{
  "version": 3,
  "sources": ["https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/signal.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/is-mutable-property.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/data.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/id.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/overload.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/cache.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/curry.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/noop.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/assign.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/create.js", "../../modules/dom/remove-range.js", "../../modules/compile/constants.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/identify.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/to-type.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/decode.js", "../../modules/dom/index-of.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/is-comment.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/is-element.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/is-fragment.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/is-text-node.js", "../../modules/dom/delete-range.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/to-type.js", "../../modules/renderer/to-text.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/remove.js", "../../modules/renderer/renderer.js", "../../modules/print.js", "../../modules/renderer/renderer-text.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/args.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/get.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/is-defined.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/arg.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/self.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/nothing.js", "../../modules/scope/safe.js", "../../modules/stash.js", "../../modules/scope.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/compile.js", "../../modules/compile/compile.js", "../../modules/compile/is-literal-string.js", "../../modules/renderer/property-names.js", "../../modules/renderer/renderer-attribute.js", "../../modules/renderer/renderer-boolean.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/trigger.js", "../../modules/config.js", "../../modules/renderer/renderer-value.js", "../../modules/renderer/renderer-checked.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/to-camel-case.js", "../../modules/renderer/renderer-dataset.js", "../../modules/renderer/renderer-style.js", "../../modules/renderer/renderer-tokens.js", "../../modules/compile/compile-attribute.js", "../../modules/compile/compile-node.js", "../../modules/template.js", "../../modules/literal.js", "../../modules/urls.js", "../../module.js"],
  "sourcesContent": ["\nconst DEBUG  = false;//window.DEBUG && window.DEBUG.signal !== false;\nconst assign = Object.assign;\n\nlet evaluatingSignal;\nlet hasInvalidDependency;\nlet id = 0;\n\n\nfunction removeInput(signal, input) {\n    // Remove input from stream\n    let i = 0;\n    while (signal[--i] && signal[i] !== input);\n    while (signal[i--]) signal[i + 1] = signal[i];\n}\n\nfunction removeOutput(signal, output) {\n    // Remove output from signal\n    let o = -1;\n    while (signal[++o] && signal[o] !== output);\n    while (signal[o++]) signal[o - 1] = signal[o];\n}\n\nfunction clearInputs(signal) {\n    let n = 0;\n    while (signal[--n]) {\n        // -------------------------- Experimental -----------------------------\n        // Stop inputs? An input with a stop method – an observer – can only have\n        // become a dependency if it were constructed during a render (they don't\n        // evaluate synchronously so they don't become dependencies otherwise).\n        // Therefore also, it can only have one output, this. Therefore it is\n        // safe to stop it. I am right about this am I not?\n        if (signal[n].stop) signal[n].stop();\n        // ---------------------------------------------------------------------\n        signal[n] = undefined;\n    }\n}\n\nfunction setDependency(signal, dependent) {\n    // Set signal as an input of dependent\n    let n = 0;\n    while (dependent[--n]) if (dependent[n] === signal) break;\n    dependent[n] = signal;\n\n    // Set dependent as an output of signal\n    n = -1;\n    while (signal[++n]) if (signal[n] === dependent) break;\n    signal[n] = dependent;\n\n    if (DEBUG) console.log(\n        '%cSignal%c connect%c ' + signal.constructor.name + '#' + signal.id + ' - ' + dependent.constructor.name + '#' + dependent.id,\n        'color: #718893; font-weight: 300;',\n        'color: #3896BF; font-weight: 300;',\n        'color: #718893; font-weight: 300;'\n    );\n}\n\nfunction invalidateDependents(signal) {\n    if (DEBUG) {\n        console.log(\n            '%cSignal%c invalidate%c ' + signal.constructor.name + '#' + signal.id + (signal.name ? ' \"' + signal.name + '\"' : ''),\n            'color: #718893; font-weight: 300;',\n            'color: #3896BF; font-weight: 300;',\n            'color: #718893; font-weight: 300;'\n        );\n    }\n\n    let n = -1;\n    let dependent;\n    while (dependent = signal[++n]) {\n        signal[n] = undefined;\n        dependent.invalidate(signal);\n    }\n}\n\nexport function hasInput(signal, input) {\n    // Check if input exists in the -ve indexes\n    let n = 0;\n    while (signal[--n]) if (signal[n] === input) return true;\n}\n\n\n/**\nSignal\n\nA signal is an object that represents a value that may change. A signal has\nessentially one property, `.value`. A state signal can have its `.value`\nwritten, a compute signal's `.value` may only be read.\n\nThe `Signal` constructor is not called directly, but calling `Signal.of(value)`\ncreates a state signal, and `Signal.from(fn)` creates a compute signal.\n**/\n\nexport default class Signal {\n    /**\n    Signal.isSignal(object)\n\n    Returns `true` where `object` is an instance of `Signal`.\n\n    This guarantees that `object` has a gettable `value` property. This is not\n    true of an Observer, which is not really a signal at all – it cannot\n    have dependencies – but is only evaluated as one when invalidated.\n    **/\n\n    static isSignal(object) {\n        return object instanceof Signal;\n    }\n\n    /**\n    Signal.of()\n    Signal.of(value)\n\n    Creates a state signal that has essentially one property, `.value`.\n    When `.value` is set the signal becomes invalid, stale, out of date,\n    irrelevant, historic, old, and any signals that depend on it are invalidated.\n    **/\n\n    static of(value) {\n        return new ValueSignal(value);\n    }\n\n    /**\n    Signal.from(fn)\n    Signal.from(promise)\n    Signal.from(stream)\n\n    Creates a compute signal from a function, where `fn` computes a value by\n    reading other signals' values. This signal is then invalidated when any of\n    the read signals are invalidated.\n\n    Creates a state signal from a promise or stream that invalidates\n    dependencies as the promise or streams' values resolve.\n    **/\n\n    static from(fn, context) {\n        // Promise\n        if (fn.then) {\n            const signal = Signal.of();\n            fn.then((value) => signal.value = value);\n            return signal;\n        }\n\n        // Pipeable\n        if (fn.pipe) {\n            return fn.pipe(new PushSignal());\n        }\n\n        // Function\n        return new ComputeSignal(fn, context);\n    }\n\n    static compute(fn, context) {\n        return new ComputeSignal(fn, context);\n    }\n\n    static fromProperty(name, object) {\n        // Function\n        return new PropertySignal(name, object);\n    }\n\n    /**\n    Signal.frame(fn, initial)\n    Returns an observe signal, a form of compute signal that calls `fn` once\n    immediately, and then on every animation frame following the invalidation\n    of any signal read during the execution of `fn`.\n    **/\n\n    static frame(fn) {\n        // Add to signals called on invalidation\n        return new FrameSignal(fn);\n    }\n\n    /**\n    Signal.tick(fn, initial)\n    Returns an observe signal, a form of compute signal that calls `fn` once\n    immediately, and then on every tick following the invalidation of any signal\n    read during the execution of `fn`.\n    **/\n\n    static tick(fn) {\n        // Add to signals called on invalidation\n        return new TickSignal(fn);\n    }\n\n    /**\n    Signal.temporal(name, object)\n    Creates a signal with an `.invalidateUntil(time)` method that maintains\n    invalidity until `time` is reached.\n    **/\n\n    static temporal(name, object) {\n        return new TimedSignal(name, object);\n    }\n\n    /**\n    Signal.evaluate(object, fn[, context])\n\n    A function for building objects that behave as compute or observe signals.\n\n    Evaluates `object` as a signal by applying it to `fn` and returning the\n    result. Signals read during `fn()` have `object` registered as a dependent,\n    so `object.invalidate()` is called when any of those signals are invalidated.\n    It's the same function as that used internally to evaluate signals.\n\n    Typically `object.invalidate()` would cue a `Signal.evaluate(object, fn)` at\n    some point in the future. (It is ill-advised to `Signal.evaluate(object, fn)`\n    synchronously inside `.invalidate()`, although this should only lead to\n    wasted cycles, not bad results... errm, in most cases, at least.)\n    **/\n\n    static evaluate(signal, fn, context = signal) {\n        // Make signal the evaluating signal for the duration of this\n        // synchronous evaluation of fn()\n        const previous = evaluatingSignal;\n        evaluatingSignal = signal;\n\n        // Clear the decks\n        if (!previous) hasInvalidDependency = false;\n\n        /*if (window.DEBUG && window.DEBUG.signal !== false) console.group(\n            '%cSignal%c evaluate%c ' + evaluatingSignal.constructor.name + '#' + evaluatingSignal.id + (evaluatingSignal.name ? ' \"' + evaluatingSignal.name + '\"' : ''),\n            'color: #718893; font-weight: 300;',\n            'color: #3896BF; font-weight: 300;',\n            'color: #718893; font-weight: 300;'\n        );*/\n\n        const value = fn.apply(context);\n\n        /*if (window.DEBUG && window.DEBUG.signal !== false) console.groupEnd();*/\n\n        evaluatingSignal = previous;\n\n        // Call synchronous updates\n        //if (!evaluatingSignal) handlers.forEach(call);\n\n        return value;\n    }\n\n    static get hasInvalidDependency() {\n        return hasInvalidDependency;\n    }\n\n    /*\n    Signal.evaluating\n    The signal that is currently being evaluated, or undefined. This is exposed\n    so that Data() can make a better call about when to create signals (if there\n    is no evaluating signal, it needn't make a signal when a property is\n    accessed). Deliberately undocumented.\n    */\n\n    static get evaluating() {\n        return evaluatingSignal;\n    }\n\n    constructor(name) {\n        if (name) this.name = name;\n\n        if (DEBUG) {\n            this.id = ++id;\n            console.log(\n                '%cSignal%c create%c ' + this.constructor.name + '#' + this.id + (this.name ? ' \"' + this.name + '\"' : ''),\n                'color: #718893; font-weight: 300;',\n                'color: #3896BF; font-weight: 300;',\n                'color: #718893; font-weight: 300;'\n            );\n        }\n    }\n\n    /**\n    .valueOf()\n\n    Enables direct use in some expressions like addition or string concatenation.\n    This may prove to be less useful than we think. For one thing, logging a\n    signal object now evaluates it, affecting the outcome.\n    **/\n\n    valueOf() {\n        return this.value;\n    }\n\n    /*\n    .toString()\n    .toJSON()\n\n    Treat `.value` as the value to output?\n    */\n\n    toString() {\n        return this.value + '' ;\n    }\n\n    toJSON() {\n        return this.value;\n    }\n}\n\n\n/*\nValueSignal(value)\n*/\n\nclass ValueSignal extends Signal {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    /**\n    .value\n\n    Getting `.value` gets value from the cache.\n\n    Setting `.value`, assuming the newly set value differs from the previous\n    value, updates the cache and invalidates dependent signals.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        return this.#value;\n    }\n\n    set value(value) {\n        // Don't update for no change in value\n        if(this.#value === value) return;\n\n        // Set cached value\n        this.#value = value;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble but #valid is true and #value is set so\n        // that's ok I think?\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nPushSignal(value)\nAn consumer interface that allows you to terminate a Stream in a signal.\n\n```js\nStream.of(1).pipe(new PushSignal())\n```\n*/\n\nclass PushSignal extends Signal {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    /**\n    .value\n    Getting `.value` gets value from the cache.\n    **/\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        return this.#value;\n    }\n\n    /**\n    .push(value)\n    Updates the cache with `value` and invalidates dependent signals.\n    **/\n    push(value) {\n        // Don't update for no change in value\n        if(this.#value === value) return;\n\n        // Set cached value\n        this.#value = value;\n\n        // Invalidate dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nPropertySignal(value)\nWraps a property in a signal. TODO: is this really needed?\n*/\n\nclass PropertySignal extends Signal {\n    // Privates\n    #valid;\n    #value;\n\n    constructor(name, object) {\n        super(name);\n        this.object = object;\n    }\n\n    evaluate() {\n        return this.object[this.name];\n    }\n\n    /**\n    .value\n    Getting `.value` gets a cached value or, if the signal is invalid,\n    evaluates (and caches) value from `fn()`. During evaluation this signal is\n    registered as dependent on other signals whose value is got.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        if (this.#valid) return this.#value;\n        this.#value = Signal.evaluate(this, this.evaluate, this);\n        if (!hasInvalidDependency) this.#valid = true;\n        return this.#value;\n    }\n\n    set value(value) {\n        // Don't update for no change in value.\n        if(this.#value === value) return;\n\n        const { object, name } = this;\n\n        // Set value on object and update value from object in case target is\n        // doing something funky with property descriptors that return a\n        // different value from the value set.\n        object[name] = value;\n        value = object[name];\n\n        // Don't invalidate for no change in value.\n        if(this.#value === value) return;\n\n        // Set cache by reading value back off the object in case object is\n        // doing something funky with property descriptors that return a\n        // different value from the value that was set. Rare, but it can happen.\n        this.#value = value;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble but #valid is true and #value is set so\n        // that's ok I think?\n        invalidateDependents(this);\n    }\n\n    /*\n    .invalidate(signal)\n    Invalidates this signal and calls `.invalidate(this)` on all dependent\n    signals. The `signal` parameter is the signal causing the invalidation; it\n    may be `undefined`: where it exists it is verified as a current input of\n    this before this is invalidated.\n    */\n\n    invalidate(signal) {\n        if (!this.#valid) return;\n\n        // Verify that signal has the right to invalidate this to protect us\n        // against the case where a dependent is left on another signal due to\n        // an old evaluation\n        if (signal && !hasInput(this, signal)) return;\n\n        this.#valid = false;\n\n        // Clear inputs\n        clearInputs(this);\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble, as it would evaluate and cache this signal\n        // and overwrite dependents before we have finished invalidating\n        // this set of dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nComputeSignal(value)\n*/\n\nclass ComputeSignal extends Signal {\n    // Privates\n    #fn;\n    #context;\n    #valid;\n    #value;\n\n    constructor(fn, context) {\n        super();\n        this.#fn      = fn;\n        this.#context = context;\n    }\n\n    /**\n    .value\n    Getting `.value` gets a cached value or, if the signal is invalid,\n    evaluates (and caches) value from `fn()`. During evaluation this signal is\n    registered as dependent on other signals whose value is got.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        if (this.#valid) return this.#value;\n        this.#value = Signal.evaluate(this, this.#fn, this.#context);\n        if (!hasInvalidDependency) this.#valid = true;\n        return this.#value;\n    }\n\n    /*\n    .invalidate(signal)\n    Invalidates this signal and calls `.invalidate(this)` on all dependent\n    signals. The `signal` parameter is the signal causing the invalidation; it\n    may be `undefined`: where it exists it is verified as a current input of\n    this before this is invalidated.\n    */\n\n    invalidate(signal) {\n        if (!this.#valid) return;\n\n        // Verify that signal has the right to invalidate this to protect us\n        // against the case where a dependent is left on another signal due to\n        // an old evaluation\n        if (signal && !hasInput(this, signal)) return;\n\n        this.#valid = false;\n\n        // Clear inputs\n        clearInputs(this);\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble, as it would evaluate and cache this signal\n        // and overwrite dependents before we have finished invalidating\n        // this set of dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/**\nTimedSignal(name, object)\nA signal that wraps an AudioParam and remains invalid until a specified time in\nthe future. This ensures that any FrameSignal signals that depend on it keep\nrendering until automation completes.\n**/\n\nexport class TimedSignal extends Signal {\n    #validTime = 0;\n\n    constructor(name, object) {\n        super(name);\n        this.object = object;\n    }\n\n    getTime() {\n        return window.performance.now();\n    }\n\n    evaluate() {\n        return this.object[this.name];\n    }\n\n    /**\n    .value\n    Getting `.value` gets the object's value. If there's an evaluating signal,\n    it becomes dependent on this ParamSignal. The signal remains invalid until\n    the `.getTime()` reaches `.invalidateUntil(time)` time.\n    **/\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal\n        if (Signal.evaluating) {\n            setDependency(this, evaluatingSignal);\n\n            // This is a timed signal, therefore may remain invalid following an\n            // evaluation. We can't invalidate the graph while evaluating, but\n            // the invalid state must prevent dependents from becoming valid...\n            // ...so set a flag marking the current evaluation as invalid\n            if (this.getTime() < this.#validTime) hasInvalidDependency = true;\n        }\n\n        // Get the current value from the audio param\n        return this.evaluate();\n    }\n\n    // DEPRECATE\n    set value(value) {\n        console.warn('Dont really want to be setting value of TimedSignal');\n        console.trace();\n\n        // Don't update for no change in value.\n        if(this.object[this.name] === value) return;\n\n        // Update value and invalidate until now\n        this.object[this.name] = value;\n        invalidateUntil(this.getTime());\n    }\n\n    /**\n    .invalidateUntil(time)\n    Sets a time at which this signal becomes valid. Until this time is reached\n    the signal remains invalid, causing dependent observer signals to keep\n    observing.\n    **/\n    invalidateUntil(time) {\n        // Don't do anything if the #validTime isn't changing ... Hmmm ... see\n        // below. I think this condition suffers the same problem.\n        //if (time === this.#validTime) return;\n\n        const currentTime = this.getTime();\n        const isValid     = currentTime >= this.#validTime;\n\n        // Update the #validTime\n        this.#validTime = time;\n\n        // If we are moving into a valid state do nothing ... Hmmmmmm ...\n        // This condition interferes with being able to invalidate a time in the\n        // past, which we may want to do for example for latency compensation.\n        // If we are calling .invalidateUntil(), I think we can assume something\n        // has changed and we need to invalidate unless we were already invalid.\n        //if (currentTime > time) return;\n\n        // If we are moving out of a valid state invalid dependents\n        if (isValid) invalidateDependents(this);\n    }\n}\n\n\n/*\nObserver(evaluate)\nAn Observer is a signal that schedules it's own evaluation. It calls `evaluate`\non construction and again on every cue following an invalidation of any signal\nread by `evaluate`. Internal only, sub-classed by `TickSignal` and `FrameSignal`.\n*/\n\nclass Observer extends Signal {\n    constructor(fn) {\n        super();\n\n        if (DEBUG) {\n            this.id = ++id;\n            console.log(\n                '%cSignal%c create%c ' + this.constructor.name + '#' + this.id + (this.name ? ' \"' + this.name + '\"' : ''),\n                'color: #718893; font-weight: 300;',\n                'color: #3896BF; font-weight: 300;',\n                'color: #718893; font-weight: 300;'\n            );\n        }\n\n        // Check we are not currently evaluating. This would be bad because an\n        // evaluation is ephemereal – it may run again, leaving this signal in\n        // memory yet superseded by the one created in the latest evaluation.\n        if (evaluatingSignal) {\n            // ------------------------ Experimental ---------------------------\n            // We can set this as an input of evaluatingSignal. this will never\n            // invalidate evaluatingSignal – it has no mechanism to do so – but\n            // when evaluatingSignal is invalidated this will be stopped.\n            let n = 0;\n            while (evaluatingSignal[--n]) if (evaluatingSignal[n] === this) break;\n            evaluatingSignal[n] = this;\n            // -----------------------------------------------------------------\n\n            // The old way was to throw an error.\n            // Make recovery possible? I'm not convinced this works in all cases\n            // but it works where an observer is instantiated inside an observer\n            //evaluatingSignal = undefined;\n            //throw new Error('Illegal nested ' + this.constructor.name + ' – cannot instantiate observer during signal evaluation');\n        }\n\n        // If no fn passed in we do not want to evaluate the signal immediately.\n        // This provides for a sub-class to define .evaluate() and launch it\n        // when it likes, as in Literal's Renderer.\n        if (!fn) return;\n\n        // Set fn as evaluation function\n        this.evaluate = fn;\n\n        // An initial, synchronous evaluation binds this observer to changes\n        if (Signal.evaluate(this, this.evaluate) || hasInvalidDependency) this.cue();\n    }\n\n    invalidate(input) {\n        // Static observers list\n        const observers = this.constructor.observers;\n\n        // If the observer is already cued do nothing\n        if (observers.indexOf(this) !== -1) return;\n\n        // Verify that input signal has the right to invalidate this\n        if (input && !hasInput(this, input)) return;\n\n        // Clear inputs\n        clearInputs(this);\n\n        this.cue();\n    }\n\n    stop() {\n        // Remove this from signal graph\n        let n = 0, input;\n        while (input = this[--n]) {\n            let m = -1;\n            this[n] = undefined;\n            // --------------------- Experimental ------------------------------\n            // A stopable signal has no output\n            if (input.stop) input.stop();\n            // -----------------------------------------------------------------\n            else removeOutput(input, this);\n        }\n\n        // Remove from observers if cued\n        const observers = this.constructor.observers;\n        const i = observers.indexOf(this);\n        if (i !== -1) {\n            // You cannot do this during a render cycle\n            if (observers === rendering) throw new Error('Attempt to remove observer while observers is rendering');\n            observers.splice(i, 1);\n        }\n        return this;\n    }\n\n    valueOf()  { return this; }\n    toString() { return '[object Signal]' ; }\n    toJSON()   { return; }\n}\n\nlet rendering;\n\nfunction render(observers) {\n    let n = -1, signal;\n\n    rendering = observers;\n    while (signal = observers[++n]) {\n        // Evaluate the signal, if it returns false-y, and nothing has flagged\n        // it as having invalid dependencies...\n        if (!Signal.evaluate(signal, signal.evaluate) && !hasInvalidDependency) {\n            // ...remove the signal from observers and decrement n\n            observers.splice(n--, 1);\n        }\n    }\n    rendering = undefined;\n    return observers;\n}\n\n\n/*\nTickSignal\nA TickSignal is a signal that calls `fn` on construction and again on every\ntick following an invalidation of any signal read by `fn`. Use `Signal.tick(fn)`.\n*/\n\nconst promise = Promise.resolve();\n\nfunction tick() {\n    const observers = render(TickSignal.observers);\n\n    // Where observers remain schedule the next tick\n    if (observers.length) promise.then(tick);\n}\n\nexport class TickSignal extends Observer {\n    static observers = [];\n\n    cue() {\n        const observers = this.constructor.observers;\n\n        // If no observers are cued, cue tick() on the next tick\n        if (!observers.length) promise.then(tick);\n\n        // Add this observer to observers\n        observers.push(this);\n    }\n}\n\n\n/*\nFrameSignal\n\nA FrameSignal is an observer signal that calls `fn` on construction and again\non every animation frame following an invalidation of any signal read by `fn`.\nAdditionally where the return value of `fn()` is truthy the signal remains\nactive and will evaluate on following frames until `fn()` is false-y.\n\nUse `Signal.frame(fn)` to create a FrameSignal signal.\n*/\n\nfunction frame() {\n    const observers = render(FrameSignal.observers);\n\n    // Where observers remain schedule the next frame\n    if (observers.length) requestAnimationFrame(frame);\n}\n\nexport class FrameSignal extends Observer {\n    static observers = [];\n\n    cue() {\n        const observers = this.constructor.observers;\n\n        // If no observers are cued, cue frame() on the next frame\n        if (!observers.length) window.requestAnimationFrame(frame);\n\n        // Add this observer to observers\n        observers.push(this);\n    }\n}\n", "\nexport default function isMutableProperty(name, object) {\n    // If there's a descriptor return its mutability\n    const descriptor = Object.getOwnPropertyDescriptor(object, name);\n    if (descriptor) return descriptor.writable || !!descriptor.set ;\n\n    // If there's a prototype look for property on it\n    const prototype = Object.getPrototypeOf(object);\n    if (prototype) return isMutableProperty(prototype, name);\n\n    // If there is no prototypes property must be unset\n    return true;\n}\n", "\nimport Signal from './signal.js';\nimport isMutableProperty from './is-mutable-property.js';\n\n\nconst assign       = Object.assign;\nconst define       = Object.defineProperties;\nconst isExtensible = Object.isExtensible;\nconst O            = Object.prototype;\nconst $trap        = Symbol('data');\nconst properties   = { [$trap]: {} };\n\n\nfunction isMuteable(object) {\n    // Many built-in objects and DOM objects bork when calling their\n    // methods via a proxy. They should be considered not observable.\n    // I wish there were a way of whitelisting rather than\n    // blacklisting, but it would seem not.\n\n    return object\n        // Reject primitives and other frozen objects\n        // This is really slow...\n        //&& !isFrozen(object)\n        // I haven't compared this, but it's necessary for audio nodes\n        // at least, but then only because we're extending with symbols...\n        // hmmm, that may need to change...\n        && isExtensible(object)\n        // This is less safe but faster.\n        //&& (typeof object === 'object' || typeof object === 'function')\n\n        // Reject DOM nodes\n        && !Node.prototype.isPrototypeOf(object)\n        // Reject WebAudio context\n        && (window.BaseAudioContext === undefined || !BaseAudioContext.prototype.isPrototypeOf(object))\n        // Reject WebAudio params\n        && !AudioParam.prototype.isPrototypeOf(object)\n        // Reject date, their methods don't enjoy being proxied\n        && !(object instanceof Date)\n        // Reject regex\n        && !(object instanceof RegExp)\n        // Reject maps\n        && !(object instanceof Map)\n        && !(object instanceof WeakMap)\n        // Reject sets\n        && !(object instanceof Set)\n        && !(window.WeakSet && object instanceof WeakSet);\n        // Reject TypedArrays and DataViews. They don't enjoy having their\n        // methods called from a proxy. On the other hand, it is useful to be\n        // able to observe them...\n        //&& !ArrayBuffer.isView(object) ;\n}\n\nfunction getSignal(signals, name, object) {\n    return signals[name] || (signals[name] = Data.toSignal(name, object));\n}\n\nfunction getValue(signals, name, object) {\n    // If there is an evaluating signal and the property is mutable\n    return (Signal.evaluating && isMutableProperty(name, object)) ?\n        // ...read value from the signal graph\n        getSignal(signals, name, object).value :\n        // ...otherwise there is no need to register the get\n        object[name] ;\n}\n\nfunction getTrap(object) {\n    return Data(object) && object[$trap];\n}\n\n\n/*\nDataTrap(object)\n*/\n\nfunction DataTrap(object) {\n    this.signals = {};\n    this.object  = object;\n    this.data    = new Proxy(object, this);\n\n    // Define trap as object[$trap]\n    properties[$trap].value = this;\n    define(object, properties);\n}\n\nassign(DataTrap.prototype, {\n    get: function get(object, name, proxy) {\n        // Don't observe changes to symbol properties or the constructor, and\n        // don't allow Safari to log __proto__ as a Proxy. That's dangerous! It\n        // pollutes Object.prototype with [$trap], which breaks everything.\n        if (typeof name === 'symbol' || name === 'constructor' || name === '__proto__') {\n            return object[name];\n        }\n\n        const value = getValue(this.signals, name, object);\n        //console.log(value, !!Signal.evaluating, isMutableProperty(name, object));\n\n        // We are not interested in getting proxies of stuff in the prototype\n        // chain so stick to hasOwnProperty. TODO: ARE WE REALLY NOT, THO? What\n        // about values returned by getters? Eh?\n        /*if (!O.hasOwnProperty.call(object, name)) {\n            return value;\n        }*/\n\n        // Return data proxy. There's a problem here. If object[name] is not\n        // writable AND not configurable returning a proxy of value throws\n        // an error regardless as to whether value is itself proxy-able\n        return Data(value) || value ;\n    },\n\n    set: function set(object, name, value, proxy) {\n        if (typeof name === 'symbol' || name === '__proto__') {\n            object[name] = value;\n            return true;\n        }\n\n        // To support arrays keep a note of pre-change length\n        const length = object.length;\n\n        // Set unproxied value on signal or directly on object\n        if (this.signals[name]) {\n            // Make sure we are setting an unproxied value.\n            this.signals[name].value = Data.objectOf(value);\n        }\n        else {\n            object[name] = Data.objectOf(value);\n        }\n\n        // Check if length has changed and update its signal if it has\n        if (name !== 'length' && object.length !== length && this.signals.length) {\n            this.signals.length.value = object.length;\n        }\n\n        // Return true to indicate success to Proxy\n        return true;\n    },\n\n    deleteProperty: function(object, name) {\n        delete object[name];\n\n        if (typeof name !== 'symbol' && name !== '__proto__' && this.signals[name]) {\n            this.signals[name].value = object[name];\n        }\n\n        // Indicate success to the Proxy\n        return true;\n    }\n});\n\n\n/*\nData(object, force)\nForces creation of an observer even where Data would normally consider\nthe object 'immutable'. Data considers DOM nodes immutable, for example, but\nnot because they are really immutable, more in order to prevent you calling node\nmethods on a node's observer proxy, which is a source of hard-to-trace errors.\nPass in `force` as `true` if you know what you are doing.\n*/\n\nexport default function Data(object, force) {\n    return !object ? undefined :\n        object[$trap] ? object[$trap].data :\n        (force || isMuteable(object)) ? (new DataTrap(object)).data :\n        undefined ;\n}\n\n/**\nData.of(object)\n\nReturns the data proxy of `object`. The data proxy is a wrapper that observes\nmutations made to `object`. There is only ever one data proxy of `object`, and\ncalls to `Data.of(object)` always return that data proxy.\n\n_Getting_ a property of a data proxy while evaluating a signal registers the\nsignal as dependent on the property. _Setting_ a property of a data proxy\nnotifies dependent signals.\n\nGetting a property of a data proxy returns a data proxy of that property\nof `object`. In this way access chains like `data.property.value` are also\nobserved.\n\nNot all objects may be proxied. Frozen objects, unextensible objects, and\nvarious others like Sets, Maps and DOM and WebAudio nodes are deemed\nimmutable or otherwise unobservable. They return `undefined`.\n**/\n\nData.of = (object, force) => Data(object, force);\n\n/**\nData.objectOf(data)\n\nReturns the un-proxied `object` wrapped by `Data.of(object)`, or, if `data` is\nalready just an object, `data`. Getting and setting properties of `object` has\nno effect on the data proxy.\n**/\n\nData.objectOf = function(object) {\n    return object && object[$trap] ?\n        object[$trap].object :\n        object ;\n};\n\n\n/**\nData.toSignal(name, object)\nThe internals of the Data proxy call this function when a signal is created.\nNormally it is assumed that Data proxies use property signals and this function\nis set to `Signal.forProperty`. Override it to opt for different types of\nsignals.\n**/\nData.toSignal = Signal.fromProperty;\n\n\n/*\nData.signal(path, data)\n*/\n\nData.signal = function(name, object) {\n    const trap = Data.of(object) && object[$trap];\n    return trap ?\n        getSignal(trap.signals, name, trap.object) :\n        nothing ;\n};\n", "/**\nid(value)\nReturns `value`.\n**/\n\nexport default function id(value) { return value; }\n", "/**\noverload(fn, object)\n\nReturns an overloaded.\n\nTakes a `fn` that returns a string key, and an `object` of key:function\npairs. The returned function calls `fn` with all arguments to get a key,\nthen calls the function at `object[key]` with all arguments.\n\nWhere `fn` returns `undefined`, `object.default` is called if it is defined\nin `object`, otherwise `overload` throws a 'no function defined for key' error.\n\n```\nvar handleEvent = overload(get('type'), {\n    click:   (e) => {...},\n    input:   (e) => {...},\n    default: (e) => {...}\n});\n```\n*/\n\n\nexport default function overload(fn, map) {\n    return function overload() {\n        const key     = fn.apply(this, arguments);\n        const handler = (map[key] || map.default);\n\n        if (!handler) {\n            throw new Error('overload() no function defined for key \"' + key + '\"');\n        }\n\n        return handler.apply(this, arguments);\n    };\n}\n", "/**\ncache(fn)\nReturns a function that caches the output values of `fn(input)` against input\nvalues in a map, such that for each input value `fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cacheByObject(fn) {\n    var map = new Map();\n\n    return function cache(object) {\n        if (window.DEBUG && !warned && object === undefined) {\n            warned = true;\n            console.warn('cache() called with undefined. Not illegal, but potentially bad.');\n        }\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cache() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        if (map.has(object)) {\n            return map.get(object);\n        }\n\n        var value = fn(object);\n        map.set(object, value);\n        return value;\n    };\n}\n", "/**\ncurry(fn [, muteable, arity])\nReturns a function that wraps `fn` and makes it partially applicable.\n*/\n\nimport cache from './cache.js';\n\nconst A     = Array.prototype;\n\nfunction applyFn(fn, args) {\n    return typeof fn === 'function' ? fn.apply(null, args) : fn ;\n}\n\nfunction curry(fn, muteable, arity) {\n    arity = arity || fn.length;\n\n    var memo = arity === 1 ?\n        // Don't cache if `muteable` flag is true\n        muteable ? fn : cache(fn) :\n\n        // It's ok to always cache intermediate memos, though\n        cache(function(object) {\n            return curry(function() {\n                var args = [object];\n                args.push.apply(args, arguments);\n                return fn.apply(null, args);\n            }, muteable, arity - 1) ;\n        }) ;\n\n    return function partial(object) {\n        return arguments.length === 0 ?\n            partial :\n        arguments.length === 1 ?\n            memo(object) :\n        arguments.length >= arity ?\n            fn.apply(null, arguments) :\n        // This is bad, I think. We don't want [[fn],[fn]].map(get(0)) to be firing the fns\n        //arguments.length > arity ?\n        //    applyFn(fn.apply(null, A.splice.call(arguments, 0, arity)), arguments) :\n        applyFn(memo(object), A.slice.call(arguments, 1)) ;\n    };\n}\n\n//function curry(fn, muteable, arity) {\n//    arity = arity || fn.length;\n//    return function curried() {\n//        return arguments.length >= arity ?\n//            fn.apply(null, arguments) :\n//            curried.bind(null, ...arguments) ;\n//    };\n//}\n\nif (window.DEBUG) {\n    const _curry = curry;\n\n    // Feature test\n\tconst isFunctionLengthDefineable = (function() {\n\t\tvar fn = function() {};\n\n\t\ttry {\n\t\t\t// Can't do this on Safari - length non configurable :(\n\t\t\tObject.defineProperty(fn, 'length', { value: 2 });\n\t\t}\n\t\tcatch(e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fn.length === 2;\n\t})();\n\n    const setFunctionProperties = function setFunctionProperties(text, parity, fn1, fn2) {\n        // Make the string representation of fn2 display parameters of fn1\n        fn2.toString = function() {\n            return /function\\s*[\\w\\d]*\\s*\\([,\\w\\d\\s]*\\)/.exec(fn1.toString()) + ' { [' + text + '] }';\n        };\n\n        // Where possible, define length so that curried functions show how\n        // many arguments they are yet expecting\n        if (isFunctionLengthDefineable) {\n            Object.defineProperty(fn2, 'length', { value: parity });\n        }\n\n        return fn2;\n    };\n\n    // Make curried functions log a pretty version of their partials\n    curry = function curry(fn, muteable, arity) {\n        arity  = arity || fn.length;\n        return setFunctionProperties('curried', arity, fn, _curry(fn, muteable, arity));\n    };\n}\n\n\nexport default curry;\n", "/**\nnoop()\nDoes nothing, returns undefined.\n**/\n\nexport default function noop() {}\n", "/**\nassign(node, properties)\n\nAssigns each property of `properties` to `node`, as a property where that\nproperty exists in `node`, otherwise as an attribute.\n\nIf `properties` has a property `'children'` it must be an array of nodes;\nthey are appended to 'node'.\n\nThe property `'html'` is aliased to `'innerHTML'`. The property `'text'`\nis aliased to `'textContent'`. The property `'tag'` is treated as an alias\nof `'tagName'` (which is ignored, as `node.tagName` is read-only). The\nproperty `'is'` is also ignored.\n*/\n\nimport curry from 'fn/curry.js';\nimport id from 'fn/id.js';\nimport noop from 'fn/noop.js';\nimport overload from 'fn/overload.js';\n\nconst assignProperty = overload(id, {\n\t// Ignore read-only properties or attributes\n\tis: noop,\n\ttag: noop,\n\n\tdata: function(name, node, object) {\n\t\t// Strip undefined\n\t\tfor (name in object) {\n\t\t\tif (object[name] === undefined) {\n\t\t\t\tdelete object[name];\n\t\t\t}\n\t\t}\n\n\t\tObject.assign(node.dataset, object);\n\t},\n\n\tdataset: function(name, node, object) {\n        // Strip undefined\n        for (name in object) {\n            if (object[name] === undefined) {\n                delete object[name];\n            }\n        }\n\n\t\tObject.assign(node.dataset, object);\n\t},\n\n\thtml: function(name, node, content) {\n\t\tnode.innerHTML = content;\n\t},\n\n\ttext: function(name, node, content) {\n\t\tnode.textContent = content;\n\t},\n\n\tstyle: overload((name, node, content) => typeof content, {\n\t\tstring: (name, node, content) => node.style = content,\n\t\tobject: (name, node, content) => Object.assign(node.style, content)\n\t}),\n\n\tchildren: function(name, node, content) {\n\t\t// Empty the node and append children\n\t\tnode.innerHTML = '';\n\t\tnode.append.apply(node, content);\n\t},\n\n\t// SVG elements have a read-only properties, and must be set as string\n\t// attributes. Todo: explore the SVG property API to make these take\n\t// advantage of it\n    href: function(name, node, content) {\n        if (node instanceof SVGElement) {\n            node.setAttribute('href', content);\n        }\n        else {\n            node.href = content;\n        }\n    },\n\n\tpoints:    setAttribute,\n    cx:        setAttribute,\n    cy:        setAttribute,\n    r:         setAttribute,\n\tx:         setAttribute,\n\ty:         setAttribute,\n\tdx:        setAttribute,\n\tdy:        setAttribute,\n\ttransform: setAttribute,\n    preserveAspectRatio: setAttribute,\n    viewBox:   setAttribute,\n\n\tdefault: function(name, node, content) {\n\t\tif (name in node) {\n\t\t\tnode[name] = content;\n\t\t}\n\t\telse {\n\t\t\tnode.setAttribute(name, content);\n\t\t}\n\t}\n});\n\nfunction setAttribute(name, node, content) {\n\tnode.setAttribute(name, content);\n}\n\nexport function assign(node, attributes) {\n\tvar names = Object.keys(attributes);\n\tvar n = names.length;\n    while (n--) assignProperty(names[n], node, attributes[names[n]]);\n\treturn node;\n}\n\nexport default curry(assign, true);\n", "\nimport id       from 'fn/id.js';\nimport overload from 'fn/overload.js';\nimport assign   from './assign.js';\n\nconst svgNamespace = 'http://www.w3.org/2000/svg';\n\nconst template      = document.createElement('template');\nconst typeofContent = (type, content) => (content && typeof content);\n\n// Constructors\n\nfunction createContextFragment(context, html = '') {\n    const range = document.createRange();\n    range.selectNode(context);\n    return range.createContextualFragment(html);\n}\n\nconst createSVG = overload(typeofContent, {\n    string: function(tag, html) {\n        const node = document.createElementNS(svgNamespace, tag);\n        node.innerHTML = html;\n        return node;\n    },\n\n    object: function(tag, object) {\n        const node = document.createElementNS(svgNamespace, tag);\n\n        // Is it array-like?\n        if (typeof object.length === 'number') {\n            // Be careful here in case object is a live NodeList, which will\n            // mutate as you iterate over it. Applying object to .append()\n            // appears to not have this problem, and will work on arrays.\n            node.append.apply(node, object);\n        }\n        else {\n            assign(node, object);\n        }\n\n        return node;\n    },\n\n    default: (tag) => document.createElementNS(svgNamespace, tag)\n});\n\nconst createHTML = overload(typeofContent, {\n    string: function(tag, html) {\n        const node = document.createElement(tag);\n        node.innerHTML = html;\n        return node;\n    },\n\n    object: function(tag, object) {\n        const node = document.createElement(tag);\n\n        // Is it array-like?\n        if (typeof object.length === 'number') {\n            // Be careful here in case object is a live NodeList, which will\n            // mutate as you iterate over it. Applying object to .append()\n            // appears to not have this problem, and will work on arrays.\n            node.append.apply(node, object);\n        }\n        else {\n            assign(node, object);\n        }\n\n        return node;\n    },\n\n    default: (tag) => document.createElement(tag)\n});\n\n/**\ncreate(tag, content)\n\nConstructs and returns a new DOM node.\n\n- If `tag` is `\"text\"` a text node is created.\n- If `tag` is `\"fragment\"` a fragment is created.\n- If `tag` is `\"comment\"` a comment is created.\n- If `tag` is any other string the element `<tag></tag>` is created.\n\nWhere a comment or text node is created `content` must be a string, as is set as\ntextContent. For fragments and other nodes:\n\n- If `content` is a string it is set as innerHTML.\n- If `content` is array-like its items are appended to node. Note that where\n`content` is a NodeList, this removes nodes from whatever the NodeList belongs\nto.\n- If `content` is an object its properties are assigned as node properties or\nattributes.\n\n##### `create(tag, content, context)`\n\nWhere `tag` is `fragment` there is an optional third parameter `context`, which\nmust be an element. The fragment parser is run in the context of this element.\n\n```\ncreate('fragment', '<li>', create('ul'));\n```\n**/\n\nconst create = overload(id, {\n    comment: function(tag, text) {\n        return document.createComment(text || '');\n    },\n\n    fragment: overload(typeofContent, {\n        string: function(tag, html, context) {\n            if (context) {\n                return createContextFragment(context, html);\n            }\n\n            template.innerHTML = html;\n            return template.content.cloneNode(true);\n        },\n\n        object: function(tag, object, context) {\n            // If there is context, create a context-aware fragment\n            const fragment = context ?\n                createContextFragment(context) :\n                document.createDocumentFragment() ;\n\n            // Is object array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                fragment.append.apply(fragment, object);\n            }\n            else {\n                assign(fragment, object);\n            }\n\n            return fragment;\n        },\n\n        default: () => document.createDocumentFragment()\n    }),\n\n    /*text: function (tag, text) {\n        return document.createTextNode(text || '');\n    },*/\n\n    circle:   createSVG,\n    ellipse:  createSVG,\n    g:        createSVG,\n    glyph:    createSVG,\n    image:    createSVG,\n    line:     createSVG,\n    rect:     createSVG,\n    use:      createSVG,\n    path:     createSVG,\n    pattern:  createSVG,\n    polygon:  createSVG,\n    polyline: createSVG,\n    svg:      createSVG,\n    tspan:    createSVG,\n    text:     createSVG,\n\n    default:  createHTML\n});\n\nexport default create;\n\n", "export default function removeRange(first, last) {\n    if (window.DEBUG && first.parentNode !== last.parentNode) {\n        throw new Error('first and last not children of same parent')\n    }\n\n    if (first === last) {\n        if (window.DEBUG) ++stats.remove;\n        return last;\n    }\n\n    // Select range of nodes managed by this template\n    const range = new Range();\n    range.setStartBefore(first);\n    range.setEndAfter(last);\n\n    // Remove range content from DOM\n    // THIS DOES NTO DO WHAT WE THINK IT DOES!!!!!! IT CLONES NODES!!!\n    return range.extractContents();\n}\n", "\n// Use > as a path separator as it is not valid in attribute names\nexport const pathSeparator = '>';\n\n// Indentation in compiled functions\nexport const line   = window.DEBUG ? '\\n' : '' ;\nexport const indent = window.DEBUG ? '  ' : '' ;\n", "/**\nidentify(node)\nidentify(node, prefix)\nidentify(node, prefix, root)\n\nReturns the id of `node`, or where `node` has no id, a random id is generated,\nchecked against the root node (document or shadowRoot) for uniqueness, set on\n`node` and returned:\n\n```js\n// Get ids of all buttons in document\nselect('button', document)\n.map(identify)\n.forEach((id) => ...)\n```\n\nThis will return useless results if `node` is in a fragment, as root node is\nthe fragment so ids will not be checked against a document or shadowRoot.\n**/\n\nexport default function identify(node, prefix = 'id-', root = (node.getRootNode && node.getRootNode() || document)) {\n\tlet id = node.id;\n\n\tif (!id) {\n\t\tdo { id = prefix + Math.ceil(Math.random() * 1000000); }\n\t\twhile (root.getElementById(id));\n\t\tnode.id = id;\n\t}\n\n\treturn id;\n}\n", "\n/**\ntoType(node)\n\nReturns one of `'element'`, `'text'`, `'comment'`, `'document'`,\n`'doctype'` or `'fragment'`.\n**/\n\nvar types = {\n    1:  'element',\n    3:  'text',\n    8:  'comment',\n    9:  'document',\n    10: 'doctype',\n    11: 'fragment'\n};\n\nexport default function toType(node) {\n    return types[node.nodeType];\n}\n", "\nconst textarea = document.createElement('textarea');\n\nexport default function decode(html) {\n    // Converts &amp;, &lt; and &gt; to &, < and >\n    textarea.innerHTML = html;\n    return textarea.value;\n}\n", "\nconst A = Array.prototype;\n\nexport default function indexOf(node) {\n    // Get the index of a DOM node\n    return A.indexOf.apply(node.parentNode.childNodes, arguments);\n}\n", "/**\nisComment(node)\nReturns `true` if `node` is a comment.\n**/\n\nexport default function isComment(node) {\n    return node.nodeType === 8;\n}\n", "/**\nisElement(node)\nReturns `true` if `node` is an element node.\n**/\n\nexport default function isElement(node) {\n    return node.nodeType === 1;\n}\n", "/**\nisFragment(node)\nReturns `true` if `node` is a fragment.\n**/\n\nexport default function isFragment(node) {\n    return node.nodeType === 11;\n}\n", "\n/**\nisTextNode(node)\nReturns `true` if `node` is a text node.\n**/\n\nexport default function isTextNode(node) {\n    return node.nodeType === 3;\n}\n", "\nexport default function deleteRange(first, last) {\n    if (window.DEBUG && first.parentNode !== last.parentNode) {\n        throw new Error('deleteRange: first and last not children of same parent')\n    }\n\n    if (first === last) {\n        last.remove();\n        return;\n    }\n\n    // Select range of nodes and remove\n    const range = new Range();\n    range.setStartBefore(first);\n    range.setEndBefore(last);\n    range.deleteContents();\n}\n", "/**\ntoType(object)\nReturns `typeof object`.\n*/\n\nexport default (object) => typeof object;\n", "\nimport id       from 'fn/id.js';\nimport overload from 'fn/overload.js';\nimport toType   from 'fn/to-type.js';\nimport Signal   from 'fn/signal.js';\n\n/**\nTemplate expressions\n\nExpressions may evaluate to a **string** or other **primitive**, a **DOM node**\nor **fragment**, an **array** of values, another **renderer**, or even an\nasynchronous value in a **promise** or a **stream**.\n\n**Falsy** values other than `false` and `0` – `undefined`, `null` or `NaN` –  don't\nrender at all.\n\n**Arrays** are flattened and joined (without spaces or commas).\n\n**Promises** and **streams** are rendered asynchronously when they emit values.\n\nLiteral flattens nested collections. A _stream_ of _arrays_ of _strings_ will\nrender text whenever the stream emits an array of strings.\n\n<table class=\"striped-table x-bleed\">\n    <thead>\n        <tr>\n            <th style=\"width:20%;\">Type</th>\n            <th>Expression</th>\n            <th style=\"width:30%;\">Renders as</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>undefined</th>\n            <th><code>${ undefined }</code></th>\n            <td>\n                <template is=\"literal-html\">${ undefined }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>null</th>\n            <th><code>${ null }</code></th>\n            <td>\n                <template is=\"literal-html\">${ null }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>NaN</th>\n            <th><code>${ NaN }</code></th>\n            <td>\n                <template is=\"literal-html\">${ NaN }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>String</th>\n            <th><code>${ 'Hello' }</code></th>\n            <td>\n                <template is=\"literal-html\">${ 'Hello' }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Boolean</th>\n            <th><code>${ true }, ${ false }</code></th>\n            <td>\n                <template is=\"literal-html\">${ true }, ${ false }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Number</th>\n            <th><code>${ 123.4 }</code></th>\n            <td>\n                <template is=\"literal-html\">${ 123.4 }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Infinity</th>\n            <th><code>${ Infinity }, ${ -Infinity }</code></th>\n            <td>\n                <template is=\"literal-html\">${ Infinity }, ${ -Infinity }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Function</th>\n            <th><code>${ function name(param) {} }</code></th>\n            <td>\n                <template is=\"literal-html\">${ function name(param) {} }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Arrow</th>\n            <th><code>${ (param) => {} }</code></th>\n            <td>\n                <template is=\"literal-html\">${ (param) => {} }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>RegExp</th>\n            <th><code>${ /^regexp/ }</code></th>\n            <td>\n                <template is=\"literal-html\">${ /^regexp/ }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Symbol</th>\n            <th><code>${ Symbol('name') }</code></th>\n            <td>\n                <template is=\"literal-html\">${ Symbol('name') }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Array</th>\n            <th><code>${ [0, 1, 2, 3] }</code></th>\n            <td>\n                <template is=\"literal-html\">${ [0, 1, 2, 3] }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Object</th>\n            <th><code>${ { property: 'value' } }</code></th>\n            <td>\n                <template is=\"literal-html\">${ { property: 'value' } }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Node</th>\n            <th><code>${ document.createTextNode('Hello') }</code></th>\n            <td>\n                <template is=\"literal-html\">${ document.createTextNode('Hello') }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Promise</th>\n            <th><code>${ Promise.resolve('yoohoo') }</code></th>\n            <td>\n                <template is=\"literal-html\">${ Promise.resolve('yoohoo') }</template>\n            </td>\n        </tr>\n        <tr>\n            <th>Stream</th>\n            <th><code>${ events('pointermove', body)<br/>\n            &nbsp;&nbsp;.map((e) => round(e.pageX)) }</code></th>\n            <td>\n                <template is=\"literal-html\">${ events('pointermove', body).map((e) => round(e.pageX)) }</template>\n            </td>\n        </tr>\n    </tbody>\n</table>\n**/\n\n\n// Matches the arguments list in the result of fn.toString()\nconst rarrowents = /\\s*(\\([\\w,\\s]*\\))/;\nconst rarguments = /function(?:\\s+\\w+)?\\s*(\\([\\w,\\s]*\\))/;\n\nconst toText = overload(toType, {\n    'boolean': id,\n\n    'function': (value) => (\n        // Print function name and parameters\n        value.prototype ?\n            (value.name || 'function') + (rarguments.exec(value.toString()) || [])[1] :\n            (rarrowents.exec(value.toString()) || [])[1] + ' ⇒ {…}'\n    ),\n\n    'number': (value) => (\n        // Convert NaN to empty string and Infinity to ∞ symbol\n        Number.isNaN(value) ? '' :\n        Number.isFinite(value) ? value + '' :\n        value < 0 ? '-∞' : '∞'\n    ),\n\n    'string': id,\n\n    'symbol': (value) => value.toString(),\n\n    'undefined': (value) => '',\n\n    'object': overload((object) => (object && object.constructor.name), {\n        'Array':   (object) => object.map(toText).join(''),\n        'RegExp':  (object) => '/' + object.source + '/',\n\n        // Allow signals to pass through, they get .toString() called when they\n        // are stringified into the DOM.\n        [Signal.name]: id,\n\n        'default': (object) => {\n            // So. Streams and other objects with circular references fail to\n            // stringify. It would be nice if we could catch streams first seeing\n            // as we so regularly return them from expressions (eg. `${ events(...) }`),\n            // but builders have a nasty habit of rewriting constructor names, and\n            // it is difficult to see how to detect them without importing the\n            // Stream constructor, and I don't want to do that because that would\n            // create a dependency on Stream that we don't really need.\n\n            /*\n            try {\n                return JSON.stringify(object, null, 2);\n            }\n            catch(e) {\n                return '';\n            }\n            */\n\n            // But saying that, why are we returning stringified JSON at all?\n            return  '';\n        }\n    }),\n\n    'default': JSON.stringify\n});\n\nexport default toText;\n", "/**\nremove(array, value)\nRemove `value` from `array`. Where `value` is not in `array`, does nothing.\n**/\n\nexport default function remove(array, value) {\n    if (array.remove) { array.remove(value); }\n\n    let i;\n    while ((i = array.indexOf(value)) !== -1) {\n        array.splice(i, 1);\n    }\n\n    return array;\n}\n", "\nimport remove  from 'fn/remove.js';\nimport Data    from 'fn/data.js';\nimport { FrameSignal } from 'fn/signal.js';\nimport Literal from '../literal.js';\n\n\nfunction stop(stopable) {\n    stopable.stop();\n}\n\nfunction promiseStop() {\n    this.status === 'done';\n}\n\nfunction renderValue(renderer, args, values, n, object, isRender = false) {\n    if (object && typeof object === 'object') {\n        // Avoid having property gets registered as observers\n        const target = Data.objectOf(object);\n\n        // Don't add literals to stopables\n        if (target instanceof Literal) return;\n\n        // Is target have .then()?\n        if (typeof target.then === 'function') {\n            const stopables = renderer.stopables || (renderer.stopables = []);\n            values[n] = '';\n\n            // You can't stop a promise, but we can flag it to be ignored\n            target.stop = promiseStop;\n            target.then((value) => {\n                if (target.status === 'done') { return; }\n                remove(stopables, target);\n                return renderValue(renderer, args, values, n, value, true);\n            });\n\n            stopables.push(target);\n            return;\n        }\n\n        // If target has a .stop() method add it to stopables, objects stopped on\n        // renderer invalidation and stop.\n        if (typeof target.stop === 'function') {\n            const stopables = renderer.stopables || (renderer.stopables = []);\n            stopables.push(target);\n        }\n\n        // If target has a .pipe() method render its piped values\n        if (typeof target.pipe === 'function') {\n            values[n] = '';\n            // Do not render synchronous values that are in the stream\n            // immediately, as they are about to be rendered by the renderer\n            let isRender = false;\n            target.pipe({ push: (value) => renderValue(renderer, args, values, n, value, isRender) });\n            isRender = true;\n            return;\n        }\n\n        // Is target an array?\n        if (typeof target.length === 'number') {\n            let i = target.length;\n            while (i--) {\n                renderValue(renderer, args, target, i, target[i]);\n            }\n        }\n    }\n\n    values[n] = object;\n\n    // If the isRender flag is set, send to render\n    if (isRender) {\n        // Todo: work out a way of cueing this render??\n        renderer.render.apply(renderer, args);\n    }\n}\n\nexport default class Renderer extends FrameSignal {\n    static consts = ['DATA', 'data', 'element', 'shadow', 'host', 'id'];\n\n    constructor(fn, parameters, compiled) {\n        // FrameSignal does not evaluate immediately when no fn passed in\n        super();\n\n        this.compiled   = compiled;\n        this.count      = 0;\n        this.fn         = fn;\n        this.parameters = parameters;\n    }\n\n    invalidate(input) {\n        // Static observers list\n        const observers = this.constructor.observers;\n\n        // If the observer is already cued do nothing\n        if (observers.indexOf(this) !== -1) return;\n\n        // Verify that input signal has the right to invalidate this\n        //if (input && !hasInput(this, input)) return;\n\n        // Clear inputs\n        //clearInputs(this);\n\n        if (this.stopables) this.stopables.forEach(stop);\n\n        this.cue();\n    }\n\n    evaluate() {\n        // Renderer may have been stopped as part of this frame's evaluation\n        // in which case it has not been removed from observers...\n        // TODO: check, not sure this is necessary\n        //if (this.status === 'done') return;\n\n        // Render count\n        ++this.count;\n\n        const { fn, parameters } = this;\n        const args = fn(parameters);\n        const strings = args[0];\n\n        // Flag the literal as containing exactly 1 expression optionally\n        // surrounded by whitespace, which allows for some optimisations\n        // further down the line, particularly for attribute renderers. We\n        // need only do this on first render.\n        if (this.singleExpression === undefined) {\n            this.singleExpression = strings.length === 2\n                && !/\\S/.test(strings[0])\n                && !/\\S/.test(strings[1]) ;\n        }\n\n        let n = 0;\n        while (strings[++n] !== undefined) renderValue(this, args, args, n, args[n]);\n        this.render.apply(this, args);\n    }\n\n    stop() {\n        if (this.stopables) this.stopables.forEach(stop);\n        return super.stop();\n    }\n}\n\nexport const stats = {};\n", "\n/**\nprint(data)\nPrints an object or objects to the DOM as a debug message.\n\n```html\n<template is=\"literal-html\" data=\"../../package.json\">\n    ${ print(data) }\n</template>\n```\n\nRenders as:\n\n<template is=\"literal-html\" data=\"../../../package.json\">\n    ${ print(data) }\n</template>\n**/\n\nimport noop    from 'fn/noop.js';\nimport Data    from 'fn/data.js';\nimport create  from 'dom/create.js';\nimport { log } from './log.js';\n\n\nconst assign = Object.assign;\n\nconst literalCSS = {\n    'box-sizing':     'border-box',\n    'position':       'relative',\n    'display':        'block',\n    /* Try to not interfere with layout of surrounding content too much */\n    'overflow':       'hidden',\n    'break-inside':   'avoid',\n    'width':          '100%',\n    'justify-self':   'stretch',\n    'align-self':     'start',\n    'text-align':     'left',\n    'font-size':      '0.75rem',\n    'font-family':    '\"Fira Mono\", Menlo, Monaco, \"Andale Mono\", monospace',\n    'font-weight':    'normal',\n    'letter-spacing': '-0.05em',\n    'line-height':    '1.5rem',\n    'border-width':   '0',\n    /* Bottom left corner underlaps <code> corner, we give it a slightly bigger\n       radius to avoid aliasing this background color through the edge. */\n    'border-radius':  '0 0.5rem 0 0.6875rem',\n    'padding':        '0 0.375rem'\n};\n\nconst literalLinkCSS = {\n    'box-sizing':     'border-box',\n    'position':       'absolute',\n    'bottom':         '0.25rem',\n    'right':          '0.25rem',\n    'z-index':        '2',\n    'padding-left':   '0',\n    'padding-right':  '0',\n    'font-size':      '0.6875em',\n    'font-family':    '\"Fira Mono\", Menlo, Monaco, \"Andale Mono\", monospace',\n    'line-height':    '1em',\n    'opacity':        '0.86666667',\n    'color':          '#81868f',\n    'background-color': 'transparent',\n    'text-decoration': 'none'\n};\n\nconst literalSmallCSS = {\n    'box-sizing':     'border-box',\n    'font-size':      '0.875em',\n    'opacity':        '0.86666667'\n};\n\nconst literalCodeCSS = {\n    'box-sizing':     'border-box',\n    'display':        'block',\n    'font-family':    'inherit',\n    /* Nothing special about this number */\n    'font-size':      '0.93333em',\n    'line-height':    '1.5em',\n    'white-space':    'normal',\n    'border-top':     'inherit',\n    'border-bottom':  'inherit',\n    'border-radius':  '0',\n    'padding':        '0.5em 0.375rem',\n    'width':          'auto',\n    'margin-left':    '-0.375rem',\n    'margin-right':   '-0.375rem',\n    'color':          '#141B1E'\n};\n\nconst literalCountCSS = {\n    'box-sizing':     'border-box',\n    'position':       'absolute',\n    'top':            '0',\n    'right':          '0.375rem'\n};\n\n\nexport const printError = window.DEBUG ? function printError(compiled, error) {\n    const template = compiled.template;\n\n    // TODO: get the data in here!\n    log('error', template.identifier + ' – ' + compiled.code, '', '', 'red');\n\n    return create('pre', {\n        children: [\n            template.identifier + ' ',\n\n            create('small', {\n                text:  compiled.code,\n                style: literalSmallCSS\n            }),\n\n            create('code', {\n                html: '<strong>' + error.constructor.name + '</strong> ' + error.message.replace(/</g, '&lt;').replace(/>/g, '&gt;'),\n                style: assign({ 'background-color': '#ffdddd' }, literalCodeCSS)\n            }),\n\n            create('a', {\n                text: 'literal',\n                href: 'https://stephen.band/literal/literal-html/',\n                style: literalLinkCSS\n            })\n        ],\n\n        style: assign({ 'color': 'white', 'background-color': '#DC0F0E' }, literalCSS)\n    });\n} : noop ;\n\nexport const printDebug = window.DEBUG ? function printDebug(renderer, error) {\n    const compiled = renderer.compiled;\n    const template = compiled.template;\n    const fullpath = compiled.path\n        + (typeof compiled.name === 'string' ? '>' + compiled.name : '') ;\n\n    const children = [\n        template.identifier + ' ',\n\n        create('small', {\n            text:  (fullpath ? '> ' + fullpath.replace(/>/g, ' > ') : ''),\n            style: literalSmallCSS\n        }),\n\n        create('span', {\n            text: renderer.count,\n            style: literalCountCSS\n        })\n    ];\n\n    let n = 0;\n    let object;\n    while ((object = arguments[++n]) !== undefined) {\n        children.push(create('code', {\n            children: [\n                create('strong', { text: object.constructor.name }),\n                JSON.stringify(object)\n            ],\n\n            style: assign({ 'background-color': '#c5dded' }, literalCodeCSS)\n        }));\n    }\n\n    children.push(create('a', {\n        text: 'literal',\n        href: 'https://stephen.band/literal/literal-html/',\n        style: literalLinkCSS\n    }));\n\n    return create('pre', {\n        children: children,\n        style: assign({ 'color': 'white', 'background-color': '#46789a' }, literalCSS)\n    });\n} : noop ;\n\nexport default function print(renderer, object) {\n    return object instanceof Error ?\n        printError(renderer.compiled, object) :\n        printDebug(renderer, object) ;\n}\n", "\n/**\nTextRenderer(source, node, path, index, message)\nConstructs an object responsible for rendering to a text node. If the result of\nprocessing the literal content is more DOM content this renderer will insert\nthat DOM after the text node.\n**/\n\nimport Signal      from 'fn/signal.js';\nimport Data        from 'fn/data.js';\nimport isComment   from 'dom/is-comment.js';\nimport isElement   from 'dom/is-element.js';\nimport isFragment  from 'dom/is-fragment.js';\nimport isTextNode  from 'dom/is-text-node.js';\nimport deleteRange from '../dom/delete-range.js';\nimport toText      from './to-text.js';\nimport Renderer, { stats } from './renderer.js';\nimport Literal     from '../literal.js';\nimport print, { printError } from '../print.js';\n\n\nconst assign = Object.assign;\nconst define = Object.defineProperties;\n\n\nfunction stop(node) {\n    node && typeof node === 'object' && node.stop && node.stop();\n}\n\nfunction notInDOM(node) {\nif (node.parentNode === null) {\n    debugger\n    console.log('NODE NOT IN DOM', node);\n}\n    return node.parentNode === null;\n}\n\nfunction setNodeValue(node, value) {\n    const nodeValue = node.nodeValue;\n\n    // textNode.nodeValue = null actually results in textNode.nodeValue = ''\n    if (nodeValue) {\n        if (nodeValue !== value) {\n            node.nodeValue = value;\n            if (window.DEBUG) ++stats.text;\n        }\n    }\n    else {\n        if (value) {\n            node.nodeValue = value;\n            if (window.DEBUG) ++stats.text;\n        }\n    }\n}\n\nfunction objectToContents(renderer, object, i) {\n    // Object may be a primitive, a DOM node or fragment, a LiteralTemplate or\n    // an array of any of these.\n    let { string, contents } = renderer;\n\n    // If object is not a node or renderer, append to string. Array.isArray()\n    // does return true for a proxy of an array.\n    if (!(object instanceof Literal)\n     && !(object instanceof Node)\n     && !Array.isArray(object)) {\n        renderer.string += toText(object);\n        return i;\n    }\n\n    // If there is a string to splice in we must do that before dealing with object\n    if (string) {\n        // And content is a text node, but not the last text node, update it\n        if (++i < contents.length - 1 && isTextNode(contents[i])) {\n            setNodeValue(contents[i], string);\n        }\n        // Otherwise create new text node and splice it into contents\n        // and the DOM\n        else {\n            const node = document.createTextNode(string);\n            contents[i].before(node);\n            if (window.DEBUG) ++stats.add;\n            contents.splice(i, 0, node);\n        }\n        // Reset string accumulator\n        renderer.string = '';\n    }\n\n    // It is possible that the template has returned the same object at the same\n    // index again, in which case we do nothing. Not hugely likely, but possible,\n    // so we may as well do the optimum thing: nothing.\n    if (object === contents[++i]) return i;\n    --i;\n\n    // Object is an array, recurse over its values\n    if (Array.isArray(object)) {\n        let n = -1;\n        while(++n < object.length) i = objectToContents(renderer, object[n], i);\n        return i;\n    }\n\n    // Object is a Literal Template\n    if (object instanceof Literal) {\n        // Get current index of object\n        const k = contents.indexOf(object);\n        // Literal Template has been previously rendered\n        if (k !== -1) {\n            // Remove object DOM nodes back to object.fragment\n            object.remove();\n            // Splice it out of contents\n            contents.splice(k, 1);\n        }\n\n        // Add content into DOM and splice object into contents\n        contents[++i].before(object.fragment);\n        if (window.DEBUG) ++stats.add;\n        contents.splice(i, 0, object);\n        return i;\n    }\n\n    // Object is a fragment\n    if (isFragment(object)) {\n        const l = object.childNodes.length;\n        const m = contents[++i];\n        contents.splice(i, 0, ...object.childNodes);\n        m.before(object);\n        return i + l - 1;\n    }\n\n    // Object is a DOM node\n    if (isTextNode(object) || isElement(object) || isComment(object)) {\n        // Splice node into contents and the DOM\n        contents[++i].before(object);\n        if (window.DEBUG) ++stats.add;\n        contents.splice(i, 0, object);\n        return i;\n    }\n\n    return i;\n}\n\n\n/**\nTextRenderer()\nRenders a text node. Text node literals may evaluate to DOM nodes or fragments,\ntemplate renderers, or strings.\n**/\n\nexport default class TextRenderer extends Renderer {\n    constructor(fn, parameters, element, node, compiled) {\n        if (window.DEBUG && !isTextNode(node)) {\n            throw new TypeError('TextRenderer() node not a text node');\n        }\n\n        // Defines .fn, .parameters\n        super(fn, assign({}, parameters, {\n            element,\n            include: (identifier, data) => data === undefined ?\n                (data) => this.include(identifier, data) :\n                this.include(identifier, data),\n            print: (...args) => print(this, ...args)\n        }), compiled);\n\n        // Only for edge case in render()\n        this.element = element;\n        // The last item in contents will always be the original text node\n        this.contents = [node];\n        // String accumulator for render cycle, private\n        this.string = '';\n        // The last node is always the last node and ever shall be\n        define(this, { lastNode: { value: node }});\n\n        // A synchronous evaluation while data signal value is undefined binds\n        // this renderer to changes to that signal. If signal value is a `data`\n        // object evaluation renders the renderer immediately.\n        if (Signal.evaluate(this, this.evaluate) || Signal.hasInvalidDependency) this.cue();\n    }\n\n    get firstNode() {\n        // The first item in contents may be a Template\n        return this.contents[0].firstNode ?\n            this.contents[0].firstNode :\n            this.contents[0] ;\n    }\n\n    include(identifier, data) {\n        const { contents, parameters } = this;\n\n        // We cannot render values that do not accept properties\n        if (data === undefined || data === null) {\n            throw new Error('No data passed in to include()');\n        }\n\n        // If a renderer already exists in contents for this template/data pair...\n        let n = -1;\n        while (contents[++n]) if (\n            contents[n] instanceof Literal &&\n            contents[n].template.identifier === identifier &&\n            contents[n].data === data\n        ) {\n            // ...return it\n            return contents[n];\n        }\n\n        // Return new template renderer\n        return Literal.create(identifier, data, parameters);\n    }\n\n    evaluate() {\n        if (window.DEBUG) {\n            try {\n                return super.evaluate();\n            }\n            catch(error) {\n                // Error object, renderer, DATA\n                const elem = printError(this.compiled, error);\n                this.render(['',''], elem);\n                //throw new Error('Literal', { cause: error });\n                return;\n            }\n        }\n\n        return super.evaluate();\n    }\n\n    render(strings) {\n        const { contents } = this;\n        // Last is the original text node\n        const last = contents[contents.length - 1];\n\n        // An edge case. If element is contenteditable it may be children have\n        // been removed from the DOM (user deleted them from contenteditable).\n        // This presents a problem because Literal uses text nodes as content\n        // placeholders and we don't know what child index contents should have\n        // inside element. For now, we're just going to plonk content back\n        // into element in last place. Less than ideal.\n        if (contents.find(notInDOM)) {\n            console.warn('Literal: contents have been removed from the DOM, attempting to replace them');\n            // Empty out element\n            this.element.innerHTML = '';\n            // Append children back in\n            this.element.append.apply(this.element, contents);\n        }\n\n        // Use `this` as an accumulator for .string. It's an internal object\n        // anyway, so this should not leak, but I admit doing this is a bit naff.\n        // It does avoid creating any more objects though.\n        this.string = '';\n\n        // Loop over strings, zip objects into string\n        let n = -1;\n        let i = -1;\n        while(++n < strings.length - 1) {\n            // Add string to next output-to-text-node string\n            this.string += strings[n];\n            i = objectToContents(this, arguments[n + 1], i);\n        }\n\n        // Set the last string on the last text node\n        setNodeValue(last, this.string + strings[n]);\n\n        // Remove and stop unused contents up to but not including the last node\n        if (contents[++i] !== last) {\n            const mid = contents[i].firstNode || contents[i];\n            deleteRange(mid, last);\n            if (window.DEBUG) ++stats.remove;\n            // Can this upset the observers queue? We are currently evaluating\n            // renderers in the observers queue, and if old renderer happens to\n            // be earlier in the queue the current index could become de-synced\n            // when it is removed... but can it be earlier?\n            contents.splice(i, contents.length - i - 1).forEach(stop);\n        }\n    }\n\n    stop() {\n        // Now, so we actually need to stop contents? Don't the signals made\n        // while instantiating this renderer - don't they stop automatically?\n        // I guess not if they were created asynchronously?\n        this.contents.forEach(stop);\n        this.contents.length = 0;\n        return super.stop.apply(this);\n    }\n\n    static consts = ['DATA', 'data', 'element', 'shadow', 'host', 'id', 'include', 'print'];\n}\n", "/**\nargs()\n\nReturns `arguments` object.\n\n```\ncode(block)\n```\n\n*/\n\nexport default function args() { return arguments; }\n", "\n/**\nget(name, object)\nGet property `name` of `object`.\n*/\n\nimport curry from './curry.js';\n\nexport function get(key, object) {\n    // Todo? Support WeakMaps and Maps and other map-like objects with a\n    // get method - but not by detecting the get method\n    return object[key];\n}\n\nexport default curry(get, true);\n", "/**\nisDefined(value)\nCheck for defined `value`. where `value` is `undefined`, `NaN` or `null`,\nreturns `false`, otherwise `true`.\n*/\n\n\nexport default function isDefined(value) {\n    // !!value is a fast out for non-zero numbers, non-empty strings\n    // and other objects, the rest checks for 0, '', etc.\n    return !!value || (value !== undefined && value !== null && !Number.isNaN(value));\n}\n", "/**\narg(n)\n\nReturns a function that returns `argument[n]`.\n\n```js\n```\n**/\n\nexport default function arg(n) {\n    return function arg() {\n        return arguments[n];\n    };\n}\n", "/**\nself()\nReturns `this`.\n*/\n\nexport default function self() { return this; }\n", "\n/**\nnothing\nA frozen array-like and stream-like object that contains no value.\n**/\n\nimport arg  from './arg.js';\nimport id   from './id.js';\nimport noop from './noop.js';\nimport self from './self.js';\n\nconst create = Object.create;\nconst freeze = Object.freeze;\n\nexport default freeze(create(create(Object.prototype, {\n    // Array methods\n    at:        { value: noop },\n    shift:     { value: noop },\n    push:      { value: noop },\n    forEach:   { value: noop },\n    join:      { value: function() { return ''; } },\n    every:     { value: function() { return true; } },\n    filter:    { value: self },\n    find:      { value: noop },\n    findIndex: { value: function() { return -1; } },\n    flat:      { value: self },\n    flatMap:   { value: self },\n    includes:  { value: function() { return false; } },\n    indexOf:   { value: function() { return -1; } },\n    map:       { value: self },\n    reduce:    { value: arg(1) },\n    sort:      { value: self },\n\n   // Stream methods\n    each:      { value: self },\n    pipe:      { value: id },\n    start:     { value: self },\n    stop:      { value: self },\n    done:      { value: self },\n\n    // Primitive coercion\n    valueOf:   { value: function() { return null; } }\n}), {\n    length: { value: 0 }\n}));\n", "\nimport create from 'dom/create.js';\n\n/**\nsafe(html)\nParses `html` and returns a fragment.\n\nBy default Literal safely renders strings into the DOM via `node.textContent`,\npreventing injection attacks. When you need to render HTML (and your data is\nknown to be safe) call `safe()` on it. Literal appends the resulting fragment\ndirectly.\n**/\n\nexport default function safe(html) {\n    return create('fragment', html);\n}\n", "\n/**\nstash(element)\nstash(element, data)\n\nQuick-and-dirty get or set a value on an element using a WeakMap. Useful for\nstashing data for event delegation. Note that the `value` attribute renderer\nuses `stash()` internally to store values on elements, which is useful when\nyou want an `<input>` to have a non-string value. Where an `'input'` or\n`'change'` event is delegated these values can be retrieved inside the handler\nby getting `stash(input)`.\n**/\n\nimport overload from 'fn/overload.js';\n\nexport const stash = new WeakMap();\n\nexport default overload(function() { return arguments.length; }, {\n    1: (object) => {\n        return stash.get(object);\n    },\n\n    2: (object, value) => {\n        stash.set(object, value);\n        return value;\n    },\n\n    default: window.DEBUG ?\n        () => { throw new Error('Literal: stash(element) to get stashed value, stash(element, value) to set stashed value'); } :\n        undefined\n});\n", "\n// This is the base set of scope functions. These functions are already used by\n// literal so they come at no cost to have them in scope by default.\n\nimport Data      from 'fn/data.js';\nimport Signal    from 'fn/signal.js';\nimport args      from 'fn/args.js';\nimport cache     from 'fn/cache.js';\nimport get       from 'fn/get.js';\nimport id        from 'fn/id.js';\nimport isDefined from 'fn/is-defined.js';\nimport noop      from 'fn/noop.js';\nimport nothing   from 'fn/nothing.js';\nimport overload  from 'fn/overload.js';\nimport remove    from 'fn/remove.js';\nimport create    from 'dom/create.js';\nimport decode    from 'dom/decode.js';\nimport identify  from 'dom/identify.js';\n\n//\n\nimport safe      from './scope/safe.js';\nimport stash     from './stash.js';\n\nconst scope = {};\n\n// Add Math functions to scope\nconst descriptors = Object.getOwnPropertyDescriptors(Math);\nlet name;\nfor (name in descriptors) scope[name] = Math[name];\n\nexport default Object.assign(scope, {\n    // Built-ins added to scope with shorter names for template brevity\n    root:      document.documentElement,\n    body:      document.body,\n    frame:     window.requestAnimationFrame,\n\n    // Override round(n) with round(n, factor)\n    round:     (value, n = 1) => Math.round(value / n) * n,\n\n    // Sane versions of isFinite() and isNaN() from Number\n    isFinite:  Number.isFinite,\n    isInteger: Number.isInteger,\n    isNaN:     Number.isNaN,\n\n    // Object functions\n    assign:    Object.assign,\n    entries:   Object.entries,\n    keys:      Object.keys,\n    values:    Object.values,\n\n    Data,\n    Signal,\n    args,\n    cache,\n    create,\n    decode,\n    get,\n    id,\n    identify,\n    isDefined,\n    noop,\n    nothing,\n    overload,\n    remove,\n    safe,\n    stash\n});\n", "\n/** \ncompile(scope, paramString, code, context)\n\nCompiles a new function from `code` that runs in `scope` with the arguments \nlisted in `paramString`. If a `context` is passed in, you get an arrow function,\notherwise a normal function (leaving you the possibility to set the context at \nruntime with `fn.apply(context, params)`).\n**/\n\nimport get from './get.js';\n\nfunction isValidConst(namevalue) {\n    const name = namevalue[0];\n    return /^\\w/.test(name);\n}\n\nexport default function compile(scope = {}, paramString, code, context) {\n    const entries = Object.entries(scope).filter(isValidConst);\n    const keys    = entries.map(get(0));\n    const values  = entries.map(get(1));\n\n    return context ?\n        // The arrow function has it's context set\n        new Function(...keys, 'return (' + paramString + ') => {' + (code || '') + '}')\n        .apply(context, values) :\n        // This function can be called with a context fn.call(context, data)\n        new Function(...keys, 'return function(' + paramString + '){' + (code || '') + '}')\n        .apply(null, values) ;\n}\n", "\nimport compileFn  from 'fn/compile.js';\nimport { log }    from '../log.js';\n\nconst indent = window.DEBUG ? '\\n    ' : '' ;\n\n/**\ncompile(source, scope, consts)\ncompile(source, scope, consts, options, debug)\nCompiles a literal template string `source` to a function that, when called,\nruns in a scope with all the properties of `scope` defined as constants. `debug`\nis an optional debug string.\n(`options.nostrict = true` enables template rendering `with(data)`.)\n**/\n\n// Store render functions against their source\nexport const compiled = {};\n\n// By default compiled functions are not in 'strict mode' so we COULD use with(),\n// and make `${ data.name }` available as simply `${ name }` in a template...\n// but there be dragons:\n//\n// 1. MDN says `with` should be considered deprecated. I really don't see\n// how they can remove it, though:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with\n//\n// 2. Accessing a not-defined property via `with(data)` does not appear to\n// be reflected in the `data` proxy get records where the property is not\n// defined. This is bad, because that property won't flag the renderer for\n// rerendering.\n//\n// 3.Arrays and other objects have their entire prototype chain exposed,\n// so `map()`, `filter()` and stuff can be called on the array, which is\n// weird, and probably bad. If we are going to use nostrict mode it would\n// probably be best to devise some way of enforcing the base data object to\n// be a prototype-less object of some sort.\n//\n// For these reasons we apply `\"use strict\";` by default.\n\nexport default function compile(source, scope, consts, options = {}, debug) {\n    const code = (options.consts && options.consts.length ?\n            indent + 'const {' + options.consts.join(',') + '} = DATA;' :\n            '' )\n        + indent + (options.nostrict ? 'with(data) ' : '')\n        + 'return args`' + source + '`;\\n';\n\n    // Return cached fn\n    if (compiled[code]) return compiled[code];\n\n    if (window.DEBUG) {\n        const t0 = window.performance.now();\n        const fn = compileFn(scope, '{' + consts.join(',') + '}', code, null, !options.nostrict);\n        const t1 = window.performance.now();\n\n        // Log this compile\n        log('compile', (t1 - t0).toPrecision(3) + 'ms – ' + debug, undefined, undefined, 'yellow');\n\n        // Add fn to cache\n        return compiled[code] = fn;\n    }\n\n    // The quick version scope, parameters, code, context, strict\n    return compiled[code] = compileFn(scope, '{' + consts.join(',') + '}', code, null, !options.nostrict);\n}\n", "\n// Todo: This is a bit of a crude test for literal strings. Surely can be\n// improved.\n\nconst rliteral = /\\$\\{/;\n\nexport default function isLiteralString(string) {\n    return string && rliteral.test(string);\n}\n", "\n// A map of attribute names to property names for attribute renderers. Readonly\n// properties of an element cannot be set, obviously. Marking them as null means\n// AttributeRenderer does not try to set them as properties but as attributes.\n\n// Todo: this prevents use of custom elements that may have different\n// definitions of these property names. We should perhaps use feature detection\n// or check the attributes against their element's tag name. Or we should rely\n// on custom element authors to respect existing attribute behaviour. Mmm-hmm.\n\nexport default {\n    'accept-charset': 'acceptCharset',\n    'accesskey':      'accessKey',\n    'cellpadding':    'cellPadding',\n    'cellspacing':    'cellSpacing',\n    'class':          'classList',\n    'codebase':       'codeBase',\n    'colspan':        'colSpan',\n    'datetime':       'dateTime',\n    'for':            'htmlFor',    // <label>\n    'form':           null,         // Readonly\n    'formaction':     'formAction', // <input>\n    'formenctype':    'formEnctype',\n    'formmethod':     'formMethod',\n    'formnovalidate': 'formNoValidate',\n    'formtarget':     'formTarget',\n    'frameborder':    'frameBorder',\n    'httpequiv':      'httpEquiv',\n    'longdesc':       'longDesc',\n    'maxlength':      'maxLength',\n    'minlength':      'minLength',\n    'nohref':         'noHref',\n    'noresize':       'noResize',\n    'noshade':        'noShade',    // <hr>\n    'nowrap':         'noWrap',\n    'novalidate':     'noValidate', // <form>\n    'readonly':       'readOnly',\n    'rowspan':        'rowSpan',\n    'tabindex':       'tabIndex',\n    'tfoot':          'tFoot',\n    'thead':          'tHead',\n    'usemap':         'useMap',\n    'valign':         'vAlign',\n    'valuetype':      'valueType',   // <object>\n};\n", "\nimport isMutableProperty from 'fn/is-mutable-property.js';\nimport Signal            from 'fn/signal.js';\nimport names             from './property-names.js';\nimport Renderer          from './renderer.js';\nimport toText            from './to-text.js';\nimport { printError }    from '../print.js';\n\n\nconst assign        = Object.assign;\nconst getDescriptor = Object.getOwnPropertyDescriptor;\nconst getPrototype  = Object.getPrototypeOf;\n\n\n/**\nAttributeRenderer(signal, literal, consts, element, name)\nConstructs an object responsible for rendering to a plain text attribute.\n**/\n\nfunction setProperty(node, name, value) {\n    // Seek and set a matching property\n    if (node[name] === value) return;\n    node[name] = value;\n}\n\nfunction setAttribute(node, name, value) {\n    const current = node.getAttribute(name);\n    // Value has not changed\n    if (value === current) return;\n    // Value is null or undefined\n    if (value === null || value === undefined) {\n        if (current === null) return;\n        node.removeAttribute(name);\n    }\n    else {\n        node.setAttribute(name, value);\n    }\n}\n\nexport function toAttributeString(values) {\n    // Zip strings and values into a single string\n    const strings = values[0];\n    let n      = 0;\n    let string = strings[n];\n    while (strings[++n] !== undefined) {\n        string += toText(values[n]);\n        string += strings[n];\n    }\n    return string;\n}\n\nexport default class AttributeRenderer extends Renderer {\n    constructor(fn, parameters, element, name, compiled, isEvaluate) {\n        super(fn, assign({}, parameters, { element }), compiled);\n\n        // Detect un-upgraded (or indeed, upgraded) custom element\n        this.isCustomElement = element.tagName.includes('-');\n        this.element = element;\n        this.name    = name;\n\n        // TODO: property ought to be tested dynamically on custom elements\n        // as they can be upgraded at any point\n        const property = name in names ? names[name] : name;\n        if (property\n            && (property in element)\n            && isMutableProperty(property, element)) {\n            this.property = property;\n        }\n\n        // Evaluate now unless explicitly told not to by subclass\n        if (isEvaluate !== false) Signal.evaluate(this, this.evaluate);\n    }\n\n    evaluate() {\n        if (window.DEBUG) {\n            try {\n                return super.evaluate();\n            }\n            catch(error) {\n                // Error object, renderer, DATA\n                const elem = printError(this.compiled, error);\n                this.element.before(elem);\n                return;\n            }\n        }\n\n        return super.evaluate();\n    }\n\n    render(strings) {\n        // If arguments contains a single expression use its value\n        const value = this.singleExpression ?\n            arguments[1] :\n            toAttributeString(arguments) ;\n\n        const { element, name, property } = this;\n\n        return this.isCustomElement ?\n            // Does element have property of same name as attribute...\n            name in element ?\n                // and it's writable, set property\n                isMutableProperty(name, element) ?\n                    setProperty(element, name, value) :\n                    // otherwise set the attribute\n                    setAttribute(element, name, value) :\n            typeof value === 'object' ?\n                setProperty(element, name, value) :\n                setAttribute(element, name, value) :\n            // If element has a mapped property name, set it\n            property ?\n                setProperty(element, property, value) :\n                // otherwise set attribute\n                setAttribute(element, name, value) ;\n    }\n}\n", "\nimport Signal            from 'fn/signal.js';\nimport AttributeRenderer from './renderer-attribute.js';\nimport { stats }         from './renderer.js';\n\n\n/**\nBooleanRenderer(signal, literal, consts, element, name)\nConstructs an object responsible for rendering to a boolean property or\nattribute.\n**/\n\nfunction setBooleanProperty(node, name, value) {\n    if (node[name] === !!value) return;\n    node[name] = !!value;\n    if (window.DEBUG) ++stats.property;\n}\n\nfunction setBooleanAttribute(node, name, value) {\n    // If attribute is already set...\n    if ((node.getAttribute(name) !== null)) {\n        if (value) return;\n        node.removeAttribute(name);\n        if (window.DEBUG) ++stats.attribute;\n        return;\n    }\n\n    // Otherwise...\n    if (!value) return;\n    node.setAttribute(name, name);\n    return;\n}\n\nexport function toAttributeBoolean(values) {\n    // Sum all values\n    const strings = values[0];\n    let n = 0;\n\n    // Anything other than white space in strings counts as true\n    if (/\\S/.test(strings[n])) return true;\n    while (strings[++n] !== undefined) {\n        if (Boolean(values[n])) return true;\n        if (/\\S/.test(strings[n])) return true;\n    }\n\n    return false;\n}\n\n\nexport default class BooleanRenderer extends AttributeRenderer {\n    render(strings) {\n        // If arguments contains a single expression use its value\n        const value = this.singleExpression ?\n            arguments[1] :\n            toAttributeBoolean(arguments);\n\n        return this.property ?\n            setBooleanProperty(this.element, this.property, value) :\n            setBooleanAttribute(this.element, this.name, value) ;\n    }\n}\n", "\n/**\ntrigger(type, node)\n\nTriggers event of `type` on `node`. Returns `false` if the event default was\nprevented, otherwise `true`.\n\n```\ntrigger('activate', node);\n```\n\nAlternatively the first argument may be an object with a `type` property, and\noptionally `detail`, which must be an object, and `bubbles`, `cancelable` and\n`composed` options, which determine the behaviour of the event.\n\n```\ntrigger({\n    type:       'activate',\n    detail:     {...},\n    bubbles:    true,\n    cancelable: true,\n    composed:   false\n}, node);\n```\n**/\n\nimport curry from 'fn/curry.js';\n\nconst assign   = Object.assign;\n\nconst defaults = {\n    // The event bubbles (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n    bubbles: true,\n\n    // The event may be cancelled (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n    cancelable: true\n\n    // Trigger listeners outside of a shadow root (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/composed\n    //composed: false\n};\n\nexport function trigger(type, node) {\n    let options = defaults;\n    let properties, detail, bubbles, cancelable, composed, event;\n\n    if (typeof type === 'object') {\n        ({ type, detail, bubbles, cancelable, composed, ...properties } = type);\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n        // Options accepted by CustomEvent:\n        // detail:     any\n        // bubbles:    true | false\n        // cancelable: true | false\n        // composed:   true | false\n        event = assign(new CustomEvent(type, {\n            detail,\n            bubbles:    bubbles    || defaults.bubbles,\n            cancelable: cancelable || defaults.cancelable,\n            composed:   composed   || defaults.composed\n        }), properties);\n    }\n    else {\n        event = new CustomEvent(type, defaults);\n    }\n\n    return node.dispatchEvent(event);\n}\n\nexport default curry(trigger, true);\n", "\n/*\nconfig\nConfigure Literal's behaviour.\n\n```js\n    // An event dispatched when Literal updates input values. Default is `false`.\n    config.updateEvent = CustomEvent('ping');\n```\n*/\n\nexport default {\n    // An event dispatched when Literal updates input values. May be false.\n    updateEvent: false\n}\n", "\nimport id                from 'fn/id.js';\nimport get               from 'fn/get.js';\nimport overload          from 'fn/overload.js';\nimport Signal            from 'fn/signal.js';\nimport trigger           from 'dom/trigger.js';\nimport config            from '../config.js';\nimport { stash }         from '../stash.js';\nimport AttributeRenderer, { toAttributeString } from './renderer-attribute.js';\nimport { stats }         from './renderer.js';\nimport toText            from './to-text.js';\n\n\nconst A = Array.prototype;\n\nconst enhancedTypes = {\n    'select-one':      true,\n    'select-multiple': true,\n    'checkbox':        true,\n    'radio':           true,\n    // <option> does not have .type\n    'undefined':       true\n};\n\n\n/** getValue(element)\n\nLiteral provides a mechanism for setting and getting values of any type on\nselect, checkbox and radio inputs. Where `input.value` always returns a string\n(on uncustomised DOM elements, at least), `stash(element)` returns the value\nset by a Literal template *before* it was coerced to a string. If no such value\nexists it falls back to returning the string.\n\n```\nevents('input', document.body)\n.map((e) => getValue(e.target))\n.each(console.log);\n```\n**/\n\nfunction getElementValue(element) {\n    return stash.has(element) ? stash.get(element) :\n        'value' in element ? element.value :\n        element.getAttribute('value') ;\n}\n\nexport const getValue = overload(get('type'), {\n    // If element is a <select> return value of selected <option>\n    'select-one': (element) => (\n        element.selectedIndex > -1 ?\n            getElementValue(element.options[element.selectedIndex]) :\n            undefined\n    ),\n\n    // If element is a <select multiple> return an array of values\n    'select-multiple': (element) => A.filter\n        .call(element.options, get('selected'))\n        .map(getElementValue),\n\n    // Otherwise return $value of enhanced element types\n    'checkbox': getElementValue,\n    'radio':    getElementValue,\n\n    // Or number of numerical types\n    'number':   (element) => Number(element.value),\n    'range':    (element) => Number(element.value),\n\n    // Or just the string value\n    'default':  (element) => element.value\n});\n\n\n/**\nsetValue(element, value)\nSets value expando and value property on element.\n**/\n\nconst types = {\n    'number': 'number',\n    'range':  'number'\n};\n\nfunction setElementValue(element, value) {\n    // Don't render into focused nodes, it makes the cursor jump to the\n    // end of the field, and we should cede control to the user\n    if (document.activeElement === element) return;\n\n    const isEnhanced = enhancedTypes[element.type];\n\n    // If value is already stashed do nothing\n    if (isEnhanced && stash.has(element) && stash.get(element) === value) return;\n\n    // Refuse to set value that does not conform to input type\n    const expectedType = types[element.type];\n    if (expectedType && typeof value !== expectedType) return;\n\n    // Where input is an enhanced type stash object\n    if (isEnhanced) stash.set(element, value);\n\n    // Convert to string with Literal's text rendering rules\n    const string = toText(value);\n\n    // Avoid updating DOM with the same value.\n    if (string === element.value) return;\n\n    // Bit of an edge case, but where we have a custom element that has not\n    // been upgraded yet, but will have a value property defined on its\n    // prototype when it does upgrade, setting value on the instance now will\n    // mask the ultimate get/set definition on the prototype...\n    if ('value' in element) {\n        element.value = string;\n        if (window.DEBUG) ++stats.property;\n    }\n    // ...so don't, if property is not in node. Set the attribute, it will be\n    // picked up on upgrade.\n    else {\n        element.setAttribute('value', string);\n        if (window.DEBUG) ++stats.attribute;\n    }\n\n    // Optional event hook\n    if (config.updateEvent) {\n        trigger(config.updateEvent, element);\n    }\n\n    // Return DOM mod count\n    return;\n}\n\nexport const setValue = overload(get('type'), {\n    'select-one': (element, value) => {\n        // Where value is a primitive set it directly\n        if (typeof value === 'string' || typeof value === 'number') {\n            return setElementValue(element, value);\n        }\n\n        // Otherwise look for a matching option and select that\n        const option = A.find.call(element.options, (option) => value === getElementValue(option));\n        if (option && !option.selected) {\n            option.selected = true;\n            if (window.DEBUG) ++stats.property;\n        }\n    },\n\n//    'select-multiple': (element, value) => {},\n\n    'default': setElementValue\n});\n\n\n/**\nValueRenderer(fn, element, unused, consts)\nConstructs an object responsible for rendering from a value attribute to a\nvalue property. Parameter `name` is redundant, but here for symmetry with other\nrenderers.\n**/\n\nconst coercer = {\n    //'date':      composeDate,\n    //'select-multiple': composeArray,\n    'number': Number,\n    'range':  Number\n};\n\nexport default class ValueRenderer extends AttributeRenderer {\n    render(strings, value) {\n        return setValue(this.element,\n            this.singleExpression ?\n                coercer[this.element.type] ?\n                    coercer[this.element.type](value) :\n                value :\n            toAttributeString(arguments)\n        );\n    }\n}\n", "\nimport id                from 'fn/id.js';\nimport isDefined         from 'fn/is-defined.js';\nimport Signal            from 'fn/signal.js';\nimport trigger           from 'dom/trigger.js';\nimport config            from '../config.js';\nimport AttributeRenderer from './renderer-attribute.js';\nimport { toAttributeBoolean } from './renderer-boolean.js';\nimport { getValue }      from './renderer-value.js';\nimport { stats }         from './renderer.js';\n\n\n/**\nCheckedRenderer(signal, literal, consts, element)\nConstructs an object responsible for rendering to a checked property.\n**/\n\nfunction toString(value) {\n    return '' + value;\n}\n\nfunction setChecked(element, value, hasValueAttribute) {\n        // Value may be a boolean in which case we use it directly\n    const checked = typeof value === 'boolean' ? value :\n        // If the element has a value attribute defined, we compare against it\n        hasValueAttribute ?\n            // Is value an array of values? It's important to include this here,\n            // at least for checkboxes, of which multiple may be checked. It\n            // cuts down on tag parsing in lists of inputs.\n            element.type === 'checkbox' && value && value.map ?\n                value.map(toString).includes(getValue(element)) :\n                // Or a string or a number?\n                value + '' === element.value :\n        // Otherwise treat value as a boolean\n        !!value ;\n\n    // Avoid updating the DOM unnecessarily\n    if (checked === element.checked) return;\n\n    element.checked = checked;\n    if (window.DEBUG) ++stats.property;\n\n    // Optional event hook\n    if (config.updateEvent) {\n        trigger(config.updateEvent, node);\n    }\n}\n\nexport default class CheckedRenderer extends AttributeRenderer {\n    constructor(fn, parameters, element, name, compiled) {\n        super(fn, parameters, element, 'checked', compiled, false);\n\n        // Flag whether element has a value attribute\n        this.hasValue = isDefined(element.getAttribute('value'));\n\n        // A synchronous evaluation while data signal value is undefined binds\n        // this renderer to changes to that signal. If signal value is an `data`\n        // object it renders the renderer immediately.\n        Signal.evaluate(this, this.evaluate);\n    }\n\n    render(strings) {\n        // If arguments contains a single expression use its value\n        const value = this.singleExpression ?\n            Boolean(arguments[1]) :\n            toAttributeBoolean(arguments) ;\n\n        return setChecked(this.element, value, this.hasValue);\n    }\n}\n", "\n/**\ntoCamelCase(string)\nCapitalises any Letter following a `'-'` and removes the dash.\n**/\n\nexport default function toCamelCase(string) {\n    // Be a little gracious in what we accept as input\n    return string.replace(/-+(\\w)/g, function($0, letter) {\n        return letter.toUpperCase();\n    });\n}\n", "\nimport Signal            from 'fn/signal.js';\nimport toCamelCase       from 'fn/to-camel-case.js';\nimport AttributeRenderer, { toAttributeString } from './renderer-attribute.js';\nimport { stats }         from './renderer.js';\n\n\n/**\nDatasetRenderer(signal, literal, consts, element, name)\nConstructs an object responsible for rendering to the `.dataset` property.\n**/\n\nexport default class DatasetRenderer extends AttributeRenderer {\n    constructor(fn, parameters, element, name, compiled) {\n        super(fn, parameters, element, name, compiled, false);\n\n        // data-prop-thing to propThing\n        this.property = toCamelCase(name.replace(/^data-/, ''));\n\n        // A synchronous evaluation while data signal value is undefined binds\n        // this renderer to changes to that signal, but if signal value is an\n        // object it renders immediately.\n        Signal.evaluate(this, this.evaluate);\n    }\n\n    render(strings) {\n        return this.element.dataset[this.property] = this.singleExpression ?\n            arguments[1] :\n            toAttributeString(arguments) ;\n    }\n}\n", "\nimport Signal    from 'fn/signal.js';\nimport AttributeRenderer, { toAttributeString } from './renderer-attribute.js';\nimport { stats } from './renderer.js';\n\nconst assign = Object.assign;\n\n/**\nDatasetRenderer(signal, literal, consts, element, name)\nConstructs an object responsible for rendering to the `.dataset` property.\n**/\n\nexport default class StyleRenderer extends AttributeRenderer {\n    render(strings) {\n        // Intercept single expressions that evaluate to an object, treat object\n        // as object of CSS property:value rules\n        if (this.singleExpression && typeof arguments[1] === 'object') {\n            assign(this.element.style, arguments[1]);\n            if (window.DEBUG) ++stats.property;\n            return;\n        }\n\n        // Otherwise treat as any other attribute\n        return super.render.apply(this, arguments);\n    }\n}\n", "\nimport id                from 'fn/id.js';\nimport nothing           from 'fn/nothing.js';\nimport overload          from 'fn/overload.js';\nimport Signal            from 'fn/signal.js';\nimport toText            from './to-text.js';\nimport AttributeRenderer from './renderer-attribute.js';\nimport { stats }         from './renderer.js';\n\n\nconst A       = Array.prototype;\n\n/**\nTokensRenderer(signal, literal, consts, element, name)\nConstructs an object responsible for rendering to a token list attribute such\nas a class attribute.\n**/\n\nfunction updateTokens(list, cached, tokens, count = 0) {\n    // Remove all tokens from cached that are found in new tokens\n    let n = cached.length;\n    while (n--) {\n        if (tokens.includes(cached[n])) {\n            cached.splice(n, 1);\n        }\n    }\n\n    // The remainder are not in values and thus must be removed\n    if (cached.length) {\n        list.remove.apply(list, cached);\n        if (window.DEBUG) ++stats.tokens;\n    }\n\n    // Add the new tokens. The list object (a TokenList) ignores tokens it\n    // already contains, so it is safe to set doubles. Return DOM mutation count\n    // for logging\n    if (tokens.length) {\n        list.add.apply(list, tokens);\n        if (window.DEBUG) ++stats.tokens;\n    }\n\n    if (window.DEBUG) ++stats.tokens;\n}\n\nexport default class TokensRenderer extends AttributeRenderer {\n    constructor(fn, parameters, element, name, compiled) {\n        super(fn, parameters, element, name, compiled, false);\n\n        // Renderer properties\n        this.list   = element[this.property];\n        this.tokens = nothing;\n\n        // A synchronous evaluation while data signal value is undefined binds\n        // this renderer to changes to that signal. If signal value is an `data`\n        // object it renders the renderer immediately.\n        Signal.evaluate(this, this.evaluate);\n    }\n\n    render(strings) {\n        // Set permanent tokens from strings on first render\n        if (this.count === 1) {\n            const tokens = strings.join(' ').trim();\n            if (tokens) {\n                const array = tokens.split(/\\s+/);\n                this.list.add.apply(this.list, array);\n                if (window.DEBUG) stats.token += 1;\n            }\n        }\n\n        // Concat remaining expression values into a spaced string\n        let n      = 0;\n        let string = '';\n        while (strings[++n] !== undefined) {\n            const text = toText(arguments[n]);\n            if (text) string += ' ' + text;\n        }\n\n        // Split into tokens\n        const tokens = string ?\n            string.trim().split(/\\s+/) :\n            nothing ;\n\n        // Set new tokens, remove unused tokens\n        updateTokens(this.list, this.tokens, tokens);\n        this.tokens = tokens;\n    }\n}\n", "\nimport scope             from '../scope.js';\nimport names             from '../renderer/property-names.js';\nimport AttributeRenderer from '../renderer/renderer-attribute.js';\nimport BooleanRenderer   from '../renderer/renderer-boolean.js';\nimport CheckedRenderer   from '../renderer/renderer-checked.js';\nimport DatasetRenderer   from '../renderer/renderer-dataset.js';\nimport StyleRenderer     from '../renderer/renderer-style.js';\nimport TokensRenderer    from '../renderer/renderer-tokens.js';\nimport ValueRenderer     from '../renderer/renderer-value.js';\nimport R                 from '../renderer/renderer.js';\nimport isLiteralString   from './is-literal-string.js';\nimport truncate          from './truncate.js';\nimport compile           from './compile.js';\nimport { printError }    from '../print.js';\n\n\nconst assign = Object.assign;\n\n\n/**\ncompileAttributes(array, element, attribute, path, options[, debug])\n**/\n\nexport default function compileAttribute(array, element, attribute, path, options, template) {\n    const source = attribute.value;\n    if (!isLiteralString(source)) { return; }\n\n    const name = attribute.localName;\n    const tag  = element.tagName.toLowerCase();\n\n    // TODO: custom elements need to be flagged as potentially upgradeable, and\n    // we shall have to devise a way of upgrading their renderers. The problem\n    // is that their properties may become available later. The other test is\n    // to see if the element is registered yet with customElements.get(), but\n    // that does not help here. Even if it is registered, element is currently\n    // inside a fragment so has not yet been upgraded.\n    const upgradeable = /-/.test(tag) || element.getAttribute('is');\n    const property    = name in names ? names[name] : name;\n\n    // We need the Renderer here just to get .consts. This is a bit\n    // clunky, but the whole passing parameters to compiled functions thing is,\n    // anyway. Needs a once-over.\n    const Renderer = /^data-/.test(name) ? DatasetRenderer :\n        property in element ?\n            property === 'value'   ? ValueRenderer :\n            property === 'checked' ? CheckedRenderer :\n            property === 'style'   ? StyleRenderer :\n            typeof element[property] === 'boolean' ? BooleanRenderer :\n            typeof element[property] === 'object' && element[property].add && element[property].remove ? TokensRenderer :\n            AttributeRenderer :\n        AttributeRenderer ;\n\n    const target = { path, name, source, Renderer, upgradeable, template };\n\n    if (window.DEBUG) {\n        const code = truncate(80, '<'\n            + tag + ' '\n            + name + '=\"' + source\n            + '\">') ;\n\n        // Fill target object with debug info\n        target.tag      = tag;\n        target.code     = code;\n        target.property = property;\n\n        // Attempt to compile, and in case of an error replace element with\n        // an error element\n        try {\n            target.literal = compile(source, scope, Renderer.consts, options, code);\n        }\n        catch(error) {\n            element.replaceWith(printError(target, error));\n            return array;\n        }\n    }\n    else {\n        target.literal = compile(source, scope, Renderer.consts, options);\n    }\n\n    array.push(target);\n\n    // Avoid errant template literals making booleans default to true, mangling\n    // classes, and unnecessarily checking checkboxes. This has been moved here\n    // from AttributeRenderer (`new AttributeRenderer()` does not need the\n    // attribute to be present, and its optimum to operate on the template DOM\n    // rather than each cloned DOM).\n    element.removeAttribute(name);\n\n    return array;\n}\n", "\nimport id                from 'fn/id.js';\nimport overload          from 'fn/overload.js';\nimport toType            from 'dom/to-type.js';\nimport decode            from 'dom/decode.js';\nimport indexOf           from '../dom/index-of.js';\nimport TextRenderer      from '../renderer/renderer-text.js';\nimport { printError }    from '../print.js';\nimport scope             from '../scope.js';\nimport compile           from './compile.js';\nimport { pathSeparator } from './constants.js';\nimport isLiteralString   from './is-literal-string.js';\nimport truncate          from './truncate.js';\nimport compileAttribute  from './compile-attribute.js';\n\n\nconst assign = Object.assign;\n\n\n/*\ncompileChildren(targets, element, path, options, template)\n*/\n\nfunction compileChildren(targets, element, path, options, template) {\n    // Children may mutate during compile, and we only want to compile\n    // current children\n    const children = Array.from(element.childNodes);\n\n    if (children) {\n        let n = -1;\n        while(children[++n]) {\n            // In HTML it is not possible to write expressions directly in\n            // certain contexts, such as in `<tbody>` or `<tr>`. They are parsed\n            // out by the HTML parser before they become DOM. However, it *is*\n            // acceptable to write `<template>` tags in these contexts. So here\n            // we treat `<template>` as a pass-through to it's own `.content` –\n            // ie, the `<template>` is removed from compiled content and\n            // replaced with its own content.\n            //\n            // TODO We may want this functionality to be opt-in with some kind of\n            // attribute on the template or something.\n            if (children[n].content) {\n                const template = children[n];\n                const fragment = template.content;\n\n                // Only do this if the fragment has content (otherwise childNode\n                // index will be 1 short)\n                if (fragment.childNodes.length) {\n                    // Splice out the template, splice in the child nodes\n                    children.splice(n, 1, ...fragment.childNodes);\n                    // Do the same to the DOM\n                    template.before(fragment);\n                    template.remove();\n                }\n            }\n\n            compileNode(targets, children[n], path, options, template);\n        }\n    }\n\n    return targets;\n}\n\n\n/*\ncompileAttributes(targets, node, path, options, template)\n*/\n\nfunction compileAttributes(targets, element, path, options, template) {\n    // Attributes may be removed during parsing so copy the list before looping\n    const attributes = Array.from(element.attributes);\n    let n = -1, attribute;\n\n    while (attribute = attributes[++n]) {\n        compileAttribute(targets, element, attribute, path, options, template);\n    }\n\n    return targets;\n}\n\n\n/*\ncompileElement(targets, node, path, options, template)\n*/\n\nconst compileElement = overload((targets, element) => element.tagName.toLowerCase(), {\n    // Ignore <defs> and <template>, which we consider as inert. Templates\n    // should have already been flattened into content anyway in compileChildren()\n    'defs':     id,\n    'template': id,\n\n    // Do not parse the inner DOM of scripts\n    'script':   compileAttributes,\n\n    'textarea': (targets, element, path, options, template) => {\n        compileAttributes(targets, element, path, options, template);\n        // A <textarea> does not have children, its textContent becomes its value\n        compileAttribute(targets, element, {\n            localName: 'value',\n            value:     element.textContent\n        }, path, options, template);\n        element.textContent = '';\n        return targets;\n    },\n\n    'default': (targets, element, path, options, template) => {\n        // Compiling children first means inner DOM to outer DOM, which allows\n        // `<select>`, for example, to pick up the correct option value. (Should\n        // we decide to change this order we must make sure value attribute is\n        // rendered after children.)\n        compileChildren(targets, element, path, options, template);\n        compileAttributes(targets, element, path, options, template);\n        return targets;\n    }\n});\n\n\n/**\ncompileNode(targets, node, path, options, template)\n**/\n\nconst compileNode = overload((targets, node) => toType(node), {\n    'comment':  id,\n    'doctype':  id,\n    'document': compileChildren,\n    'fragment': compileChildren,\n    'element': (targets, element, path, options, template) => {\n        compileElement(targets, element, (path ? path + pathSeparator : '') + indexOf(element), options, template);\n        return targets;\n    },\n    'text': (targets, node, path, options, template) => {\n        const string = node.nodeValue;\n        if (!isLiteralString(string)) return targets;\n\n        const source = decode(string);\n        const target = {\n            template,\n            path,\n            name: indexOf(node),\n            source,\n            Renderer: TextRenderer\n        };\n\n        if (window.DEBUG) {\n            const parent = node.parentElement;\n            const tag    = parent && parent.tagName.toLowerCase();\n            const code   = truncate(80, tag ?\n                '<' + tag + '>' + source.trim() + '</' + tag + '>' :\n                source.trim()\n            );\n\n            // Add target object with debug info\n            target.tag  = tag;\n            target.code = code;\n\n            // Attempt to compile, and in case of an error replace node with an\n            // error element\n            try {\n                target.literal = compile(source, scope, TextRenderer.consts, options, code);\n                node.nodeValue = '';\n                targets.push(target);\n                return targets;\n            }\n            catch(error) {\n                node.replaceWith(printError(target, error));\n                return targets;\n            }\n        }\n\n        target.literal = compile(source, scope, TextRenderer.consts, options);\n        node.nodeValue = '';\n        targets.push(target);\n        return targets;\n    }\n});\n\nexport default compileNode;\n", "\nimport id          from 'fn/id.js';\nimport create      from 'dom/create.js';\nimport identify    from 'dom/identify.js';\nimport compileNode from './compile/compile-node.js';\n\n\nconst assign = Object.assign;\nconst cache  = {};\n\n\n/**\nTemplate(id, fragment, options)\nParses `fragment` for literal tags and creates an object that serves as a\nfactory for creating renderers of the template. This object is cached against\n`id`, further calls with the same id return the same object.\n**/\n\nexport default class Template extends id {\n    constructor(id, fragment, options = {}) {\n        // If cached against id, return cached instance\n        if (cache[id]) return cache[id];\n\n        // Set 4th argument up as this, allowing this to be a DOM template\n        super(arguments[3]);\n\n        // Identifier is a cache key, in the case of a template in the DOM it is\n        // its fragment identifier, it may be a url or anything else\n        this.identifier = id;\n        this.compiled = compileNode([], fragment, '', options, this);\n        if (!this.content) this.content = fragment;\n\n        // Cache template\n        cache[id] = this;\n    }\n\n    get innerHTML() {\n        // Meh. (TODO test if this actually works)\n        const template = create('template', { children: [this.content] });\n        return template.innerHTML;\n    }\n\n    /**\n    Template.fromHTML(id, html, options)\n    **/\n    static fromHTML(id, html, options = {}) {\n        if (cache[id]) throw new Error('Template.fromHTML() id \"' + id + '\" already registered');\n        const template = create('template', html);\n        const fragment = template.content;\n        return new Template(id, fragment, options, template);\n    }\n\n    /**\n    Template.fromFragment(id, fragment, options)\n    **/\n    static fromFragment(id, fragment, options = {}) {\n        if (cache[id]) throw new Error('Template.fromFragment() id \"' + id + '\" already registered');\n        return new Template(id, fragment, options);\n    }\n\n    /**\n    Template.fromTemplate(template)\n    **/\n    static fromTemplate(template, settings) {\n        const identifier = '#' + identify(template, 'literal-');\n        const consts = template.getAttribute('consts');\n        const options = assign({}, settings, {\n            nostrict: template.hasAttribute ?\n                template.hasAttribute('nostrict') :\n                undefined,\n            consts: consts ?\n                consts.trim().split(/\\s*[\\s,]\\s*/) :\n                undefined\n        });\n\n        return new Template(identifier, template.content, options, template);\n    }\n}\n", "\nimport Data        from 'fn/data.js';\nimport Signal      from 'fn/signal.js';\nimport create      from 'dom/create.js';\nimport removeRange from './dom/remove-range.js';\nimport { pathSeparator } from './compile/constants.js';\nimport Template    from './template.js';\n\n\nconst assign = Object.assign;\nconst define = Object.defineProperties;\nconst ids    = {};\n\n\n/*\nTemplate contents\nDescendant paths are stored in the form `\"#id>1>12>3\"`, enabling fast cloning of\nLiteral instances without re-traversing their DOMs looking for template tags.\n*/\n\nfunction getChild(element, index) {\n    return element.childNodes[index];\n}\n\nfunction getElement(path, node) {\n    return path\n    .split(pathSeparator)\n    .reduce(getChild, node);\n}\n\n\n/*\nTemplate context\nA template may be rendered into an element that requires something other than\nthe standard HTML context, ie SVG elements, in which case the fragment we pass\nto Literal should not be `template.content` but a fragment with an SVG context.\n*/\n\nfunction getContextFragment(template, element) {\n    if (element && element instanceof SVGElement) {\n        const range = document.createRange();\n        const html = template.innerHTML;\n\n        // An outer <svg> will not act as the correct context, I suspect because\n        // it is itself an HTML element. Not entirely clear, but whatever, we\n        // must use a <g> or <defs>, either of which permit the same content as\n        // an <svg> context.\n        if (element.ownerSVGElement === null) {\n            // Create a <defs>, append it, use it as context\n            const defs = create('defs');\n            element.appendChild(defs);\n            range.selectNode(defs);\n\n            // Create fragment, remove the <defs>, return the fragment\n            const fragment = range.createContextualFragment(html);\n            range.deleteContents();\n            return fragment;\n        }\n\n        // Use element as context to create fragment\n        range.selectNode(element);\n        return range.createContextualFragment(html);\n    }\n\n    // Use the template's content fragment directly\n    return template.content.cloneNode(true);\n}\n\nfunction toTemplate(compiled) {\n    const { fragment, parameters } = this;\n    const { path, name } = compiled;\n\n    // Where `.path` exists find the element at the end of the path\n    const element = path ? getElement(path, fragment) : parameters.element ;\n\n    // Text renderer expects a text node that must always come from the\n    // cloned content fragment\n    const node =\n        typeof name === 'number' ?\n            path ? element.childNodes[name] :\n            fragment.childNodes[name] :\n        name;\n\n    if (window.DEBUG && !node) throw new Error('Literal – node ' + name + ' not found in template');\n\n    // Parameters for new Renderer()\n    return { element, node, compiled };\n}\n\nfunction toRenderer({ element, node, compiled }) {\n    const { parameters } = this;\n    const { Renderer, literal } = compiled;\n    return new Renderer(literal, parameters, element, node, compiled);\n}\n\nfunction stop(renderer) {\n    renderer.stop();\n}\n\n\n/**\nLiteral(template, data, parameters)\n**/\n\nexport default class Literal {\n    #first;\n\n    constructor(template, object, parameters = {}) {\n        // Expose data in order to perform include comparisons\n        this.data = Data.of(object);\n        // Expose template id in order to perform include comparisons\n        this.template = template;\n        // Make fragment from element context where necessary\n        this.fragment = getContextFragment(template, parameters.element);\n        // Assemble parameters\n        this.parameters = assign({}, parameters, {\n            data: this.data,\n            DATA: Data.objectOf(object)\n        });\n\n        const children = this.fragment.childNodes;\n        // The first node may change\n        this.#first = children[0];\n        // The last node is always the last node\n        this.lastNode = children[children.length - 1];\n        // Create renderers array\n        this.renderers = template.compiled\n            // We must find targets in cloned content\n            .map(toTemplate, this)\n            // before we create renderers for them, renderers may mutate the DOM\n            .map(toRenderer, this);\n    }\n\n    /** .firstNode **/\n    /** .lastNode **/\n    get firstNode() {\n        // Has #first become the last node of a TextRenderer? Note that it is\n        // perfectly possible to have a template with no content renderers.\n        const renderer = this.renderers && this.renderers[0];\n        return renderer && this.#first === renderer.lastNode ?\n            renderer.firstNode :\n            this.#first ;\n    }\n\n    /**\n    .before()\n    **/\n    before() {\n        const first = this.firstNode;\n        const last  = this.lastNode;\n\n        // Last node is not in the DOM\n        if (this.fragment.lastChild === last) {\n            throw new Error('Illegal Literal.before() – template is not in the DOM');\n        }\n\n        // First node is not in the DOM\n        return this.fragment.firstChild === first ?\n            last.before.apply(last, arguments) :\n            first.before.apply(first, arguments) ;\n    }\n\n    /**\n    .remove()\n    Removes rendered content from the DOM and places it back in the `.content`\n    fragment.\n    **/\n    remove() {\n        const first = this.firstNode;\n        const last  = this.lastNode;\n\n        // Check if we are in the DOM. Can't remove if we're not in the DOM.\n        if (this.fragment.lastChild === last) {\n            return;\n        }\n\n        if (this.fragment.firstChild === first) {\n            this.fragment.appendChild(last);\n            return;\n        }\n\n        const fragment = removeRange(first, last);\n        this.fragment.appendChild(fragment);\n    }\n\n    /**\n    .stop()\n    **/\n    stop() {\n        this.renderers.forEach(stop);\n        return this;\n    }\n\n    /**\n    Literal.create(identifier, element, parameters)\n    **/\n    static create(identifier, data, parameters) {\n        // Assume identifier is of the form `#id`\n        const element = document.getElementById(identifier.slice(1));\n        //const fragment = element.content;\n        //const options  = { nostrict: element.hasAttribute && element.hasAttribute('nostrict') };\n        //const template = new Template(identifier, fragment, options, element);\n        const template = Template.fromTemplate(element);\n        return new Literal(template, data, parameters);\n    }\n\n    /**\n    Literal.fromFragment(fragment, element, parameters, options)\n    **/\n    static fromFragment(fragment, data, parameters, options) {\n        const template = Template.fromFragment(identifier, fragment, options);\n        return new Literal(template, data, parameters);\n    }\n\n    /**\n    Literal.fromHTML(html, element, options, parameters)\n    **/\n    static fromHTML(html, data, parameters, options) {\n        const template = Template.fromHTML(identifier, html, options);\n        return new Literal(template, data, parameters);\n    }\n\n    /**\n    Literal.fromTemplate(template, element, parameters, options)\n    **/\n    static fromTemplate(element, data, parameters, options) {\n        const template = Template.fromTemplate(element, options);\n        return new Literal(template, data, parameters);\n    }\n\n    /**\n    Literal.render(identifier, data, element)\n    Returns a rendered (or about-to-be-rendered-on-the-next-frame) fragment\n    from template identified by `identifier`.\n    **/\n    static render(id, data, element) {\n        const literal = Literal.from(id, data, { element });\n        return literal.fragment;\n    }\n}\n", "\nconst entries = Object.entries;\nconst map     = {};\nconst cache   = {};\n\nfunction toMap(urls, [path1, path2]) {\n    const url = new URL(path1, window.location);\n    map[url] = new URL(path2, window.location);\n    return map;\n}\n\nexport function urls(object) {\n    return entries(object).reduce(toMap, map);\n}\n\nexport function rewriteURL(path) {\n    // Rewrite relative import URLs to be absolute, taking location as their\n    // relative root (if we don't do this import() assumes the location of\n    // the script as relative root).\n    const url = new URL(path, window.location);\n\n    // Are we rewriting this URL?\n    return map[url] || url;\n}\n", "\nimport Data    from 'fn/data.js';\nimport Signal  from 'fn/signal.js';\nimport Literal from './modules/literal.js';\nimport scope   from './modules/scope.js';\nimport { compiled } from './modules/compile/compile.js';\n\nLiteral.scope  = scope;\n\nexport { Literal as default, Data, Signal, compiled };\nexport { default as config } from './modules/config.js';\nexport { urls }              from './modules/urls.js';\n"],
  "mappings": "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",
  "names": ["evaluatingSignal", "hasInvalidDependency", "removeOutput", "signal", "output", "o", "clearInputs", "n", "setDependency", "dependent", "invalidateDependents", "hasInput", "input", "Signal", "_Signal", "object", "value", "ValueSignal", "fn", "context", "PushSignal", "ComputeSignal", "name", "PropertySignal", "FrameSignal", "TickSignal", "TimedSignal", "previous", "evaluatingSignal", "hasInvalidDependency", "#value", "#valid", "#fn", "#context", "#validTime", "time", "isValid", "Observer", "m", "observers", "i", "rendering", "render", "promise", "tick", "frame", "isMutableProperty", "name", "object", "descriptor", "prototype", "assign", "define", "isExtensible", "O", "$trap", "properties", "isMuteable", "object", "getSignal", "signals", "name", "Data", "getValue", "Signal", "isMutableProperty", "DataTrap", "object", "properties", "$trap", "define", "assign", "name", "proxy", "value", "getValue", "Data", "length", "force", "isMuteable", "Signal", "trap", "getSignal", "id", "value", "overload", "fn", "map", "key", "handler", "cacheByObject", "fn", "map", "object", "value", "A", "applyFn", "fn", "args", "curry", "muteable", "arity", "memo", "cacheByObject", "object", "partial", "curry_default", "noop", "assignProperty", "overload", "id", "noop", "name", "node", "object", "content", "setAttribute", "assign", "attributes", "names", "n", "assign_default", "curry_default", "svgNamespace", "template", "typeofContent", "type", "content", "createContextFragment", "context", "html", "range", "createSVG", "overload", "tag", "node", "object", "assign_default", "createHTML", "create", "id", "text", "fragment", "create_default", "removeRange", "first", "last", "range", "pathSeparator", "identify", "node", "prefix", "root", "id", "types", "toType", "node", "textarea", "decode", "html", "A", "indexOf", "node", "isComment", "node", "isElement", "node", "isFragment", "node", "isTextNode", "node", "deleteRange", "first", "last", "range", "to_type_default", "object", "rarrowents", "rarguments", "toText", "overload", "to_type_default", "id", "value", "object", "Signal", "to_text_default", "remove", "array", "value", "i", "stop", "stopable", "promiseStop", "renderValue", "renderer", "args", "values", "n", "object", "isRender", "target", "Data", "Literal", "stopables", "value", "remove", "i", "Renderer", "FrameSignal", "fn", "parameters", "compiled", "input", "strings", "printError", "noop", "printDebug", "print", "renderer", "object", "assign", "define", "stop", "node", "notInDOM", "setNodeValue", "value", "nodeValue", "objectToContents", "renderer", "object", "i", "string", "contents", "Literal", "to_text_default", "isTextNode", "n", "k", "isFragment", "l", "m", "isElement", "isComment", "TextRenderer", "Renderer", "fn", "parameters", "element", "compiled", "identifier", "data", "args", "print", "Signal", "strings", "last", "mid", "deleteRange", "args", "get", "key", "object", "get_default", "curry_default", "isDefined", "value", "arg", "n", "self", "create", "freeze", "nothing_default", "noop", "self", "arg", "id", "safe", "html", "create_default", "stash", "stash_default", "overload", "object", "value", "scope", "descriptors", "name", "scope_default", "value", "n", "Data", "Signal", "args", "cacheByObject", "create_default", "decode", "get_default", "id", "identify", "isDefined", "noop", "nothing_default", "overload", "remove", "safe", "stash_default", "isValidConst", "namevalue", "name", "compile", "scope", "paramString", "code", "context", "entries", "keys", "get_default", "values", "indent", "compiled", "compile", "source", "scope", "consts", "options", "debug", "code", "rliteral", "isLiteralString", "string", "property_names_default", "assign", "setProperty", "node", "name", "value", "setAttribute", "current", "toAttributeString", "values", "strings", "n", "string", "to_text_default", "AttributeRenderer", "Renderer", "fn", "parameters", "element", "compiled", "isEvaluate", "assign", "property", "property_names_default", "isMutableProperty", "Signal", "setBooleanProperty", "node", "name", "value", "setBooleanAttribute", "toAttributeBoolean", "values", "strings", "n", "BooleanRenderer", "AttributeRenderer", "assign", "defaults", "trigger", "type", "node", "options", "properties", "detail", "bubbles", "cancelable", "composed", "event", "trigger_default", "curry_default", "config_default", "A", "enhancedTypes", "getElementValue", "element", "stash", "getValue", "overload", "get_default", "types", "setElementValue", "value", "isEnhanced", "expectedType", "string", "to_text_default", "config_default", "trigger_default", "setValue", "option", "coercer", "ValueRenderer", "AttributeRenderer", "strings", "toAttributeString", "toString", "value", "setChecked", "element", "hasValueAttribute", "checked", "getValue", "config_default", "trigger_default", "CheckedRenderer", "AttributeRenderer", "fn", "parameters", "name", "compiled", "isDefined", "Signal", "strings", "toAttributeBoolean", "toCamelCase", "string", "$0", "letter", "DatasetRenderer", "AttributeRenderer", "fn", "parameters", "element", "name", "compiled", "toCamelCase", "Signal", "strings", "toAttributeString", "assign", "StyleRenderer", "AttributeRenderer", "strings", "A", "updateTokens", "list", "cached", "tokens", "count", "TokensRenderer", "AttributeRenderer", "fn", "parameters", "element", "name", "compiled", "nothing_default", "Signal", "strings", "array", "n", "string", "text", "to_text_default", "compileAttribute", "array", "element", "attribute", "path", "options", "template", "source", "isLiteralString", "name", "tag", "upgradeable", "property", "property_names_default", "Renderer", "DatasetRenderer", "ValueRenderer", "CheckedRenderer", "StyleRenderer", "BooleanRenderer", "TokensRenderer", "AttributeRenderer", "target", "compile", "scope_default", "compileChildren", "targets", "element", "path", "options", "template", "children", "n", "fragment", "compileNode", "compileAttributes", "attributes", "attribute", "compileAttribute", "compileElement", "overload", "id", "node", "toType", "pathSeparator", "indexOf", "string", "isLiteralString", "source", "decode", "target", "TextRenderer", "compile", "scope_default", "compile_node_default", "assign", "cache", "Template", "_Template", "id", "fragment", "options", "compile_node_default", "create_default", "html", "template", "settings", "identifier", "identify", "consts", "assign", "getChild", "element", "index", "getElement", "path", "node", "pathSeparator", "getContextFragment", "template", "range", "html", "defs", "create_default", "fragment", "toTemplate", "compiled", "parameters", "name", "toRenderer", "Renderer", "literal", "stop", "renderer", "Literal", "_Literal", "#first", "object", "Data", "assign", "children", "first", "last", "removeRange", "identifier", "data", "Template", "options", "id", "entries", "map", "toMap", "urls", "path1", "path2", "url", "map", "object", "entries", "rewriteURL", "path", "Literal", "scope_default"]
}
