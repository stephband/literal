{
  "version": 3,
  "sources": ["../../fn/modules/id.js", "../../fn/modules/overload.js", "../../fn/modules/cache.js", "../../fn/modules/curry.js", "../../fn/modules/noop.js", "../../dom/modules/assign.js", "../../dom/modules/create.js", "../../fn/modules/exec.js", "../../fn/modules/capture.js", "../../dom/modules/log.js", "../../dom/modules/element.js", "../../fn/modules/choose.js", "../../dom/modules/request.js", "../library/include-html.js", "../../fn/observer/observer.js", "../elements/include-html.js", "../library/request.js", "../../dom/modules/identify.js", "../../dom/modules/is-text-node.js", "../../dom/modules/to-type.js", "../../fn/modules/by.js", "../../fn/modules/equals.js", "../../fn/modules/matches.js", "../../fn/modules/nothing.js", "../../fn/modules/get-path.js", "../../fn/modules/slugify.js", "../../fn/modules/last.js", "../../fn/modules/to-type.js", "../../fn/modules/parse-value.js", "../../dom/modules/style.js", "../../dom/modules/parse-length.js", "../../fn/modules/stream/stopable.js", "../../fn/modules/stream/producer.js", "../../fn/modules/is-iterable.js", "../../fn/modules/stream/buffer-producer.js", "../../fn/modules/stream/promise-producer.js", "../../fn/modules/stream/stream.js", "../../fn/modules/stream/broadcast.js", "../../fn/modules/stream/combine-producer.js", "../../fn/modules/stream/merge-producer.js", "../../fn/modules/stream/zip-producer.js", "../../fn/modules/stream.js", "../../fn/observer/observe.js", "../modules/library.js", "../../fn/modules/get.js", "../../fn/modules/compile.js", "../renderers/analytics.js", "../modules/compile.js", "../modules/to-text.js", "../../fn/modules/remove.js", "../modules/gets.js", "../renderers/batcher.js", "../renderers/renderer.js", "../renderers/property-names.js", "../renderers/attribute-renderer.js", "../renderers/boolean-renderer.js", "../../fn/modules/is-defined.js", "../../dom/modules/event.js", "../../dom/modules/trigger.js", "../modules/config.js", "../renderers/checked-renderer.js", "../library/include-literal.js", "../renderers/content-renderers.js", "../renderers/content-renderer.js", "../renderers/tokens-renderer.js", "../renderers/value-renderer.js", "../modules/decode.js", "../modules/compile-node.js", "../renderers/template-renderer.js", "../elements/include-literal.js", "../modules/analytics.js", "../../dom/modules/events.js", "../../dom/modules/rect.js", "../../fn/modules/to-array.js", "../../dom/modules/select.js", "../module.js"],
  "sourcesContent": ["/**\nid(value)\nReturns `value`.\n*/\n\nexport default function id(value) { return value; }\n", "/**\noverload(fn, map)\n\nReturns a function that calls a function at the property of `object` that\nmatches the result of calling `fn` with all arguments.</p>\n\n```\nvar fn = overload(toType, {\n    string: function a(name, n) {...},\n    number: function b(n, m) {...}\n});\n\nfn('pie', 4); // Returns a('pie', 4)\nfn(1, 2);     // Returns b(1, 2)\n```\n*/\n\n\nexport default function overload(fn, map) {\n    return function overload() {\n        const key     = fn.apply(this, arguments);\n        const handler = (map[key] || map.default);\n\n        if (!handler) {\n            throw new Error('overload() no handler for \"' + key + '\"');\n        }\n\n        return handler.apply(this, arguments);\n    };\n}\n", "/**\ncache(fn)\nReturns a function that caches the output values of `fn(input)`\nagainst input values in a map, such that for each input value\n`fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cache(fn) {\n    var map = new Map();\n\n    return function cache(object) {\n        if (window.DEBUG && !warned && object === undefined) {\n            warned = true;\n            console.warn('cache() called with undefined. Not illegal, but worthy of a warning.');\n        }\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cache() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        if (map.has(object)) {\n            return map.get(object);\n        }\n\n        var value = fn(object);\n        map.set(object, value);\n        return value;\n    };\n}\n", "/**\ncurry(fn [, muteable, arity])\nReturns a function that wraps `fn` and makes it partially applicable.\n*/\n\nimport cache from './cache.js';\n\nconst A     = Array.prototype;\n\nfunction applyFn(fn, args) {\n    return typeof fn === 'function' ? fn.apply(null, args) : fn ;\n}\n\nfunction curry(fn, muteable, arity) {\n    arity = arity || fn.length;\n\n    var memo = arity === 1 ?\n        // Don't cache if `muteable` flag is true\n        muteable ? fn : cache(fn) :\n\n        // It's ok to always cache intermediate memos, though\n        cache(function(object) {\n            return curry(function() {\n                var args = [object];\n                args.push.apply(args, arguments);\n                return fn.apply(null, args);\n            }, muteable, arity - 1) ;\n        }) ;\n\n    return function partial(object) {\n        return arguments.length === 0 ?\n            partial :\n        arguments.length === 1 ?\n            memo(object) :\n        arguments.length >= arity ?\n            fn.apply(null, arguments) :\n        // This is bad, I think. We don't want [[fn],[fn]].map(get(0)) to be firing the fns\n        //arguments.length > arity ?\n        //    applyFn(fn.apply(null, A.splice.call(arguments, 0, arity)), arguments) :\n        applyFn(memo(object), A.slice.call(arguments, 1)) ;\n    };\n}\n\n//function curry(fn, muteable, arity) {\n//    arity = arity || fn.length;\n//    return function curried() {\n//        return arguments.length >= arity ?\n//            fn.apply(null, arguments) :\n//            curried.bind(null, ...arguments) ;\n//    };\n//}\n\nif (window.DEBUG) {\n    const _curry = curry;\n\n    // Feature test\n\tconst isFunctionLengthDefineable = (function() {\n\t\tvar fn = function() {};\n\n\t\ttry {\n\t\t\t// Can't do this on Safari - length non configurable :(\n\t\t\tObject.defineProperty(fn, 'length', { value: 2 });\n\t\t}\n\t\tcatch(e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fn.length === 2;\n\t})();\n\n    const setFunctionProperties = function setFunctionProperties(text, parity, fn1, fn2) {\n        // Make the string representation of fn2 display parameters of fn1\n        fn2.toString = function() {\n            return /function\\s*[\\w\\d]*\\s*\\([,\\w\\d\\s]*\\)/.exec(fn1.toString()) + ' { [' + text + '] }';\n        };\n\n        // Where possible, define length so that curried functions show how\n        // many arguments they are yet expecting\n        if (isFunctionLengthDefineable) {\n            Object.defineProperty(fn2, 'length', { value: parity });\n        }\n\n        return fn2;\n    };\n\n    // Make curried functions log a pretty version of their partials\n    curry = function curry(fn, muteable, arity) {\n        arity  = arity || fn.length;\n        return setFunctionProperties('curried', arity, fn, _curry(fn, muteable, arity));\n    };\n}\n\n\nexport default curry;\n", "/**\nnoop()\nReturns undefined.\n*/\n\nexport default function noop() {}\n", "/**\nassign(node, properties)\n\nAssigns each property of `properties` to `node`, as a property where that\nproperty exists in `node`, otherwise as an attribute.\n\nIf `properties` has a property `'children'` it must be an array of nodes;\nthey are appended to 'node'.\n\nThe property `'html'` is aliased to `'innerHTML'`. The property `'text'` \nis aliased to `'textContent'`. The property `'tag'` is treated as an alias \nof `'tagName'` (which is ignored, as `node.tagName` is read-only). The \nproperty `'is'` is also ignored.\n*/\n\nimport curry from '../../fn/modules/curry.js';\nimport id from '../../fn/modules/id.js';\nimport noop from '../../fn/modules/noop.js';\nimport overload from '../../fn/modules/overload.js';\n\nconst assignProperty = overload(id, {\n\t// Ignore read-only properties or attributes\n\tis: noop,\n\ttag: noop,\n\n\thtml: function(name, node, content) {\n\t\tnode.innerHTML = content;\n\t},\n\n\ttext: function(name, node, content) {\n\t\tnode.textContent = content;\n\t},\n\n\tchildren: function(name, node, content) {\n\t\t// Empty the node and append children\n\t\tnode.innerHTML = '';\n\t\tcontent.forEach((child) => { node.appendChild(child) });\n\t},\n\n\t// SVG points property must be set as string attribute - SVG elements\n\t// have a read-only API exposed at .points\n\tpoints: setAttribute,\n    cx:     setAttribute,\n    cy:     setAttribute,\n    r:      setAttribute,\n    preserveAspectRatio: setAttribute,\n    viewBox: setAttribute,\n\n\tdefault: function(name, node, content) {\n\t\tif (name in node) {\n\t\t\tnode[name] = content;\n\t\t}\n\t\telse {\n\t\t\tnode.setAttribute(name, content);\n\t\t}\n\t}\n});\n\nfunction setAttribute(name, node, content) {\n\tnode.setAttribute(name, content);\n}\n\nexport function assign(node, attributes) {\n\tvar names = Object.keys(attributes);\n\tvar n = names.length;\n\n\twhile (n--) {\n\t\tassignProperty(names[n], node, attributes[names[n]]);\n\t}\n\n\treturn node;\n}\n\nexport default curry(assign, true);\n", "\nimport id       from '../../fn/modules/id.js';\nimport overload from '../../fn/modules/overload.js';\nimport assign   from './assign.js';\n\nconst svgNamespace = 'http://www.w3.org/2000/svg';\n\nconst div           = document.createElement('div');\nconst typeofTag     = (tag, content)  => (tag && typeof tag);\nconst typeofContent = (type, content) => (content && typeof content);\n\n// Constructors\n\nfunction createContextFragment(context, html) {\n    const range = document.createRange();\n    range.selectNode(context);\n    return range.createContextualFragment(html);\n}\n\nfunction createSVG(tag, html) {\n    var node = document.createElementNS(svgNamespace, tag);\n\n    if (html) {\n        node.innerHTML = html;\n    }\n\n    return node;\n}\n\n/**\ncreate(tag, content)\n\nConstructs and returns a new DOM node.\n\n- If `tag` is `\"text\"` a text node is created.\n- If `tag` is `\"fragment\"` a fragment is created.\n- If `tag` is `\"comment\"` a comment is created.\n- If `tag` is any other string the element `<tag></tag>` is created.\n\nWhere a comment or text node is created `content` must be a string, as is set as\ntextContent. For fragments and other nodes:\n\n- If `content` is a string it is set as innerHTML.\n- If `content` is array-like its items are appended to node. Note that where\n`content` is a NodeList, this removes nodes from whatever the NodeList belongs\nto.\n- If `content` is an object its properties are assigned as node properties or\nattributes.\n\nWhere node is a fragment there is an optional third parameter `context`, which\nmust be an element. The fragment parser is run in the context of the element:\n\n```\ncreate('fragment', '<li>', document.querySelector('ul'));\n```\n**/\n\nconst create = overload(id, {\n    comment: function(tag, text) {\n        return document.createComment(text || '');\n    },\n\n    fragment: overload(typeofContent, {\n        string: function(tag, html, context) {\n            if (context) {\n                return createContextFragment(context, html);\n            }\n\n            const fragment = document.createDocumentFragment();\n            div.innerHTML = html;\n            const nodes = div.childNodes;\n            while (nodes[0]) { fragment.appendChild(nodes[0]); }\n            return fragment;\n        },\n\n        object: function(tag, object, context) {\n            // If there is context, create a context-aware fragment\n            const fragment = context ?\n                createContextFragment(context) :\n                document.createDocumentFragment() ;\n\n            // Is object array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                fragment.append.apply(fragment, object);\n            }\n            else {\n                assign(fragment, object);\n            }\n\n            return fragment;\n        },\n\n        default: () => document.createDocumentFragment()\n    }),\n\n    text: function (tag, text) {\n        return document.createTextNode(text || '');\n    },\n\n    circle:   createSVG,\n    ellipse:  createSVG,\n    g:        createSVG,\n    glyph:    createSVG,\n    image:    createSVG,\n    line:     createSVG,\n    rect:     createSVG,\n    use:      createSVG,\n    path:     createSVG,\n    pattern:  createSVG,\n    polygon:  createSVG,\n    polyline: createSVG,\n    svg:      createSVG,\n\n    default: overload(typeofContent, {\n        string: function(tag, html) {\n            const node = document.createElement(tag);\n            node.innerHTML = html;\n            return node;\n        },\n\n        object: function(tag, object) {\n            const node = document.createElement(tag);\n\n            // Is it array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                node.append.apply(node, object);\n            }\n            else {\n                assign(node, object);\n            }\n\n            return node;\n        },\n\n        default: (tag) => {\n            if (typeof tag !== 'string') {\n                // We used to support object as first argument. Deprecated.\n                // Todo: remove this message when we dont see any more errors\n                throw new Error('create(tag, content) accepts only a string as tag \"' + (typeof tag) + '\"')\n            }\n\n            return document.createElement(tag);\n        }\n    }),\n});\n\nexport default create;\n\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { create });\n}\n", "/**\nexec(regex, fn, string)\n\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n*/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + string + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "\nimport noop from '../../fn/modules/noop.js';\n\nexport default window.DEBUG ?\n    function log(name, ...args) {\n        if (window.console && window.console.log) {\n            window.console.log('%cdom %c' + name + '%c', 'color: #888888; font-weight: 400;', 'color: #3a8ab0; font-weight: 600;', 'color: inherit; font-weight: 400;', ...args);\n         }\n    } :\n    noop ;\n", "\n/**\nelement(name, options)\n\nRegisters a custom element and returns its constructor.\n\n- name: `'element-name'` or `'tag is=\"element-name\"'`\n- options: {\n    mode:       'open' or 'closed', defaults to 'closed'\n    focusable:  true or false, defaults to true\n    properties: An object of attribute and property handlers\n    \n    // Lifecycle handlers\n    stylesheet: optional string path to stylesheet for shadow DOM\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in \nbrowsers that support the feature. Safari is a known culprit. Mileage will vary.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser \nsupport.\n\nAt the start of initialisation the `construct` handler is called. Use it to\nset up a shadow root and define event handlers. Children and attributes must\nnot be inspected or assigned at this point – doing so will throw in some cases,\neg. construction via `document.createElement()`.\n\nFollowing that, attribute handlers are called for attributes declared in the\nHTML. The parser normally calls these in source order, but this can be problematic\nif you require setup to run in a specific order so here they are run in the order\ndeclared in the `options.properties`.\n\nThen the `connect` handler is called when the element is placed in the DOM\nor if it is already in the DOM and is being upgraded.\n\nFinally the `load` handler is called after the first connect, and after any\nstylesheet links in the shadow DOM have loaded. If there are no links, it is\ncalled immediately after `connect`.\n\nAll lifecycle handlers are called with the parameter `(shadow)`.\n*/\n\nimport create  from './create.js';\nimport capture from '../../fn/modules/capture.js';\nimport log     from './log.js';\n\nconst $internals = Symbol('internals');\nconst $shadow    = Symbol('shadow');\n\nconst define = Object.defineProperties;\n\nconst constructors = {\n    // We need list only those whose constructor names do not match their tag\n    'a':        HTMLAnchorElement,\n    'dl':       HTMLDListElement,\n    'p':        HTMLParagraphElement,\n    'br':       HTMLBRElement,\n    'fieldset': HTMLFieldSetElement,\n    'hr':       HTMLHRElement,\n    'img':      HTMLImageElement,\n    'li':       HTMLLIElement,\n    'ol':       HTMLOListElement,\n    'optgroup': HTMLOptGroupElement,\n    'q':        HTMLQuoteElement,\n    'textarea': HTMLTextAreaElement,\n    'td':       HTMLTableCellElement,\n    'th':       HTMLTableCellElement,\n    'tr':       HTMLTableRowElement,\n    'tbody':    HTMLTableSectionElement,\n    'thead':    HTMLTableSectionElement,\n    'tfoot':    HTMLTableSectionElement,\n    'ul':       HTMLUListElement\n};\n\nconst formProperties = {\n    // These properties echo those provided by native form controls.\n    // They are not strictly required, but provided for consistency.\n    //type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function() { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get: function() { return this[$internals].form; }},\n    labels:            { get: function() { return this[$internals].labels; }},\n    validity:          { get: function() { return this[$internals].validity; }},\n    validationMessage: { get: function() { return this[$internals].validationMessage; }},\n    willValidate:      { get: function() { return this[$internals].willValidate; }},\n    checkValidity:     { value: function() { return this[$internals].checkValidity(); }},\n    reportValidity:    { value: function() { return this[$internals].reportValidity(); }}\n};\n\nconst nothing   = {};\nconst onceEvent = { once: true };\nconst shadowParameterIndex = 0;\n\nlet supportsCustomisedBuiltIn = false;\n\nfunction getElementConstructor(tag) {\n        // Return a constructor from the known list of tag names – not all tags\n        // have constructor names that match their tags\n    return constructors[tag]\n        // Or assemble the tag name in the form \"HTMLTagElement\" and return\n        // that property of the window object\n        || window['HTML' + tag[0].toUpperCase() + tag.slice(1) + 'Element']\n        || (() => {\n            throw new Error('Constructor not found for tag \"' + tag + '\"');\n        })();\n}\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst captureNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is=[\"']?([a-z][\\w]*-[\\w]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n    \n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() – name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nfunction transferProperty(elem, key) {\n    if (elem.hasOwnProperty(key)) {\n        const value = elem[key];\n        delete elem[key];\n        elem[key] = value;\n    }\n\n    return elem;\n}\n\nfunction createShadow(/*template, */elem, options) {\n    elem._initialLoad = true;\n\n    // Create a shadow root if there is DOM content. Shadows may be 'open' or\n    // 'closed'. Closed shadows are not exposed via element.shadowRoot, and\n    // events propagating from inside of them report the element as target.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (options.stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: options.stylesheet });\n        shadow.append(link);\n    }\n\n    elem[$shadow] = shadow;\n\n    return shadow;\n}\n\nfunction attachInternals(elem) {\n    var internals;\n\n    // Use native attachInternals where it exists\n    if (elem.attachInternals) {\n        internals = elem.attachInternals();\n        if (internals.setFormValue) {\n            return internals;\n        }\n    }\n    else {\n        internals = {\n            shadowRoot: elem.shadowRoot\n        };\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however – it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    internals.input = create('input', { type: 'hidden', name: elem.name });\n    elem.appendChild(internals.input);\n\n    // Polyfill internals object setFormValue\n    internals.setFormValue = function(value) {\n        this.input.value = value;\n    };\n\n    return internals;\n}\n\nfunction primeAttributes(elem) {\n    elem._initialAttributes = {};\n    elem._n = 0;\n}\n\nfunction advanceAttributes(elem, attributes, handlers) {\n    const values = elem._initialAttributes;\n\n    while(elem._n < attributes.length && values[attributes[elem._n]] !== undefined) {\n        //console.log('ADVANCE ATTR', attributes[elem._n]);\n        handlers[attributes[elem._n]].call(elem, values[attributes[elem._n]]);\n        ++elem._n;\n    }\n}\n\nfunction flushAttributes(elem, attributes, handlers) {\n    if (!elem._initialAttributes) { return; }\n\n    const values = elem._initialAttributes;\n\n    while(elem._n < attributes.length) {\n        if (values[attributes[elem._n]] !== undefined && handlers[attributes[elem._n]]) {\n            handlers[attributes[elem._n]].call(elem, values[attributes[elem._n]]);\n        }\n        ++elem._n;\n    }\n\n    delete elem._initialAttributes;\n    delete elem._n;\n}\n\nfunction hasPropertyAttribute(option) {\n    return !!option.attribute;\n}\n\nfunction hasPropertyDefinition(option) {\n    return option.set || option.get || option.hasOwnProperty('value');\n}\n\nfunction groupAttributeProperty(data, entry) {\n    if (hasPropertyAttribute(entry[1])) {\n        data.attributes[entry[0]] = entry[1].attribute;\n    }\n\n    if (hasPropertyDefinition(entry[1])) {\n        data.properties[entry[0]] = entry[1];\n    }\n\n    return data;\n}\n\nexport default function element(definition, lifecycle, api) {\n    const { name, tag } = captureNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    const { attributes, properties } = api ?\n            Object.entries(api).reduce(groupAttributeProperty, {\n                attributes: {}, \n                properties: {}\n            }) :\n        // Support the old way, a single options object with props and lifecycle included\n        lifecycle.properties ?\n            Object.entries(lifecycle.properties).reduce(groupAttributeProperty, {\n                attributes: {}, \n                properties: {}\n            }) :\n        nothing ;\n\n    function Element() {\n        // Construct an instance from Constructor using the Element prototype\n        const elem   = Reflect.construct(constructor, arguments, Element);\n        const shadow = lifecycle.construct && lifecycle.construct.length > shadowParameterIndex ?\n            createShadow(elem, lifecycle) :\n            undefined ;\n\n        // Get access to the internal form control API\n        const internals = Element.formAssociated && attachInternals(elem) ;\n\n        if (tag) {\n            supportsCustomisedBuiltIn = true;\n        }\n\n        lifecycle.construct && lifecycle.construct.call(elem, shadow, internals);\n\n        // Preserve initialisation order of attribute initialisation by\n        // queueing them\n        if (attributes) {\n            primeAttributes(elem);\n\n            // Wait a tick to flush attributes\n            Promise.resolve(1).then(function() {\n                flushAttributes(elem, Element.observedAttributes, attributes);\n            });\n        }\n\n        // At this point, if properties have already been set before the\n        // element was upgraded, they exist on the elem itself, where we have\n        // just upgraded it's protytype to define those properties those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype\n        //    Object.defineProperties(elem, properties);\n        //\n        // 2. Take a great deal of care not to set properties before an element\n        //    is upgraded. I can't impose a restriction like that.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy you have to do this, though.\n        properties\n        && Object.keys(properties).reduce(transferProperty, elem);\n\n        return elem;\n    }\n\n\n    // Properties\n    //\n    // Must be defined before attributeChangedCallback, but I cannot figure out\n    // why. Where one of the properties is `value`, the element is set up as a\n    // form element.\n    Element.prototype = Object.create(constructor.prototype, properties) ;\n\n\n    // Form properties\n\n    if (properties && properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n        \n        // Define standard form properties\n        define(Element.prototype, formProperties);\n    \n        if (lifecycle.enable || lifecycle.disable) {\n            Element.prototype.formDisabledCallback = function(disabled) {\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.call(this, this[$shadow], this[$internals]) :\n                    lifecycle.enable && lifecycle.enable.call(this, this[$shadow], this[$internals]) ;\n            };\n        }\n        \n        if (lifecycle.reset) {\n            Element.prototype.formResetCallback = function() {\n                return lifecycle.reset.call(this, this[$shadow], this[$internals]);\n            };\n        }\n        \n        if (lifecycle.restore) {\n            Element.prototype.formStateRestoreCallback = function() {\n                return lifecycle.restore.call(this, this[$shadow], this[$internals]);\n            };\n        }\n    }\n\n\n    // Attributes\n\n    if (attributes) {\n        Element.observedAttributes = Object.keys(attributes);\n\n        Element.prototype.attributeChangedCallback = function(name, old, value) {\n            if (!this._initialAttributes) {\n                return attributes[name].call(this, value) ;\n            }\n\n            // Keep a record of attribute values to be applied in\n            // observedAttributes order\n            this._initialAttributes[name] = value;\n            advanceAttributes(this, Element.observedAttributes, attributes);\n        };\n    }\n\n\n    // Lifecycle\n\n    Element.prototype.connectedCallback = function() {\n        const elem      = this;\n        const shadow    = elem[$shadow];\n        const internals = elem[$internals];\n\n        // Initialise any attributes that appeared out of order\n        if (elem._initialAttributes) {\n            flushAttributes(elem, Element.observedAttributes, attributes);\n        }\n\n        // If we have simulated form internals, append the hidden input now\n        //if (elem[$internals] && !elem.attachInternals) {\n        //    elem.appendChild(elem[$internals].input);\n        //}\n\n        // If this is the first connect and there is an lifecycle.load fn,\n        // _initialLoad is true\n        if (elem._initialLoad) {\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                let count  = 0;\n                let n = links.length;\n\n                const load = function load(e) {\n                    if (++count >= links.length) {\n                        // Delete _initialLoad. If the element is removed\n                        // and added to the DOM again, stylesheets do not load\n                        // again\n                        delete elem._initialLoad;\n                        if (lifecycle.load) {\n                            log('element()', 'loaded', Array.from(links).map((link) => link.href).join('\\n'));\n                            lifecycle.load.call(elem, shadow);\n                        }\n                    }\n                };\n\n                const error = window.DEBUG ? function error(e) {\n                    console.error('Failed to load stylesheet', e.target.href);\n                    load(e);\n                } :\n                load ;\n\n                while (n--) {\n                    links[n].addEventListener('load', load, onceEvent);\n                    links[n].addEventListener('error', error, onceEvent);\n                }\n\n                lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n            }\n            else {\n                lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n                lifecycle.load    && lifecycle.load.call(this, shadow, internals);\n            }\n        }\n        else {\n            lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n        }\n    }\n\n    if (lifecycle.disconnect) {\n        Element.prototype.disconnectedCallback = function() {\n            return lifecycle.disconnect.call(this, this[$shadow], this[$internals]);\n        };\n    }\n\n    log('element()', '<' + (tag ? tag + ' is=' + name + '' : name) + '>');\n\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n    // Where tag is supplied, element should have been registered as a customised \n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to \n    // go some way towards filling in support by searching for elements and \n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        if (window.DEBUG) {\n            console.warn('Browser does not support customised built-in elements.\\nAttempting to partially polyfill instances of <' + tag + ' is=\"' + name + '\"> found in the DOM.');\n        }\n\n        document.querySelectorAll('[is=\"' + name + '\"]').forEach((element) => {\n            // Define properties on element\n            define(element, properties);\n\n            // Run constructor\n            lifecycle.construct && lifecycle.construct.apply(element);\n\n            // Detect and run attributes\n            let name;\n            for (name in attributes) {\n                const attribute = element.attributes[name];\n                if (attribute) {\n                    attributes[name].call(element, attribute.value);\n                }\n            }\n\n            lifecycle.connect && lifecycle.connect.apply(element);\n        });\n    }\n\n    return Element;\n}\n", "/**\nchoose(fn, map)\nReturns a function that takes its first argument as a key and uses it\nto select a function in `map` which is invoked with the remaining arguments.\n\nWhere `map` has a function `default`, that function is run when a key\nis not found, otherwise unfound keys will error.\n\n```\nvar fn = choose({\n    'fish':  function fn1(a, b) {...},\n    'chips': function fn2(a, b) {...}\n});\n\nfn('fish', a, b);   // Calls fn1(a, b)\n```\n*/\n\nexport default function choose(map) {\n    return function choose(key, ...params) {\n        var fn = map[key] || map.default;\n        return fn && fn.apply(this, params) ;\n    };\n}\n", "import choose  from '../../fn/modules/choose.js';\nimport id      from '../../fn/modules/id.js';\n\nconst assign = Object.assign;\n\n/*\nconfig\n\n```{\n    headers:    fn(data),    // Must return an object with properties to add to the header\n    body:       fn(data),    // Must return an object to send as data\n    onresponse: function(response)\n}```\n*/\n\nexport const config = {\n    // Takes data, returns headers\n    headers: function(data) { return {}; },\n\n    // Takes data (can be FormData object or plain object), returns data\n    body: id,\n\n    // Takes response, returns response\n    onresponse: function(response) {\n        // If redirected, navigate the browser away from here. Can get\n        // annoying when receiving 404s, maybe not a good default...\n        if (response.redirected) {\n            window.location = response.url;\n            return;\n        }\n\n        return response;\n    }\n};\n\nconst createHeaders = choose({\n    'application/x-www-form-urlencoded': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'application/x-www-form-urlencoded',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'application/json': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'multipart/form-data': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'multipart/form-data',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'audio/wav': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'audio/wav',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'default': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'application/x-www-form-urlencoded',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    }\n});\n\nconst createBody = choose({\n    'application/json': function(data) {\n        return data.get ?\n            formDataToJSON(data) :\n            JSON.stringify(data);\n    },\n\n    'application/x-www-form-urlencoded': function(data) {\n        return data.get ?\n            formDataToQuery(data) :\n            dataToQuery(data) ;\n    },\n\n    'multipart/form-data': function(data) {\n        // Mmmmmhmmm?\n        return data.get ?\n            data :\n            dataToFormData(data) ;\n    }\n});\n\nfunction formDataToJSON(formData) {\n    return JSON.stringify(\n        // formData.entries() is an iterator, not an array\n        Array\n        .from(formData.entries())\n        .reduce(function(output, entry) {\n            output[entry[0]] = entry[1];\n            return output;\n        }, {})\n    );\n}\n\nfunction formDataToQuery(data) {\n    return new URLSearchParams(data).toString();\n}\n\nfunction dataToQuery(data) {\n    return Object.keys(data).reduce((params, key) => {\n        params.append(key, data[key]);\n        return params;\n    }, new URLSearchParams());\n}\n\nfunction dataToFormData(data) {\n    throw new Error('TODO: dataToFormData(data)');\n}\n\nfunction urlFromData(url, data) {\n    // Form data\n    return data instanceof FormData ?\n        url + '?' + formDataToQuery(data) :\n        url + '?' + dataToQuery(data) ;\n}\n\nfunction createOptions(method, data, head, controller) {\n    const contentType =\n        typeof head === 'string' ? head :\n        head && head['Content-Type'] ||\n        'application/json' ;\n\n    const headers = createHeaders(contentType, assign(\n        config.headers && data ? config.headers(data) : {},\n        typeof head === 'string' ? {} : head\n    ));\n\n    const options = {\n        method:  method,\n        headers: headers,\n        credentials: 'same-origin',\n        signal: controller && controller.signal\n    };\n\n    if (method !== 'GET') {\n        options.body = createBody(contentType, config.body ? config.body(data) : data);\n    }\n\n    return options;\n}\n\nconst responders = {\n    'text/html': respondText,\n    'application/json': respondJSON,\n    'multipart/form-data': respondForm,\n    'application/x-www-form-urlencoded': respondForm,\n    'audio': respondBlob,\n    'audio/wav': respondBlob,\n    'audio/m4a': respondBlob\n};\n\nfunction respondBlob(response) {\n    return response.blob();\n}\n\nfunction respondJSON(response) {\n    return response.json().catch((e) => {\n        throw new Error('Cannot parse JSON ' + response.url + '. ' + e.message + '');\n    });\n}\n\nfunction respondForm(response) {\n    return response.formData();\n}\n\nfunction respondText(response) {\n    return response.text();\n}\n\nfunction respond(response) {\n    if (config.onresponse) {\n        response = config.onresponse(response);\n    }\n\n    if (!response.ok) {\n        throw new Error(response.statusText + '');\n    }\n\n    // Get mimetype from Content-Type, remembering to hoik off any\n    // parameters first\n    const mimetype = response.headers\n    .get('Content-Type')\n    .replace(/\\;.*$/, '');\n\n    return responders[mimetype](response);\n}\n\n\n/**\nrequest(method, url, data, mimetype | headers)\n\nUses `fetch()` to send a request to `url`. Where `type` is `\"GET\"`, `data` is\nserialised and appended to the URL, otherwise it is sent as a request body.\nThe 4th parameter may be a content type string or a headers object (in which\ncase it must have a `'Content-Type'` property).\n**/\n\nexport default function request(method = 'GET', url, data, contenttype = 'application/json') {\n    if (url.startsWith('application/') || url.startsWith('multipart/') || url.startsWith('text/') || url.startsWith('audio/')) {\n        throw new Error('request(method, url, data, contenttype) parameter order has changed. You passed (method, contenttype, url, data).');\n    }\n\n    method = method.toUpperCase();\n\n    // If this is a GET and there is data, append data to the URL query string\n    if (method === 'GET' && data) {\n        url = urlFromData(url, data);\n    }\n\n    // param[4] is an optional abort controller\n    const options = createOptions(method, data, contenttype, arguments[4]);\n    return fetch(url, options).then(respond);\n}\n\n/**\nrequestGet(url)\nA shortcut for `request('get', url, null, 'application/json')`\n**/\n\nexport function requestGet(url) {\n    return request('GET', url);\n}\n\n/**\nrequestPatch(url, data)\nA shortcut for `request('patch', 'application/json', url, data)`\n**/\n\nexport function requestPatch(url, data) {\n    return request('PATCH', url, data, 'application/json');\n}\n\n/**\nrequestPost(url, data)\nA shortcut for `request('post', 'application/json', url, data)`\n**/\n\nexport function requestPost(url, data) {\n    return request('POST', url, data, 'application/json');\n}\n\n/**\nrequestDelete(url, data)\nA shortcut for `request('delete', 'application/json', url, data)`\n**/\n\nexport function requestDelete(url, data) {\n    return request('DELETE', url, data, 'application/json');\n}\n\n/*\nthrottledRequest(type, mimetype, url)\n*/\n\nfunction ignoreAbortError(error) {\n    // Swallow AbortErrors, since we generate one every time we use\n    // the AbortController.\n    if (error.name === 'AbortError') {\n        console.log('Request aborted by throttle. Nothing to worry about.');\n\n        // JS promises have no machanism to conditionally catch different\n        // types of error – throw undefined to fall through to the next\n        // catch without a value.\n        throw undefined;\n    }\n\n    // Rethrow all other errors\n    throw error;\n}\n\nexport function throttledRequest(type, mimetype, url) {\n    var controller, data, promise;\n\n    function then() {\n        controller = undefined;\n    }\n\n    function send() {\n        controller = new AbortController();\n        var req = request(type, mimetype, url, data, controller);\n        req.then(then);\n        promise = undefined;\n        data    = undefined;\n        return req;\n    }\n\n    return function(object) {\n        data = object;\n\n        if (promise) {\n            return promise;\n        }\n\n        // Cancel previous request\n        if (controller) {\n            controller.abort();\n            controller = undefined;\n        }\n\n        // Batch requests to ticks\n        return promise = Promise\n        .resolve()\n        .then(send)\n        .catch(ignoreAbortError);\n    };\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n\twindow.dom ? (window.dom.request = request) : (window.dom = { request });\n}\n", "\n/**\nincludeHTML(src)\nIncludes cloned html content from an external document at the `src` URL, or from\nthe content of an element identified by the `src` fragment identifier.\n**/\n\nimport create         from '../../dom/modules/create.js';\nimport { requestGet } from '../../dom/modules/request.js';\n\nexport default function includeHTML(url) {\n    if (!/^#/.test(url)) {\n        return requestGet(url).then((html) => create('fragment', html));\n    }\n\n    if (url.length < 2) {\n        throw new Error('hash identifier empty ' + url);\n    }\n\n    const id       = url.slice(1);\n    const template = document.getElementById(id);\n\n    if (!template) {\n        throw new Error('template not found ' + url);\n    }\n\n    return template.content ?\n        // Clone template content\n        template.content.cloneNode(true) :\n        // Clone element children /*, pass in template as context? */\n        create('fragment', template.cloneNode(true).childNodes /*, template*/) ;\n}\n", "\nconst assign       = Object.assign;\nconst define       = Object.defineProperties;\nconst isExtensible = Object.isExtensible;\n\nconst $trap = Symbol('observe');\n\nexport const analytics = {\n    observables: 0,\n    observes: 0\n};\n\nfunction remove(array, value) {\n    const i = array.indexOf(value);\n    if (i > -1) { array.splice(i, 1); }\n    return array;\n}\n\n\n/**\nTrap()\n**/\n\nconst properties = { [$trap]: {} };\n\nfunction fire(observables, value) {\n    if (!observables || !observables.length) { return 0; }\n    observables = observables.slice(0);\n    var n = -1;\n\n    while (observables[++n]) {\n        // Observables are objects with a fn property\n        observables[n].push(value);\n    }\n\n    return n;\n}\n\nfunction Trap(target) {\n    this.observables = {};\n    this.gets     = [];\n    this.sets     = undefined;\n    this.target   = target;\n    this.observer = new Proxy(target, this);\n\n    // Define trap as target[$trap]\n    properties[$trap].value = this;\n    define(target, properties);\n}\n\nassign(Trap.prototype, {\n\n    /* Helpers */\n\n    notify: function(name) {\n        fire(this.observables[name], this.target[name]);\n        fire(this.sets, this.target);\n    },\n\n    listen: function(name, observable) {\n        const observables = name === null ?\n            (this.sets || (this.sets = [])) :\n            (this.observables[name] || (this.observables[name] = [])) ;\n\n        observables.push(observable);\n    },\n\n    unlisten: function(name, observable) {\n        const observables = name === null ?\n            this.sets :\n            this.observables[name] ;\n\n        if (observables) {\n            remove(observables, observable);\n        }\n    },\n\n    /* Traps */\n\n    get: function get(target, name, proxy) {\n        const value = target[name];\n\n        // Don't observe changes to symbol properties, and\n        // don't allow Safari to log __proto__ as a Proxy. (That's dangerous!\n        // It pollutes Object.prototpye with [$trap] which breaks everything.)\n        // Also, we're not interested in observing the prototype chain so\n        // stick to hasOwnProperty.\n        if (typeof name === 'symbol' || name === '__proto__') {\n            return value;\n        }\n\n        // Is the property mutable? Note that unset properties have no descriptor\n        const descriptor = Object.getOwnPropertyDescriptor(target, name);\n        const mutable    = descriptor ?\n            descriptor.writable || descriptor.set :\n            value === undefined ;\n\n        if (mutable) {\n            fire(this.gets, name);\n        }\n\n        // Get the observer of its value\n        const observer = Observer(value);\n\n        if (!observer) {\n            return value;\n        }\n\n        // If get operations are being monitored, make them monitor the\n        // object at the named key also\n        var n = -1;\n        while(this.gets[++n]) {\n            this.gets[n].listen(name);\n        }\n\n        return observer;\n    },\n\n    set: function set(target, name, value, proxy) {\n        if (typeof name === 'symbol' || name === '__proto__') {\n            target[name] = value;\n            return true;\n        }\n\n        // Make sure we are dealing with an unproxied value\n        value = getTarget(value);\n\n        // If we are setting the same value, we're not really setting at all\n        if (target[name] === value) {\n            return true;\n        }\n\n        // To support arrays keep a note of pre-change length\n        const length = target.length;\n\n        // Unbind get listeners on the old value?\n        var n = -1;\n        while(this.gets[++n]) {\n            this.gets[n].unlisten(name);\n        }\n\n        // Set value on target. Then get the target's value just in case target\n        // is doing something funky with property descriptors that return a\n        // different value from the value that was set. Rare, but it can happen.\n        target[name] = value;\n\n        // Check if length has changed and notify if it has\n        if (name !== 'length' && target.length !== length) {\n            fire(this.observables.length, target.length);\n        }\n\n        this.notify(name);\n\n        // Return true to indicate success to Proxy\n        return true;\n    },\n\n    deleteProperty: function(target, name) {\n        if (typeof name === 'symbol' || name === '__proto__') {\n            // Delete without notifying\n            delete target[name];\n            return true;\n        }\n\n        if (!target.hasOwnProperty(name)) {\n            // Nothing to delete\n            return true;\n        }\n\n        delete target[name];\n        this.notify(name);\n\n        // Indicate success to the Proxy\n        return true;\n    }\n});\n\n\n/**\nisMuteable(object)\n**/\n\nexport function isMuteable(object) {\n    // Many built-in objects and DOM objects bork when calling their\n    // methods via a proxy. They should be considered not observable.\n    // I wish there were a way of whitelisting rather than\n    // blacklisting, but it would seem not.\n\n    return object\n        // Reject primitives and other frozen objects\n        // This is really slow...\n        //&& !isFrozen(object)\n        // I haven't compared this, but it's necessary for audio nodes\n        // at least, but then only because we're extending with symbols...\n        // hmmm, that may need to change...\n        && isExtensible(object)\n        // This is less safe but faster.\n        //&& (typeof object === 'object' || typeof object === 'function')\n\n        // Reject DOM nodes\n        && !Node.prototype.isPrototypeOf(object)\n        // Reject WebAudio context\n        && (typeof BaseAudioContext === 'undefined' || !BaseAudioContext.prototype.isPrototypeOf(object))\n        // Reject dates\n        && !(object instanceof Date)\n        // Reject regex\n        && !(object instanceof RegExp)\n        // Reject maps\n        && !(object instanceof Map)\n        && !(object instanceof WeakMap)\n        // Reject sets\n        && !(object instanceof Set)\n        && !(window.WeakSet && object instanceof WeakSet)\n        // Reject TypedArrays and DataViews\n        && !ArrayBuffer.isView(object) ;\n}\n\n\n/**\nObserver(object)\nCreate an observer proxy around `object`. Mutations made to this proxy are\nobservable via `observe(path, object` and `mutations(paths, object)`.\n**/\n\nexport function Observer(object) {\n    return !object ? undefined :\n        object[$trap] ? object[$trap].observer :\n        isMuteable(object) ? (new Trap(object)).observer :\n        undefined ;\n}\n\n\n/**\ngetTarget(object)\n**/\n\nexport function getTarget(object) {\n    return object && object[$trap] && object[$trap].target || object ;\n}\n\n\n/**\ngetTrap(object)\n**/\n\nexport function getTrap(object) {\n    return Observer(object) && object[$trap];\n}\n\n\n/*\nnotify(path, object)\nForce the `object`'s Observer to register a mutation at `path`.\n*/\n\nexport function notify(name, object) {\n    const trap = object[$trap];\n    if (trap) {\n        trap.notify(name);\n    }\n}\n", "\n/**\n<include-html>\n\nA `include-html` may be placed pretty much anywhere in your HTML, enabling\nthe insertion of static content.\n\nA `include-html` finds a source template identified by its `src` attribute\nthen replaces itself with the cloned content.\n\nA `include-html` may contain fallback content, in case any of that fails.\n\n```html\n<template id=\"greetings\">\n    Hello world.\n</template>\n\n<include-html src=\"#greetings\">\n    Fallback content.\n</include-html>\n```\n**/\n\nimport element        from '../../dom/modules/element.js';\nimport { requestGet } from '../../dom/modules/request.js';\nimport create         from '../../dom/modules/create.js';\nimport includeHTML    from '../library/include-html.js';\nimport print          from '../library/print.js';\n\nconst onerror = window.DEBUG ? (e, element) => {\n    element.loading = false;\n    element.replaceWith(print(e));\n    throw e;\n} : (e, include) => {\n    element.loading = false;\n    if (element.frame) { cancelAnimationFrame(element.frame); }\n    else { element.removeAttribute('loading'); }\n    throw e;\n} ;\n\nelement('<include-html>', {\n    construct: function() {\n        if (window.DEBUG && !this.hasAttribute('src')) {\n            console.error('<include-html> a src attribute is required', this);\n        }\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolveSrc = resolve;\n            this.rejectSrc = reject;\n        })\n        .catch((e) => onerror(e, this));\n    },\n\n    connect: function() {\n        // If we are loading at connect time, add the loading attribute after a\n        // couple of frames, allowing time for any styled transition to start\n        (this.loading && (this.frame = requestAnimationFrame(() =>\n            (this.loading && (this.frame = requestAnimationFrame(() =>\n                (this.loading && this.setAttribute('loading', ''))\n            )))\n        )));\n\n        // Cue up first render and replace\n        this.promise.then((dom) => {\n            this.loading = false;\n            this.replaceWith(dom);\n        });\n    }\n}, {\n    loading: {\n        /**\n        loading=\"\"\n        Read-only (pseudo-read-only) boolean attribute indicating status of\n        `src` request.\n        **/\n\n        /**\n        .loading\n        Read-only boolean indicating status of `src` request.\n        **/\n\n        value: false,\n        writable: true\n    },\n\n    /**\n    src=\"\"\n    Define a source document or node whose cloned content replaces this\n    `<include-html>` element. This is a required attribute.\n    **/\n\n    src: {\n        attribute: function(src) {\n            if (!src) {\n                return this.rejectSrc(new Error('<include-html> source src=\"' + value + '\" is empty'));\n            }\n\n            // Flag loading until we connect, at which point we add the\n            // loading attribute that may be used to indicate loading. Why\n            // wait? Because we are not in the DOM yet, and if we want a\n            // loading icon to transition in the transition must begin after\n            // we are already in the DOM.\n            this.loading = true;\n\n            // includeHTML may return a fragment or a promise\n            this.resolveSrc(includeHTML(src));\n        }\n    }\n});\n", "\n/**\nrequestData(url)\n\nTakes a `url` pointing to either a `.json` file, in which case it fetches and \nparses it, or a `.js` file, which it imports as a module, and returns a \npromise representing the result.\n\n```\nrequestData('./path/to/data.json');\n```\n\nWhere a `url` to a module is relative it is normalised to `window.location` so \nthat imports written in templates are treated relative to their location \n(dynamic `import()` would otherwise try and import relative to this \n`request.js` module).\n\n```\nrequestData('./path/to/module.js');\n```\n\nBy default a module request imports the default export. If `url` contains a \n`#fragment` identifier, the named export corresponding to the identifier is \nimported.\n\n```\nrequestData('./path/to/module#named');\n```\n\nIf the fragment identifier is also post-fixed with parameters then that named \nexport is treated as a constructor function and called:\n\n```\nrequestData('./path/to/module#named(\"parameter\")');\n```\n\nTo construct a default export use the name `default`:\n\n```\nrequestData('./path/to/module#default(\"parameter\")');\n```\n**/\n\nimport overload from '../../fn/modules/overload.js';\nimport cache from '../../fn/modules/cache.js';\nimport { requestGet } from '../../dom/modules/request.js';\n\nconst rextension = /\\.([\\w-]+)(?:#|\\?|$)/;\nconst rfragment  = /#(\\w+)(?:\\(([^\\)]*)\\))?$/;\nconst defaultexp = ['', 'default', ''];\nconst empty = [];\n\nexport default overload((url) => (rextension.exec(url) || empty)[1], {\n    js: (url) => {\n        // Rewrite relative import URLs to be absolute, taking the page as their\n        // relative root\n        const absolute = url[0] === '.' ?\n            new URL(url, window.location) :\n            url ;\n\n        // Otherwise use the export as data directly\n        return import(absolute).then((data) => data.default);\n    },\n\n    // Cache JSON requests in memory so that all requests to a given URL result \n    // in the same object.\n    default: cache((url) => requestGet(url))\n});\n", "/**\nidentify(node)\n\nReturns the id of `node`, or where `node` has no id, a random id is generated,\nchecked against the DOM for uniqueness, set on `node` and returned:\n\n```\n// Get ids of all buttons in document\nselect('button', document)\n.map(identify)\n.forEach((id) => ...)\n```\n*/\n\nexport default function identify(node) {\n\tvar id = node.id;\n\n\tif (!id) {\n\t\tdo { id = Math.ceil(Math.random() * 100000); }\n\t\twhile (document.getElementById(id));\n\t\tnode.id = id;\n\t}\n\n\treturn id;\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { identify });\n}\n", "\n/**\nisTextNode(node)\nReturns `true` if `node` is a text node.\n**/\n\nexport default function isTextNode(node) {\n    return node.nodeType === 3;\n}\n", "\n/**\ntoType(node)\n\nReturns one of `'element'`, `'text'`, `'comment'`, `'document'`,\n`'doctype'` or `'fragment'`.\n**/\n\nvar types = {\n    1:  'element',\n    3:  'text',\n    8:  'comment',\n    9:  'document',\n    10: 'doctype',\n    11: 'fragment'\n};\n\nexport default function toType(node) {\n    return types[node.nodeType];\n}\n", "/**\nby(fn, a, b)\nCompares `fn(a)` against `fn(b)` and returns `-1`, `0` or `1`. Useful for sorting\nobjects by property:\n\n```\n[{id: '2'}, {id: '1'}].sort(by(get('id')));  // [{id: '1'}, {id: '2'}]\n```\n**/\n\nimport curry from './curry.js';\n\nexport function by(fn, a, b) {\n    const fna = fn(a);\n    const fnb = fn(b);\n    return fnb === fna ? 0 : fna > fnb ? 1 : -1 ;\n}\n\nexport default curry(by, true);\n", "\n/**\nequals(a, b)\nPerform a deep equality comparison of `a` and `b`. Returns `true` if\nthey are equal.\n*/\n\nimport curry from './curry.js';\n\nexport function equals(a, b) {\n    // Fast out if references are for the same object\n    if (a === b) { return true; }\n\n    // If either of the values is null, or not an object, we already know\n    // they're not equal so get out of here\n    if (a === null ||\n        b === null ||\n        typeof a !== 'object' ||\n        typeof b !== 'object') {\n        return false;\n    }\n\n    // Compare their enumerable keys\n    const akeys = Object.keys(a);\n    const bkeys = Object.keys(b);\n\n    let n = akeys.length;\n    while (n--) {\n        // Has the property been set to undefined on a?\n        if (a[akeys[n]] === undefined) {\n            // We don't want to test if it is an own property of b, as\n            // undefined represents an absence of value\n            if (b[akeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // console.log(equals(a[akeys[n]], b[akeys[n]]), akeys[n], a[akeys[n]], b[akeys[n]]);\n            if (!b.hasOwnProperty(akeys[n]) || !equals(a[akeys[n]], b[akeys[n]])) {\n                return false;\n            }\n        }\n\n        const i = bkeys.indexOf(akeys[n]);\n        if (i > -1) {\n            bkeys.splice(i, 1);\n        }\n    }\n\n    n = bkeys.length;\n    while (n--) {\n        // Has the property been set to undefined on b?\n        if (b[bkeys[n]] === undefined) {\n            if (a[bkeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // We already know a does not have own property bkeys[n], because\n            // we have already been through all the enumerable properties\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport default curry(equals, true);\n", "/**\nmatches(selector, object)\nWhere `selector` is an object containing properties to be compared against\nproperties of `object`. If they are all strictly equal, returns `true`,\notherwise `false`.\n\n```\nconst vegeFoods = menu.filter(matches({ vegetarian: true }));\n```\n*/\n\nimport curry from './curry.js';\n\nexport function matches(object, item) {\n\tlet property;\n\tfor (property in object) {\n\t\tif (object[property] !== item[property]) { return false; }\n\t}\n\treturn true;\n}\n\nexport default curry(matches, true);\n", "import noop from './noop.js';\n\nconst define = Object.defineProperties;\nconst freeze = Object.freeze;\n\nfunction self() {\n    return this;\n}\n\nexport default freeze(define([], {\n    // Make array and stream methods no-ops\n    shift:   { value: noop },\n    push:    { value: noop },\n    each:    { value: noop },\n    forEach: { value: noop },\n    start:   { value: noop },\n    stop:    { value: noop },\n    done:    { value: noop },\n    join:    { value: function() { return ''; } },\n    map:     { value: self },\n    filter:  { value: self },\n    reduce:  { value: function(fn, accumulator) { return accumulator; } }\n}));\n", "\n/**\ngetPath(path, object)\n\nReturns the value at `path` in `object`.\n\n```\nconst value = getPath('path.to.value', object);\n```\n*/\n\nimport curry from './curry.js';\n\nconst rpath = /\\.?([\\w-]+)/g;\n\nfunction getRegexPathThing(regex, path, object) {\n    var tokens = regex.exec(path);\n\n    if (!tokens) {\n        throw new Error('getPath(path, object): invalid path \"' + path + '\" at index ' + regex.lastIndex);\n    }\n\n    return getRegexPath(regex, path, object[tokens[1]]);\n}\n\nfunction getRegexPath(regex, path, object) {\n        // At the end of a path return what we've got there\n    return regex.lastIndex === path.length ? object :\n        // Otherwise where object is falsy further drilldown is not possoble\n        !object ? undefined :\n        // Otherwise drill down\n        getRegexPathThing(regex, path, object) ;\n}\n\nexport function getPath(path, object) {\n    rpath.lastIndex = 0;\n    return getRegexPath(rpath, path, object) ;\n}\n\nexport default curry(getPath, true);\n", "/**\nslugify(string)\n\nReplaces any series of non-word characters with a `'-'` and lowercases the rest.\n\n```js\n    slugify('Party on #mydudes!') // 'party-on-mydudes'\n```\n**/\n\nexport default function slugify(string) {\n    // Accept a number or string\n    string = typeof string === 'number' ?\n        string + '' : \n        string.trim() ;\n\n    if (typeof string !== 'string') { return; }\n\n    return string\n    .toLowerCase()\n    .replace(/^[\\W_]+/, '')\n    .replace(/[\\W_]+$/, '')\n    .replace(/[\\W_]+/g, '-');\n}\n", "/**\nlast(array)\nGets the last value from an array.\n**/\n\nexport default function last(array) {\n    if (typeof array.length === 'number') {\n        return array[array.length - 1];\n    }\n\n    // Todo: handle Fns and Streams\n}\n", "/**\ntoType(object)\nReturns `typeof object`.\n*/\n\nexport default function toType(object) {\n    return typeof object;\n}\n", "import curry from './curry.js';\n\n/**\nparseValue(units, string)\n\nParse `string` as a value with a unit (such as `\"3px\"`). Parameter `units` is an\nobject of functions keyed by the unit postfix. It may also have a `catch`\nfunction.\n\n```js=\nconst value = parseValue({\n    px: function(n) {\n        return n;\n    },\n\n    catch: function(string) {\n        if (typeof string === 'number') {\n            return string;\n        }\n\n        throw new Error('Cannot parse px value');\n    }\n}, '36px');\n```\n**/\n\n// Be generous in what we accept, space-wise, but exclude spaces between the \n// number and the unit\nconst runit = /^\\s*([+-]?\\d*\\.?\\d+)([^\\s\\d]*)\\s*$/;\n\nexport function parseValue(units, string) {\n    // Allow number to pass through\n    if (typeof string === 'number') {\n        return string;        \n    }\n\n    var entry = runit.exec(string);\n\n    if (!entry || !units[entry[2] || '']) {\n        if (!units.catch) {\n            throw new Error('Cannot parse value \"' + string + '\" with provided units ' + Object.keys(units).join(', '));\n        }\n\n        return entry ?\n            units.catch(parseFloat(entry[1]), entry[2]) :\n            units.catch(parseFloat(string)) ;\n    }\n\n    return units[entry[2] || ''](parseFloat(entry[1]));\n}\n\nexport default curry(parseValue);\n", "/**\nstyle(property, node)\n\nReturns the computed style `property` of `node`.\n\n    style('transform', node);            // returns transform\n\nIf `property` is of the form `\"property:name\"`, a named aspect of the property\nis returned.\n\n    style('transform:rotate', node);     // returns rotation, as a number, in radians\n    style('transform:scale', node);      // returns scale, as a number\n    style('transform:translateX', node); // returns translation, as a number, in px\n    style('transform:translateY', node); // returns translation, as a number, in px\n*/\n\nvar rpx          = /px$/;\nvar styleParsers = {\n\t\"transform:translateX\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\treturn parseFloat(values[4]);\n\t},\n\n\t\"transform:translateY\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\treturn parseFloat(values[5]);\n\t},\n\n\t\"transform:scale\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\tvar a = parseFloat(values[0]);\n\t\tvar b = parseFloat(values[1]);\n\t\treturn Math.sqrt(a * a + b * b);\n\t},\n\n\t\"transform:rotate\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\tvar a = parseFloat(values[0]);\n\t\tvar b = parseFloat(values[1]);\n\t\treturn Math.atan2(b, a);\n\t}\n};\n\nfunction valuesFromCssFn(string) {\n\treturn string.split('(')[1].split(')')[0].split(/\\s*,\\s*/);\n}\n\nfunction computedStyle(name, node) {\n\treturn window.getComputedStyle ?\n\t\twindow\n\t\t.getComputedStyle(node, null)\n\t\t.getPropertyValue(name) :\n\t\t0 ;\n}\n\nexport default function style(name, node) {\n    // If name corresponds to a custom property name in styleParsers...\n    if (styleParsers[name]) { return styleParsers[name](node); }\n\n    var value = computedStyle(name, node);\n\n    // Pixel values are converted to number type\n    return typeof value === 'string' && rpx.test(value) ?\n        parseFloat(value) :\n        value ;\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { style });\n}\n", "// Units\n\nimport id         from '../../fn/modules/id.js';\nimport overload   from '../../fn/modules/overload.js';\nimport toType     from '../../fn/modules/to-type.js';\nimport parseValue from '../../fn/modules/parse-value.js';\nimport style      from './style.js';\n\n\n/* Track document font size */\n\nlet emSize;\nlet remSize;\n\nfunction getEmSize() {\n    if (!emSize) {\n        if (window.DEBUG) {\n            console.warn('Calculating root em value may cause reflow as user font-size cannot be known without setting <html style=\"font-size: 100%;\">');\n        }\n\n        const styledFontSize = document.documentElement.style.fontSize;\n        document.documentElement.style.fontSize = '100%';\n        emSize = style(\"font-size\", document.documentElement);\n        document.documentElement.style.fontSize = styledFontSize || '';\n    }\n\n    return emSize;\n}\n\nfunction getRemSize() {\n    if (!remSize) {\n        remSize = style(\"font-size\", document.documentElement);\n    }\n\n    return remSize;\n}\n\nwindow.addEventListener('resize', () => {\n    emSize  = undefined;\n    remSize = undefined;\n});\n\n/**\npx(value)\nTakes a number in pixels or a string of the form `'10px'`, `'10em'`, `'10rem'`,\n`'100vw'`, `'100vh'`, `'100vmin'` or `'100vmax'`, and returns a numeric value\nin pixels.\n*/\n\nexport const px = overload(toType, {\n    'number': id,\n\n    'string': parseValue({\n        em: function(n) {\n            return getEmSize() * n;\n        },\n\n        px: function(n) {\n            return n;\n        },\n\n        rem: function(n) {\n            return getRemSize() * n;\n        },\n\n        vw: function(n) {\n            return window.innerWidth * n / 100;\n        },\n\n        vh: function(n) {\n            return window.innerHeight * n / 100;\n        },\n\n        vmin: function(n) {\n            return window.innerWidth < window.innerHeight ?\n                window.innerWidth * n / 100 :\n                window.innerHeight * n / 100 ;\n        },\n\n        vmax: function(n) {\n            return window.innerWidth < window.innerHeight ?\n                window.innerHeight * n / 100 :\n                window.innerWidth * n / 100 ;\n        }\n    })\n});\n\nexport default px;\n\n/**\nem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `em`, eg. `0.625`. Depends on the user defined browser\n`font-size`.\n*/\n\nexport function em(n) {\n    return px(n) / getEmSize();\n}\n\n/**\nrem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `rem`, eg. `0.625`. Depends on the `font-size` of the\ndocumentElement.\n*/\n\nexport function rem(n) {\n    return px(n) / getRemSize();\n}\n\n/**\nvw(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vw`, eg. `120`. Depends on the width of the viewport at\nrender time.\n*/\n\nexport function vw(n) {\n    return 100 * px(n) / window.innerWidth;\n}\n\n/**\nvh(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vh`, eg. `120`. Depends on the height of the viewport at\nrender time.\n*/\n\nexport function vh(n) {\n    return 100 * px(n) / window.innerHeight;\n}\n\n/**\nvmin(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmin`, eg. `120`. Depends on the minimum dimension of the\nviewport at render time.\n*/\n\nexport function vmin(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerWidth :\n            window.innerHeight\n    );\n}\n\n/**\nvmax(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmax`, eg. `120`. Depends on the maximum dimension of the\nviewport at render time.\n*/\n\nexport function vmax(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerHeight :\n            window.innerWidth\n    );\n}\n\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { px, em, rem, vw, vh, vmin, vmax });\n}\n", "\nconst assign = Object.assign;\n\nfunction stopOne(stopable) {\n    return stopable.stop ?\n        stopable.stop() :\n        stopable() ;\n}\n\nfunction stopAll(stopables) {\n    stopables.forEach(stopOne);\n    stopables.length = 0;\n}\n\n\n/**\nStopable()\n**/\n\nexport default function Stopable() {}\n\nassign(Stopable.prototype, {\n    stop: function stop() {\n        this.stopables && stopAll(this.stopables);\n        return this;\n    },\n\n    done: function done(fn) {\n        const stopables = this.stopables || (this.stopables = []);\n        stopables.push(fn);\n        return this;\n    }\n});\n", "\nimport Stopable from './stopable.js';\nconst assign = Object.assign;\n\n/*\nProducer\n*/\n\nexport function stop(stream) {\n    // Call done functions (in stream order - is this the best order, or would reverse order be better?)\n    Stopable.prototype.stop.apply(stream);\n\n    let n = -1;\n    let output;\n    while (output = stream[++n]) {\n        stream[n] = undefined;\n        stop(output);\n    }\n}\n\nexport default function Producer() {}\n\nassign(Producer.prototype, {\n    pipe: function(stream) {\n        this[0] = stream;\n    },\n\n    stop: function() {\n        stop(this[0]);\n    }\n});\n", "\n/**\nisIterable(value)\n**/\n\nexport default function isIterable(object) {\n    return object && object[Symbol.iterator];\n}\n", "\nimport Producer from './producer.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\n\n/*\nBufferProducer\n*/\n\nexport default function BufferProducer(buffer) {\n    this.buffer = buffer;\n}\n\nassign(BufferProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        this[0] = stream;\n        while(this.buffer.length) {\n            stream.push(A.shift.apply(this.buffer));\n        }\n    }\n});\n", "\nimport nothing  from '../nothing.js';\nimport Producer from './producer.js';\n\nconst assign = Object.assign;\n\n\n/*\nPromiseProducer()\n*/\n\nexport default function PromiseProducer(promise) {\n    this.promise = promise;\n}\n\nassign(PromiseProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        const promise = this.promise;\n\n        this[0] = stream;\n\n        promise\n        .then((value) => this[0].push(value))\n        .finally((value) => this.stop());\n    },\n\n    stop: function() {\n        Producer.prototype.stop.apply(this, arguments);\n\n        // Make sure any remaining signals from the promise are not transmitted\n        // to output.\n        this[0] = nothing;\n    }\n});\n", "\nimport isIterable      from '../is-iterable.js';\nimport Stopable        from './stopable.js';\nimport { stop }        from './producer.js';\nimport BufferProducer  from './buffer-producer.js';\nimport PromiseProducer from './promise-producer.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\n\n\n/* Stream */\n\nfunction push(stream, value) {\n    if (value !== undefined) {\n        stream[0].push(value);\n    }\n}\n\nfunction unpipe(stream, output) {\n    // Support broadcast streams: streams with more than 1 output. Remove output\n    // from outputs then send stop signal to output and all its descendants.\n    if (stream[1]) {\n        let n = -1;\n        while (stream[++n] && stream[n] !== output);\n        while (stream[n++]) { stream[n - 1] = stream[n]; }\n        stop(output);\n    }\n\n    // Otherwise keep going back up the chain looking for a point to launch\n    // stop signal.\n    else {\n        stream.stop();\n    }\n}\n\nexport default function Stream(producer) {\n    this.input = producer;\n}\n\nassign(Stream, {\n    /**\n    Stream.of(value1, value2, ...)\n    Creates a buffer stream from parameters.\n    **/\n    of: function() {\n        return new Stream(new BufferProducer(arguments));\n    },\n\n    /**\n    Stream.from(source)\n    Creates a stream from a `source`, which may be an array (or array-like),\n    a promise, or a producer.\n    **/\n    from: function(source) {\n            // Source is a stream or producer\n        return source.pipe ? new Stream(source) :\n            // Source is a promise\n            source.then ? new Stream(new PromiseProducer(source)) :\n            // Source is an array-like\n            new Stream(new BufferProducer(source));\n    }\n});\n\nassign(Stream.prototype, Stopable.prototype, {\n    /**\n    .push(value)\n    Pushes `value` into the stream. If the stream has not been started or is\n    already stopped this will cause an error.\n    **/\n    push: function(value) {\n        if (window.DEBUG && !this[0]) {\n            throw new Error('Stream: attempt to .push() to a stopped stream (has a producer not been stopped correctly?)');\n        }\n\n        push(this, value);\n    },\n\n    /**\n    .pipe(stream)\n    Starts a stream and pushes its values into `stream`. Returns `stream`.\n    **/\n    pipe: function(output) {\n        if (this[0]) {\n            throw new Error('Stream: Attempt to .pipe() a unicast stream multiple times. Create a multicast stream with stream.broadcast().');\n        }\n\n        this[0] = output;\n        this.input.pipe(this);\n        return output;\n    },\n\n    /**\n    .map(fn)\n    Maps each value in the stream to `fn(value)`. Resulting values that are not\n    `undefined` are pushed downstream.\n    **/\n    map: function(fn) {\n        return new Map(this, fn);\n    },\n\n    /**\n    .filter(fn)\n    Filters out values from the stream where `fn(value)` is falsy.\n    **/\n    filter: function(fn) {\n        return new Filter(this, fn);\n    },\n\n    /**\n    .flatMap(fn)\n    **/\n    flatMap: function(fn) {\n        return new FlatMap(this, fn);\n    },\n\n    /**\n    .take(n)\n    Returns a stream of the first `n` values of the stream.\n    **/\n    take: function(n) {\n        return new Take(this, n);\n    },\n\n    /**\n    .each(fn)\n    Starts the stream and calls `fn(value)` for each value in it.\n    Returns the stream.\n    **/\n    each: function(fn) {\n        return new Each(this, fn);\n    },\n\n    /**\n    .reduce(fn, initial)\n    Consumes the stream. TODO: Not sure what to return old boy.\n    **/\n    reduce: function(fn, initial) {\n        return new Reduce(this, fn, initial);\n    },\n\n    /**\n    .scan(fn, initial)\n    Calls `fn(current, value)` for each `value` in the stream. Where `fn`\n    returns a value it is pushed downstream, and `current` assumes that value\n    on the next iteration. Where `fn` returns `undefined` nothing is pushed and\n    `current` remains unchanged.\n    **/\n    scan: function(fn, initial) {\n        return new Scan(this, fn, initial);\n    },\n\n    /**\n    .stop()\n    Stops the stream.\n    **/\n    stop: function() {\n        // We send to unpipe() to support broadcast streams, a unicast stream\n        // at input only requires this.input.stop()\n        unpipe(this.input, this);\n        return this;\n    }\n\n    /**\n    .done(fn)\n    Cues `fn` to be called when the stream is stopped.\n    **/\n});\n\n\n/* Map */\n\nfunction Map(input, fn) {\n    this.input = input;\n    this.fn    = fn;\n}\n\nMap.prototype = assign(create(Stream.prototype), {\n    push: function map(value) {\n        const fn = this.fn;\n        push(this, fn(value));\n    }\n});\n\n\n/* Filter */\n\nfunction Filter(input, fn) {\n    this.input = input;\n    this.fn    = fn;\n}\n\nFilter.prototype = assign(create(Stream.prototype), {\n    push: function filter(value) {\n        const fn = this.fn;\n        const is = fn(value);\n        is && push(this, value);\n    }\n});\n\n\n/* FlatMap */\n\nfunction FlatMap(input, fn) {\n    this.input = input;\n    this.fn    = fn;\n}\n\nFlatMap.prototype = assign(create(Stream.prototype), {\n    push: function flatMap(value) {\n        const fn     = this.fn;\n        const values = fn(value);\n\n        if (values !== undefined) {\n            if (isIterable(values)) {\n                for (const value of values) {\n                    push(this, value);\n                }\n            }\n            else {\n                // Todo: support flattening of streams. Should streams by made\n                // iterable? CAN streams be made iterable? They'd have to be async?\n                throw new Error('Stream: Cannot .flatMap() non-iterable values');\n            }\n        }\n    }\n});\n\n\n/* Take */\n\nfunction Take(input, n) {\n    if (window.DEBUG && (typeof n !== 'number' || n < 1)) {\n        throw new Error('Stream: .take() only accepts non-zero positive integers (' + n + ')');\n    }\n\n    this.input = input;\n    this.count = n;\n}\n\nTake.prototype = assign(create(Stream.prototype), {\n    push: function take(value) {\n        this[0].push(value);\n        if (!(--this.count)) {\n            this.stop();\n        }\n    }\n});\n\n\n/*\nReduce\n*/\n\nfunction Reduce(input, fn, accumulator) {\n    this.input = input;\n    this.fn    = fn;\n    this.value = accumulator;\n}\n\nReduce.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value);\n    }\n});\n\n\n/* Scan */\n\nfunction Scan(input, fn, accumulator) {\n    this.input = input;\n    this.fn    = fn;\n    this.value = accumulator;\n}\n\nScan.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value);\n        this[0].push(this.value);\n    }\n});\n\n\n/* Each */\n\nfunction Each(input, fn) {\n    this.input = input;\n    this.push  = fn;\n\n    // Start pulling values\n    input.pipe(this);\n}\n\nEach.prototype = assign(create(Stream.prototype), {\n    each: null,\n    pipe: null\n});\n", "\nimport nothing from '../nothing.js';\nimport Stream  from './stream.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\n\n\n/*\nBroadcast(producer, options)\nA Broadcast stream may be piped to multiple outputs. The options object has\nthe optional properties:\n\n```js\n{\n    // Remember and send the latest value to new pipes\n    memory: true,\n\n    // Start the stream immediately and keep it alive after all pipes are stopped\n    live:   true\n}\n```\n*/\n\nexport default function Broadcast(producer, options) {\n    Stream.apply(this, arguments);\n\n    // Mark this stream as a memory stream\n    this.memory = !!(options && options.memory);\n\n    // Open the stream immediately and keep it live even without outputs by\n    // sending output 0 to nothing. It can now only be stopped by explicitly\n    // calling .stop() on it, and not by stopping child streams.\n    if (options && options.live) {\n        this.pipe(nothing);\n    }\n}\n\nBroadcast.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        if (value !== undefined) {\n            // If this is a memory stream keep value\n            if (this.memory) {\n                this.value = value;\n            }\n\n            let n = -1;\n            while (this[++n]) {\n                this[n].push(value);\n            }\n        }\n    },\n\n    pipe: function(output) {\n        let n = -1;\n        while (this[++n]);\n        this[n] = output;\n\n        // If this is a memory stream, ie has value already\n        if (this.value !== undefined) {\n            output.push(this.value);\n        }\n\n        if (n === 0) {\n            this.input.pipe(this);\n        }\n\n        return output;\n    }\n});\n", "\nimport Producer from './producer.js';\n\nconst assign = Object.assign;\nconst keys   = Object.keys;\n\n/*\nCombineProducer\n*/\n\nfunction push(producer, name, value) {\n    const values = producer.values;\n    const names  = producer.names;\n    const stream = producer[0];\n\n    values[name] = value;\n\n    if (producer.active || (producer.active = keys(values).length === names.length)) {\n        stream.push(assign({}, values));\n    }\n}\n\nexport default function CombineProducer(sources) {\n    this.sources = sources;\n}\n\nassign(CombineProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        const sources = this.sources;\n\n        this.values = {};\n        this.names  = keys(sources);\n        this.active = false;\n        this[0]     = stream;\n\n        for (const name in sources) {\n            const source = sources[name];\n\n            if (source.each) {\n                stream.done(source.each((value) => push(this, name, value)));\n            }\n            else if (source.then) {\n                source.then((value) => push(this, name, value));\n                //.finally((value) => stop(this[0]));\n            }\n            else {\n                console.log('Todo: combine() raw values ?');\n            }\n        }\n    }\n});\n", "\nimport Producer from './producer.js';\n\nconst assign = Object.assign;\n\n/*\nMergeProducer\n*/\n\nexport default function MergeProducer(inputs) {\n    this.inputs = inputs;\n}\n\nassign(MergeProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        const inputs = this.inputs;\n\n        this[0] = stream;\n\n        let i = -1;\n        let input;\n        while (input = inputs[++i]) {\n            // Input is a stream\n            if (input.each) {\n                input.pipe(stream);\n            }\n\n            // Input is a promise\n            else if (input.then) {\n                input\n                .then((value) => stream.push(value));\n                //.finally((value) => stop(this[0]));\n            }\n\n            // Input is an array-like\n            else {\n                let n = -1;\n                while (++n < input.length) {\n                    stream.push(input[n]);\n                }\n            }\n        }\n    }\n});\n", "\nimport Producer from './producer.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\n\n/*\nZipProducer\n*/\n\nfunction hasLength(buffer) {\n    return buffer.length > 0;\n}\n\nfunction toObject(object, buffer, i) {\n    object[i] = buffer.shift();\n    return object;\n}\n\nfunction makeArray(object) {\n    return [];\n}\n\nfunction fillBuffer(controller, buffers, buffer, value) {\n    buffer.push(value);\n    if (buffers.every(hasLength)) {\n        controller.push(buffers.reduce(toObject, {}));\n    }\n}\n\n\nexport default function ZipProducer(inputs) {\n    this.inputs  = inputs;\n    this.buffers = A.map.call(inputs, makeArray);\n}\n\nassign(ZipProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        const inputs  = this.inputs;\n        const buffers = this.buffers;\n\n        this[0] = stream;\n\n        A.forEach.call(inputs, (input, i) => {\n            const buffer = buffers[i];\n\n            // Support streams\n            if (input.each) {\n                // Stop stream when controller stops - we wrap stream.each like\n                // this because stream may be a broadcaster and we don't want to\n                // stop that.\n                stream.done(\n                    input.each((value) => fillBuffer(stream, buffers, buffer, value))\n                );\n            }\n            // Support promises\n            else if (input.then) {\n                input.then((value) => fillBuffer(stream, buffers, buffer, value));\n            }\n            // Support array-likes\n            else {\n                A.forEach.call(input, (value) => fillBuffer(stream, buffers, buffer, value));\n            }\n        });\n    }\n});\n", "\nimport nothing         from './nothing.js';\n\nimport Stream          from './stream/stream.js';\nimport Broadcast       from './stream/broadcast.js';\nimport BufferProducer  from './stream/buffer-producer.js';\nimport CombineProducer from './stream/combine-producer.js';\nimport MergeProducer   from './stream/merge-producer.js';\nimport ZipProducer     from './stream/zip-producer.js';\n\nconst assign = Object.assign;\n\nexport default assign(Stream, {\n    /**\n    Stream.broadcast(options)\n    Returns a pushable broadcast stream. Methods called on this stream each\n    create a new stream.\n    **/\n    broadcast: function broadcast(options) {\n        return new Broadcast(new BufferProducer(nothing), options);\n    },\n\n    /**\n    Stream.combine(streams)\n    Creates a stream by combining the latest values of all input streams into\n    an objects containing those values. A new object is emitted when a new value\n    is pushed to any input stream.\n    **/\n    combine: function combine(streams) {\n        return new Stream(new CombineProducer(streams));\n    },\n\n    /**\n    Stream.merge(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream.\n    **/\n    merge: function() {\n        return new Stream(new MergeProducer(arguments));\n    },\n\n    /**\n    Stream.zip(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream.\n    **/\n    zip: function() {\n        return new Stream(new ZipProducer(arguments));\n    }\n});\n\nassign(Stream.prototype, {\n    /**\n    .broadcast(options)\n    Returns a broadcast stream. Methods called on this stream each create new\n    child streams. The first time a consumer is attached to one of these streams\n    the broadcast stream is piped, and the last consumer to be stopped stops the\n    broadcast stream.\n\n    A broadcast stream may have memory, where newly created consumers\n    immediately receive the latest value of the broadcaster when attached\n    (assuming that value is not `undefined`):\n\n    ```js\n    const broadcaster = stream.broadcast({ memory: true });\n    ```\n    **/\n    broadcast: function(options) {\n        return new Broadcast(this, options);\n    }\n});\n\n\n// Debug\n\nif (window.DEBUG) {\n    window.Stream = Stream;\n}\n\n", "\nimport Producer from '../modules/stream/producer.js';\nimport Stream   from '../modules/stream.js';\n\nimport { isMuteable, getTarget, getTrap } from './observer.js';\n\nconst assign = Object.assign;\nconst rkey   = /(^\\.?|\\.)\\s*([\\w-]*)\\s*/g;\n\n\nfunction push(value) {\n    this.producer.push(value);\n}\n\nfunction PathObserver(path, index, target, producer) {\n    if (window.DEBUG && !path.length) {\n        throw new SyntaxError('observe() path is empty');\n    }\n\n    // Parse path\n    rkey.lastIndex = index;\n    const p = rkey.exec(path);\n\n    // Check that path is valid\n    if (window.DEBUG && !p) {\n        throw new SyntaxError('observe() path \"' + path + '\" cannot be parsed at \"' + path.slice(index) + '\"');\n    }\n\n    // Check that if there is no key we are being instructed to observe all\n    // mutations via a '.' at the end of path - should not happen\n    if (window.DEBUG && !p[2] && p[1] !== '.') {\n        throw new SyntaxError('observe() path \"' + path + '\" must end with \".\"');\n    }\n\n    this.path     = path;\n    this.target   = target;\n    this.producer = producer;\n    this.key      = p[2] || p[1];\n    this.index    = rkey.lastIndex;\n    this.isMuteableObserver = this.path.slice(this.index) === '.';\n\n    // Are we at the end of the path? .push() can go straight to the producer.\n    if (this.index >= this.path.length) {\n        this.push = push;\n    }\n\n    // Bind observer to proxy\n    this.listen();\n    this.push(this.key === '.' ? this.target : this.target[this.key]);\n}\n\nassign(PathObserver.prototype, {\n    push: function(value) {\n        // We already know that we are not at path end here, as this.push is\n        // replaced with a consumer at path end (in the constructor).\n\n        // If the value is not muteable according to observer, we have no\n        // business observing it\n        if (!isMuteable(value)) {\n            if (this.child) {\n                this.child.stop();\n                this.child = undefined;\n            }\n\n            // We are not at path end, and have just received an object that\n            // cannot have observable deep properties. If we are observing a\n            // muteable at path end ('.'), push it, otherwise undefined.\n            // Todo: make it so PathObserver can jump into immutable objects?\n            this.producer.push(this.isMuteableObserver ? value : undefined);\n        }\n        else if (this.child) {\n            this.child.relisten(value);\n        }\n        else {\n            this.child = new PathObserver(this.path, this.index, value, this.producer);\n        }\n    },\n\n    listen: function() {\n        const trap = getTrap(this.target);\n\n        if (trap) {\n            trap.listen(this.key === '.' ? null : this.key, this);\n        }\n        else {\n            if (window.DEBUG) {\n                console.log('observe() cannot get trap of ', this.target);\n            }\n        }\n    },\n\n    unlisten: function() {\n        getTrap(this.target).unlisten(this.key === '.' ? null : this.key, this);\n    },\n\n    relisten: function(target) {\n        this.unlisten();\n        this.target = target;\n        this.listen();\n        this.push(this.target[this.key]);\n    },\n\n    stop: function() {\n        this.unlisten();\n        this.child && this.child.stop();\n        this.child = undefined;\n    }\n});\n\n\n/**\nPathProducer(path, target, currentValue)\n**/\n\nfunction pushAllowUndefined(stream, value) {\n    // Stream.push rejects undefined, but for this stream we want to allow\n    // undefined. We could do this with Stream(..., options). We could. Let's\n    // override .push() for the moment.\n    stream[0].push(value);\n}\n\nfunction PathProducer(path, target, value) {\n    this.path   = path;\n    this.target = target;\n    this.value  = value;\n}\n\nassign(PathProducer.prototype, Producer.prototype, {\n    push: function(value) {\n        // Deduplicate values\n        if (this.value === value) {\n            // If this is a mutation observer (path ends with '.') inspect\n            // values: we want to allow muteable objects to pass through\n            if (!this.isMutationProducer) { return; }\n            if (!isMuteable(value)) { return; }\n        }\n\n        this.value = value;\n        pushAllowUndefined(this[0], value);\n    },\n\n    pipe: function(stream) {\n        this[0] = stream;\n        this.pathObserver = new PathObserver(this.path, 0, this.target, this);\n\n        // This flag is set here so that `initial` value *is* deduplicated\n        // but subsequent mutations are *not*.\n        this.isMutationProducer = this.path[this.path.length - 1] === '.';\n    },\n\n    stop: function() {\n        this.pathObserver.stop();\n        Producer.prototype.stop.apply(this, arguments);\n    }\n});\n\n\n/**\nobserve(path, object [, initial])\nReturns a stream of values of `path` in `object`. A new value is emitted every\ntime any of the objects in `path` mutates to result in a new value at the end of\n`path`. An initial value is emitted (synchronously) when the value at `path`\nis not equal to `initial`.\n**/\n\nexport default function observe(path, object, initial) {\n    const target = getTarget(object);\n    const value  = getTarget(initial);\n    return new Stream(new PathProducer(path, target, value));\n}\n", "\n/**\nTemplate functions\n\nThe scope of literal templates contains a small library of functions. Some are\nsimply JS built-ins aliased for brevity. Others provide template includes,\nrouting and value transformations.\n\n**/\n\nimport id              from '../../fn/modules/id.js';\nimport by              from '../../fn/modules/by.js';\nimport capture         from '../../fn/modules/capture.js';\nimport equals          from '../../fn/modules/equals.js';\nimport matches         from '../../fn/modules/matches.js';\nimport nothing         from '../../fn/modules/nothing.js';\nimport get             from '../../fn/modules/get-path.js';\nimport noop            from '../../fn/modules/noop.js';\nimport slugify         from '../../fn/modules/slugify.js';\nimport last            from '../../fn/modules/last.js';\nimport overload        from '../../fn/modules/overload.js';\nimport { px, em, rem, vw, vh } from '../../dom/modules/parse-length.js';\nimport { Observer, notify }    from '../../fn/observer/observer.js';\nimport observe         from '../../fn/observer/observe.js';\nimport Stream          from '../../fn/modules/stream.js';\nimport print           from '../library/print.js';\n\nconst assign  = Object.assign;\nconst entries = Object.entries;\n\nconst library = {\n    /** assign(a, b, ...)\n    Alias of `Object.assign()`.\n    **/\n    assign: assign,\n\n    /** by(fn, a, b)\n    Compares `fn(a)` against `fn(b)` and returns `-1`, `0` or `1`. Partially\n    applicable and intended for use in `array.sort()`. For example, to sort an\n    array of objects by their ids:\n\n    ```\n    array.sort(by(get('id')))\n    ```\n    **/\n    by,\n\n    /**\n    capture()\n    **/\n    capture: capture,\n\n    /** ceil(n)\n    Alias of `Math.ceil()`.\n    **/\n    ceil: Math.ceil,\n\n    /** define()\n    Alias of `Object.defineProperties()`.\n    **/\n    define: Object.defineProperties,\n\n    /** entries(object)\n    Alias of `Object.entries()`.\n    **/\n    entries: entries,\n\n    /** equals(a, b)\n    Compares `a` and `b` for deep equality and returns `true` or `false`.\n    **/\n    equals,\n\n    /** floor(n)\n    Alias of `Math.floor()`.\n    **/\n    floor: Math.floor,\n\n    /** get(path, object)\n    Gets the value of `path` in `object`, where `path` is a string in JS\n    dot-notation. Where a path does not lead to a value, returns `undefined`:\n\n    ```\n    get('path.to.value', {})       // undefined\n    ```\n\n    Numbers are accepted as path components:\n\n    ```\n    get('array.0', {\n        array: ['first', 'second']\n    })                             // 'first'\n    ```\n    **/\n    get,\n\n    /** id(object)\n    Returns `object`.\n    **/\n    id,\n\n    /** keys(object)\n    Alias of `Object.keys()`.\n    **/\n    keys: Object.keys,\n\n    /** last()\n    Gets the last item from an array or array-like.\n    **/\n    last,\n\n    /** matches(selector, object)\n    Returns true where all the properties of `selector` are strictly equal to the\n    same properties of `object`.\n    **/\n    matches,\n\n    /** noop()\n    Return undefined.\n    **/\n    noop,\n\n    /*\n    nothing\n    A frozen array representing no value.\n    */\n    //nothing,\n\n    /** notify(path, object)\n    Force observer to register a mutation at `path` of `object`.\n    **/\n    notify,\n\n    /** observe(path, object)\n    Returns an observable of mutations to `path` in `object`. Consume mutations\n    with an observable's `.each()` method.\n\n    ```js\n    const observable = observe('title', data).each((title) => console.log(title));\n    ```\n\n    Observables may be stopped with the method `.stop()`:\n\n    ```js\n    observable.stop();\n    ```\n\n    Renderers (which are exposed as `this` inside templates), have a `.done()`\n    method that calls a subscriber's `.stop()` method when the render is\n    stopped. This pattern observes `data.title` until the next render:\n\n    ```js\n    this.done(observe('title', data).each((title) => console.log(title)));\n    ```\n    **/\n    observe,\n\n    /* Observer(object)\n    Returns the Observer proxy of `object`. Use this proxy to make changes to\n    an object that may be observed using `observe(path, object)` (above).\n    */\n    Observer,\n\n    /* overload(fn, object) */\n    overload,\n\n    print: window.DEBUG ? print : noop,\n\n    /** rect(node)\n    **/\n    //rect,\n\n    /** round(n)\n    Alias of `Math.round()`;\n    **/\n    round: Math.round,\n\n    /**\n    paramify(object)\n    Turns an object with enumerable properties into a (native) URL search\n    parameters object, rejecting undefined properties and flattening out\n    array values.\n    **/\n    paramify: function(object) {\n        // If this is an object with properties that may be arrays, flatten it\n        // out into entries\n        const params = typeof object === 'object' && typeof object.length !== 'number' ?\n            entries(object).flatMap((entry) => (\n                entry[1] === undefined ? nothing :\n                entry[1] && typeof entry[1] === 'object' && entry[1].map ? entry[1].map((value) => [entry[0], value]) :\n                [entry]\n            )) :\n            object ;\n\n        //console.log('PARAMIFY', object, params);\n        return new URLSearchParams(params);\n    },\n\n    /** slugify(string)\n    Returns the slug of `string`.\n    **/\n    slugify,\n\n    /** Stream(fn)\n    Returns a stream of values.\n    **/\n    Stream,\n\n    /**\n    translate()\n    **/\n    translate: function(key) {\n        return window.translations && window.translations[key] || key;\n    },\n\n    /** values()\n    Alias of `Object.values()`.\n    **/\n    values: Object.values,\n\n    px,\n    em,\n    rem,\n    vw,\n    vh,\n\n    /* Deprecate errors */\n    combine: function() {\n        throw new Error('combine() is now Stream.combine()');\n    },\n\n    merge : function() {\n        throw new Error('merge() is now Stream.merge()');\n    },\n\n    zip: function() {\n        throw new Error('zip() is now Stream.zip()');\n    }\n};\n\nexport default library;\n\nexport function register(name, fn) {\n    if (library[name]) {\n        throw new Error('Literal: function \"' + name + '\" already registered');\n    }\n\n    library[name] = fn;\n\n    // Allow registered fns to be exported directly from their modules via\n    // `export default register(name, fn);` by returning `fn`.\n    return fn;\n}\n", "\n/**\nget(name, object)\nGet property `name` of `object`.\n*/\n\nimport curry from './curry.js';\n\nexport function get(key, object) {\n    // Todo? Support WeakMaps and Maps and other map-like objects with a\n    // get method - but not by detecting the get method\n    return object[key];\n}\n\nexport default curry(get, true);\n", "\n/** \ncompile(scope, paramString, code, context)\n\nCompiles a new function from `code` that runs in `scope` with the arguments \nlisted in `paramString`. If a `context` is passed in, you get an arrow function,\notherwise a normal function (leaving you the possibility to set the context at \nruntime with `fn.apply(context, params)`).\n**/\n\nimport get from './get.js';\n\nfunction isValidConst(namevalue) {\n    const name = namevalue[0];\n    return /^\\w/.test(name);\n}\n\nexport default function compile(scope = {}, paramString, code, context) {\n    const entries = Object.entries(scope).filter(isValidConst);\n    const keys    = entries.map(get(0));\n    const values  = entries.map(get(1));\n\n    return context ?\n        // The arrow function has it's context set\n        new Function(...keys, 'return (' + paramString + ') => {' + (code || '') + '}')\n        .apply(context, values) :\n        // This function can be called with a context fn.call(context, data)\n        new Function(...keys, 'return function(' + paramString + '){' + (code || '') + '}')\n        .apply(null, values) ;\n}\n", "\nexport default {\n    Totals: {\n        template:  0,\n        text:      0,\n        attribute: 0,\n        boolean:   0,\n        class:     0,\n        checked:   0,\n        value:     0\n    }\n};\n\nexport const meta = {\n    count: 0\n};\n", "\nimport compileFn from '../../fn/modules/compile.js';\nimport analytics from '../renderers/analytics.js';\n\nif (window.DEBUG) {\n    analytics.totalCompileTime = 0;\n}\n\n/**\ncompile(scope, params, source, id, info, element)\nCompiles a literal template to a function.\n**/\n\nconst indent = '  ';\n\n// Store render functions against their source\nexport const cache = {};\n\n// Last two params, info and element, are purely for debug messages\nexport default function compile(scope, params, source, id, info, element) {\n    if (typeof source !== 'string') {\n        throw new Error('Template is not a string');\n    }\n\n    const key = id || source;\n\n    // Return cached fn\n    if (cache[key]) { return cache[key]; }\n\n    const code = '\\n'\n        + (id ? indent + '// Template #' + id + '\\n' : '')\n        + indent + 'return this.compose`' + source + '`;\\n';\n\n    if (window.DEBUG) {\n        try {\n            const text = source.trim();\n            const name = text.length > 32 ?\n                text.slice(0, 30).replace(/\\s+/g, ' ').replace(/\"/g, '\\\\\"') + ' …' :\n                text.replace(/\\s+/g, ' ').replace(/\"/g, '\\\\\"') ;\n\n            const t0 = window.performance.now();\n            cache[key] = compileFn(scope, params,\n                'try {' + code + '} catch(e) {' +\n                // Append useful info to error message\n                indent + 'e.message += \" in template #\" + this.template + (this.element && this.element.tagName ? \", <\" + this.element.tagName.toLowerCase() + (this.name ? \" \" + this.name + \"=\\\\\"' + name + '\\\\\">\" : \"> ' + name + '\") : \"\");' +\n                indent + 'throw e;' +\n                '}'\n            );\n\n            const t1 = window.performance.now();\n            analytics.totalCompileTime += (t1 - t0);\n\n            // timeEnd(name);\n            return cache[key];\n        }\n        catch(e) {\n            // Append useful info to error message\n            if (info) {\n                e.message += ' in template #' + info.template + (element && element.tagName ? ', <' + element.tagName.toLowerCase() + (info.name ? ' ' + info.name + '=\"' + source + '\">' : '>') : '') ;\n            }\n            throw e;\n        }\n    }\n\n    return cache[key] = compileFn(scope, params, code);\n}\n", "\n/** \nTemplate tags\n\nLiteral template tags can contain any valid JavaScript expression. The renderer\ndecides how to render the evaluated output of each tag based on its type and \nconstructor. Where an expression evaluates to a promise, the promise resolves \nbefore being rendered.\n\n<table class=\"striped-table x-bleed\">\n    <thead>\n        <tr>\n            <th style=\"width:20%;\">Type</th>\n            <th>Expression</th>\n            <th style=\"width:30%;\">Rendered as</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>undefined</th>\n            <th><code>${ undefined }</code></th>\n            <td>\n                <template id=\"value-undefined\">${ undefined }</template>\n                <include-literal src=\"#value-undefined\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>null</th>\n            <th><code>${ null }</code></th>\n            <td>\n                <template id=\"value-null\">${ null }</template>\n                <include-literal src=\"#value-null\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>NaN</th>\n            <th><code>${ NaN }</code></th>\n            <td>\n                <template id=\"value-nan\">${ NaN }</template>\n                <include-literal src=\"#value-nan\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>String</th>\n            <th><code>${ 'Hello' }</code></th>\n            <td>\n                <template id=\"value-string\">${ 'Hello' }</template>\n                <include-literal src=\"#value-string\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>Number</th>\n            <th><code>${ 100.3 }</code></th>\n            <td>\n                <template id=\"value-number\">${ 100.3 }</template>\n                <include-literal src=\"#value-number\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>Infinity</th>\n            <th><code>${ Infinity }, ${ -Infinity }</code></th>\n            <td>\n                <template id=\"value-infinity\">${ Infinity }, ${ -Infinity }</template>\n                <include-literal src=\"#value-infinity\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>Function</th>\n            <th><code>${ function name(param) {} }</code></th>\n            <td>\n                <template id=\"value-function\">${ function name(param) {} }</template>\n                <include-literal src=\"#value-function\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>Arrow</th>\n            <th><code>${ (param) => {} }</code></th>\n            <td>\n                <template id=\"value-arrow\">${ (param) => {} }</template>\n                <include-literal src=\"#value-arrow\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>RegExp</th>\n            <th><code>${ /^regexp/ }</code></th>\n            <td>\n                <template id=\"value-regexp\">${ /^regexp/ }</template>\n                <include-literal src=\"#value-regexp\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>Symbol</th>\n            <th><code>${ Symbol('name') }</code></th>\n            <td>\n                <template id=\"value-symbol\">${ Symbol('name') }</template>\n                <include-literal src=\"#value-symbol\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>Array</th>\n            <th><code>${ [0, 1, 2, 3] }</code></th>\n            <td>\n                <template id=\"value-array\">${ [0, 1, 2, 3] }</template>\n                <include-literal src=\"#value-array\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>Object</th>\n            <th><code>${ { property: 'value' } }</code></th>\n            <td>\n                <template id=\"value-object\">${ { property: 'value' } }</template>\n                <include-literal src=\"#value-object\"></include-literal>\n            </td>\n        </tr>\n        <tr>\n            <th>Node</th>\n            <th><code>${ document.createTextNode('Text') }</code></th>\n            <td>\n                <template id=\"value-node\">${ document.createTextNode('Text') }</template>\n                <include-literal src=\"#value-node\"></include-literal>\n            </td>\n        </tr>\n    </tbody>\n</table>\n**/\n\nimport id       from '../../fn/modules/id.js';\nimport overload from '../../fn/modules/overload.js';\nimport toType   from '../../fn/modules/to-type.js';\n\n// Matches the arguments list in the result of fn.toString()\nconst rarrowents = /\\s*(\\([\\w,\\s]*\\))/;\nconst rarguments = /function(?:\\s+\\w+)?\\s*(\\([\\w,\\s]*\\))/;\n\nexport default overload(toType, {\n    /** \n    \n    **/\n    'boolean': (value) => value + '',\n\n    // Print function and parameters\n    'function': (value) => (\n        value.prototype ?\n            (value.name || 'function') + (rarguments.exec(value.toString()) || [])[1] :\n            (rarrowents.exec(value.toString()) || [])[1] + ' ⇒ {…}'\n    ),\n\n    // Convert NaN to empty string and Infinity to ∞ symbol\n    'number': (value) => (\n        Number.isNaN(value) ? '' :\n        Number.isFinite(value) ? value + '' :\n        value < 0 ? '-∞' : '∞'\n    ),\n\n    'string': id,\n\n    'symbol': (value) => value.toString(),\n\n    'undefined': (value) => '',\n\n    'object': overload((object) => (object && object.constructor.name), {\n        'RegExp':  (object) => '/' + object.source + '/',\n        'null':    () => '',\n        'default': (object) => JSON.stringify(object, null, 2)\n    }),\n\n    'default': JSON.stringify\n});\n", "/**\nremove(array, value)\nRemove `value` from `array`. Where `value` is not in `array`, does nothing.\n**/\n\nimport curry from './curry.js';\n\nexport function remove(array, value) {\n    if (array.remove) { array.remove(value); }\n\n    let i;\n    while ((i = array.indexOf(value)) !== -1) {\n        array.splice(i, 1);\n    }\n\n    // Todo: should return array so can be used as reducer. Hook up remove() in \n    // Literal > renderer.js when you do\n    return value;\n}\n\nexport default curry(remove, true);\n", "\nimport { remove } from '../../fn/modules/remove.js';\nimport Producer   from '../../fn/modules/stream/producer.js';\nimport Stream     from '../../fn/modules/stream.js';\nimport { getTrap, getTarget } from '../../fn/observer/observer.js';\n\n//const DEBUG = window.DEBUG === true;\n\nconst assign = Object.assign;\nconst values = Object.values;\n\n/**\nreads(object)\nCalls `fn` for every property of `object` read via a get operation. Returns an\nobject with the method `.stop()`.\n**/\n\nfunction stop(gets) {\n    gets.stop();\n}\n\nfunction GetProducer(target, path, root) {\n    this.children = {};\n\n    // For some reason child proxies are being set... dunno how...\n    this.target = getTarget(target);\n    this.path   = path;\n    this.root   = root;\n}\n\nassign(GetProducer.prototype, Producer.prototype, {\n    pipe: function(root) {\n        this[0] = this.root = root;\n        getTrap(this.target).gets.push(this);\n    },\n\n    listen: function(key) {\n        // We may only create one child observer per key\n        if (this.children[key]) { return; }\n        const path = this.path ? this.path + '.' : '';\n        this.children[key] = new GetProducer(this.target[key], path + key, this.root);\n    },\n\n    unlisten: function(key) {\n        // Can't unobserve the unobserved\n        if (!this.children[key]) { return; }\n        this.children[key].stop();\n        delete this.children[key];\n    },\n\n    fn: function(key) {\n        const path = this.path ? this.path + '.' : '';\n        // Pass concatenated path to parent fn\n        this.root.push(path + key);\n    },\n\n    stop: function() {\n        remove(getTrap(this.target).gets, this);\n        values(this.children).forEach(stop);\n        if (this[0]) {\n            Producer.prototype.stop.apply(this, arguments);\n        }\n    }\n});\n\nexport default function gets(observer) {\n    return new Stream(new GetProducer(observer, ''));\n}\n", "\nimport { log, group, groupCollapsed, groupEnd } from '../modules/log.js';\nimport analytics from './analytics.js';\nimport { cache as compileCache } from '../modules/compile.js';\n\nconst renderers = [];\nconst promise   = Promise.resolve(renderers);\n\nconst logs = window.DEBUG && {\n    totalCompileTime: 0,\n    totalCompileCount: 0\n};\n\nlet cued;\n\nfunction constructorCount(renderers) {\n    // Count constructors\n    return renderers\n    .map((renderer) => renderer.constructor.name)\n    .reduce((names, name) => {\n        const i = names.indexOf(name);\n        if (i === -1) { names.push(1, name); }\n        else          { ++names[i - 1]; }\n        return names;\n    }, [])\n    .reduce((string, value) => string + (\n        typeof value === 'number' ?\n            string ? ', ' + value :\n            value :\n        ' ' + value\n    ), '');\n}\n\nfunction render(renderers) {\n    var t0, ids;\n    if (window.DEBUG) {\n        t0 = window.performance.now() / 1000;\n        groupCollapsed('batch', t0.toFixed(3) + 's – cued ' + constructorCount(renderers), '#B6BD00');\n        ids = {};\n    }\n\n    var renderer, count = 0;\n    while (renderer = renderers.shift()) {\n        // Call .render() with latest arguments\n        count += renderer.render.apply(renderer, renderer.cuedArguments);\n        renderer.cuedArguments = undefined;\n        renderer.cued = false;\n        if (window.DEBUG) {\n            ids && (ids[renderer.id] = ids[renderer.id] === undefined ? 1 : ids[renderer.id] + 1);\n        }\n    }\n\n    cued = undefined;\n\n    if (window.DEBUG) {\n        const keys = Object.keys(ids);\n        const t1 = window.performance.now() / 1000;\n\n        if (logs.totalCompileTime !== analytics.totalCompileTime) {\n            logs.batchCompileTime = analytics.totalCompileTime - logs.totalCompileTime;\n            logs.totalCompileTime = analytics.totalCompileTime;\n\n            const ids      = Object.keys(compileCache);\n            const batchIds = ids.slice(logs.totalCompileCount);\n            const totalCompileCount = ids.length;\n\n            logs.batchCompileCount = totalCompileCount - logs.totalCompileCount;\n            logs.totalCompileCount = totalCompileCount;\n\n            log('compile', logs.batchCompileCount + ' literal' + (logs.batchCompileCount === 1 ? '' : 's') + ', ' + logs.batchCompileTime.toPrecision(3) + 'ms', undefined, undefined, '#DDB523');\n        }\n        else {\n            logs.batchCompileTime = 0;\n        }\n\n        log('render',\n            // renderers\n            keys.length + ' renderer' + (keys.length === 1 ? ', ' : 's, ')\n            // mutations\n            + count + ' mutation' + (count === 1 ? ', ' : 's, ')\n            // duration\n            + ((t1 - t0) * 1000 - logs.batchCompileTime).toPrecision(3) + 'ms'\n            // ids\n            + ' (#' + keys.slice(0, 12).join(', #') + (keys.length > 12 ? ', ...)' : ')'),\n            //\n            '', '', 'orange'\n        );\n\n        if (Object.values(ids).find((n) => n > 1)) {\n            console.warn('Literal', 'same renderer rendered multiple times in batch', ids);\n        }\n\n        groupEnd();\n\n        if (t1 - t0 > 0.016) {\n            log('render took longer than a frame (16.7ms) ' + ((t1 - t0) * 1000).toPrecision(3) + 'ms', '', '', '', '#ba4029');\n        }\n    }\n}\n\n/**\ncue(renderer, args)\nCues a renderer to be rendered in the next batch with latest args. If the\nrenderer is already cued, args are replaced with latest args.\n**/\n\nexport function cue(renderer, args) {\n    renderer.cuedArguments = args;\n\n    // Ignore if renderer is already cued\n    if (renderer.cued) {\n        return promise;\n    }\n\n    // Create a new batch end promise where required\n    if (!cued) {\n        cued = promise.then(render);\n    }\n\n    renderers.push(renderer);\n    renderer.cued = true;\n    return cued;\n}\n\n/**\nuncue(renderer)\nRemoves renderer from the render queue.\n**/\n\nexport function uncue(renderer) {\n    if (!renderers.length) { return; }\n    if (!renderer.cued) { return; }\n\n    const i = renderers.indexOf(renderer);\n    if (i > 0) { renderers.splice(i, 1); }\n    renderer.cuedArguments = undefined;\n    renderer.cued = false;\n}\n", "\nimport getPath        from '../../fn/modules/get-path.js';\nimport nothing        from '../../fn/modules/nothing.js';\nimport { Observer, getTarget } from '../../fn/observer/observer.js';\nimport observe        from '../../fn/observer/observe.js';\nimport toText         from '../modules/to-text.js';\nimport gets           from '../modules/gets.js';\nimport { cue, uncue } from './batcher.js';\nimport { meta }       from './analytics.js';\n\n\nconst assign = Object.assign;\nconst keys   = Object.keys;\n\nconst isPromise = (object) => (object\n    && typeof object === 'object'\n    && object.then);\n\nconst reduce = (values) => values.reduce((output, value) => (\n    // Ignore undefined and empty strings\n    value === '' || value === undefined ?\n        output :\n        output + value\n));\n\n\nfunction stringify(value, string, render) {\n    return value && typeof value === 'object' ? (\n        // If expression returns a promise\n        value.then ?\n            value.then((value) => (\n                string === '' ?\n                    value :\n                    string + value\n            )) :\n        // If expression returns an array with promises\n        value.find ?\n            value.find(isPromise) ?\n                // Resolve promises and join to string\n                Promise\n                .all(value)\n                .then((strings) => (\n                    string === '' ?\n                        reduce(strings.map(render)) :\n                        string + reduce(strings.map(render))\n                )) :\n            // Otherwise join to string immediately\n            string === '' ?\n                reduce(value.map(render)) :\n                string + reduce(value.map(render)) :\n        // pass any other value to render\n        string === '' ?\n            render(value) :\n            string + render(value)\n    ) :\n    string === '' ?\n        render(value) :\n        string + render(value) ;\n}\n\nexport function renderString(values) {\n    const strings = values[0];\n    return reduce(strings.map((string, i) => (\n        i <= values.length ?\n            // Strings 0 to n - 1\n            stringify(values[i + 1], string, toText) :\n            // Final string\n            string === '' ? undefined :\n            string\n    )));\n}\n\nexport function removeNodes(first, last) {\n    // Remove last to first and all nodes in between\n    let node  = last;\n    let count = 0;\n\n    while (node && node !== first) {\n        const previous = node.previousSibling;\n        node.remove();\n        node = previous;\n        ++count;\n    }\n\n    first.remove();\n    ++count;\n\n    return count;\n}\n\n\n// States\n\n// Collection of paths is synchronous, use a singleton array\nconst paths   = [];\nconst postfix = '-fns';\n\nfunction createDistributor(status) {\n    const list = status + postfix;\n\n    return function listen(fn) {\n        // If we are already in state `name` call `fn` immediately. This assumes\n        // we cannot reenter a state and therefore all handlers are called once\n        // only.\n        if (this.status === status) {\n            fn();\n            // Distributor is designed to be used in templates, return undefined\n            // to avoid rendering anything.\n            return;\n        }\n\n        const fns = this[list] || (this[list] = []);\n        fns.push(fn);\n    };\n}\n\nfunction callReducer(method, triggerable) {\n    triggerable[method] ?\n        triggerable[method]() :\n        triggerable() ;\n\n    return method;\n}\n\nfunction triggerReducer(args, renderer) {\n    const method  = args[1];\n    const payload = args[3];\n    renderer[method] && renderer[method](payload);\n    return args;\n}\n\nexport function trigger(object, method, status, payload) {\n    if (object.status === status) { return; }\n    object.status = status;\n\n    const contents = object.contents;\n    if (contents) { contents.reduce(triggerReducer, arguments); }\n\n    const listeners = object[status + postfix];\n    if (listeners) { listeners.reduce(callReducer, method); }\n\n    //log(method, object.constructor.name +  ' #' + object.id, undefined, undefined, 'lightgrey');\n    return object;\n}\n\nexport function renderStopped() {\n    console.error('Attempted .push() to stopped renderer', this.id, '#' + this.template, this.path, this.name);\n}\n\nexport function stop(stopable) {\n    return stopable.stop ?\n        stopable.stop() :\n        stopable() ;\n}\n\n\n// Observers\n\nfunction toPaths(paths, path) {\n    // Keep paths unique\n    if (paths.includes(path)) { return; }\n\n    var prev;\n\n    // Make some attempt to remove intermediate paths traversed\n    // while getting the value at the end of the path. Warning: not 100%\n    // robust. If we want to be robust about this we need to collect gets\n    // async inside the observer, I think.\n    while(\n        (prev = paths[paths.length - 1])\n        && prev.length < path.length\n        && path.startsWith(prev)\n    ) {\n        --paths.length;\n    }\n\n    // store the path\n    paths.push(path);\n}\n\nfunction remove(paths, path) {\n    const i = paths.indexOf(path);\n\n    // Where path is in paths, remove it\n    if (i > -1) {\n        paths.splice(i, 1);\n    }\n\n    return paths;\n}\n\nfunction stopProperty(object, key) {\n    object[key].stop();\n    delete object[key];\n    return object;\n}\n\nfunction toObservables(renderer, path) {\n    const data        = renderer.data;\n    const observables = renderer.observables;\n\n    if (!observables[path]) {\n        // Don't getPath() of the observer proxy here, that really makes\n        // the machine think too hard.\n        const value = getPath(path, data);\n\n        observables[path] = observe(path, data, value)\n        .each((value) => renderer.push(data));\n    }\n\n    return renderer;\n}\n\n\n/**\nRenderer()\nBase class/mixin for providing contents with the properties\n`{ node, path }` and a generic `.push()` method.\n**/\n\nexport default function Renderer(node, options, element) {\n    this.element  = element || node;\n    this.node     = node;\n    this.path     = options.path;\n    this.id       = ++meta.count;\n    this.count    = 0;\n    this.template = options.template;\n    this.observables = {};\n}\n\nassign(Renderer.prototype, {\n    /**\n    .push(data)\n    Push data into the renderer. The renderer is now cued to render this data in\n    the next render batch.\n    **/\n    push: function(data) {\n        if (window.DEBUG && this.render === renderStopped) {\n            console.error('Attempted .push() to stopped renderer', this.id, '#' + (this.template.id || this.template), (this.path ? this.path + ' ' : '') + this.constructor.name);\n            return;\n        }\n\n        // Cue .render() to be called on the next batch\n        return cue(this, arguments);\n    },\n\n    /**\n    .render(data)\n    Renders data to the DOM. Normally you should use `.push(data)`, which cues\n    up `render(data)` in the next render batch. This method is used internally\n    when immediate rendering is desired.\n    **/\n    render: function render(object) {\n        const stops = this['stop' + postfix];\n        if (stops) {\n            stops.forEach(stop);\n            stops.length = 0;\n        }\n\n        paths.length = 0;\n\n        const data     = getTarget(object);\n        const observer = Observer(data);\n        const reads    = data ?\n            gets(data).each((path) => toPaths(paths, path)) :\n            nothing ;\n\n        // Update `this` before rendering\n        this.data = data;\n        ++this.count;\n\n        // Evaluate the template. Note that we are potentially leaving\n        // observers live here, if any data is set during render we may trigger\n        // a further render... not what we want. Do we need to pause observers?\n        const stats = this.literally(observer, this.element, this.include);\n\n        // We may only collect synchronous gets – other templates may use\n        // this data object and we don't want to include their gets by stopping\n        // any later. Stop now. If we want to change this, making a data proxy\n        // per template instance would be the way to go. We're not going there.\n        reads.stop();\n\n        // Stop unused paths\n        paths\n        // Remove paths from observables keys\n        .reduce(remove, keys(this.observables))\n        // Stop the remaining keys\n        .reduce(stopProperty, this.observables);\n\n        // Start observing any new paths\n        paths\n        //\n        .reduce(toObservables, this);\n\n        // Return information about the render\n        return stats;\n    },\n\n    /**\n    .connected(fn)\n    Calls `fn` when renderer nodes enter the DOM.\n    **/\n    connected: createDistributor('dom'),\n\n    /**\n    .connect()\n    Signals to renderer and all child renderers that they have entered the DOM.\n    **/\n    connect: function() {\n        // object, method, status, payload\n        trigger(this, 'connect', 'dom');\n    },\n\n    /**\n    .done(fn)\n    Calls `fn` when renderer is stopped.\n    **/\n    done: createDistributor('done'),\n\n    /**\n    .stop()\n    Stops renderer.\n    **/\n    stop: function() {\n        uncue(this);\n        keys(this.observables).reduce(stopProperty, this.observables);\n\n        if (window.DEBUG) {\n            this.render = renderStopped;\n        }\n\n        // object, method, status, payload\n        trigger(this, 'stop', 'done');\n        return this;\n    }\n});\n", "/**\nsetProperty(node, name, value)/\n**/\n\n// Readonly properties cannot be set, obviously. Marking them as this name\n// means AttributeRenderer does not try to set hem as properties. Crude.\nconst READONLY = 'READONLY';\n\nexport default {\n    'accept-charset': 'acceptCharset',\n    accesskey:       'accessKey',\n    cellpadding:     'cellPadding',\n    cellspacing:     'cellSpacing',\n    codebase:        'codeBase',\n    colspan:         'colSpan',\n    datetime:        'dateTime',\n    'for':           'htmlFor',    // <label>\n    form:            READONLY,\n    formaction:      'formAction', // <input>\n    formenctype:     'formEnctype',\n    formmethod:      'formMethod',\n    formnovalidate:  'formNoValidate',\n    formtarget:      'formTarget',\n    frameborder:     'frameBorder',\n    href:            READONLY,     // <use href> is readonly\n    httpequiv:       'httpEquiv',\n    longdesc:        'longDesc',\n    maxlength:       'maxLength',\n    minlength:       'minLength',\n    nohref:          'noHref',\n    noresize:        'noResize',\n    noshade:         'noShade',    // <hr>\n    nowrap:          'noWrap',\n    novalidate:      'noValidate', // <form>\n    readonly:        'readOnly',\n    rowspan:         'rowSpan',\n    tabindex:        'tabIndex',\n    tfoot:           'tFoot',\n    thead:           'tHead',\n    usemap:          'useMap',\n    valign:          'vAlign',\n    valuetype:       'valueType'    // <object>\n};\n", "\nimport library   from '../modules/library.js';\nimport compile   from '../modules/compile.js';\nimport Renderer, { renderString } from './renderer.js';\nimport names     from './property-names.js';\nimport analytics from './analytics.js';\n\nconst assign = Object.assign;\n\n/**\nAttributeRenderer()\nConstructs an object responsible for rendering to a plain text attribute.\n**/\n\nfunction setAttribute(node, name, value) {\n    const prop = names[name] || name;\n\n    // Seek and set a matching property\n    if (prop in node) {\n        if (node[prop] !== value) {\n            node[prop] = value;\n            return 1;\n        }\n    }\n\n    // If that doesn't work set the attribute\n    if (value === node.getAttribute(name)) {\n        return 0;\n    }\n\n    node.setAttribute(name, value);\n    return 1;\n}\n\nexport default function AttributeRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = options.name;\n    this.literally = options.literally || compile(library, 'data, element', options.source, null, options, this.element);\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].attribute || (analytics[id].attribute = 1);\n    ++analytics.Totals.attribute;\n}\n\nassign(AttributeRenderer.prototype, Renderer.prototype, {\n    compose: function() {\n        const value = renderString(arguments);\n        return setAttribute(this.node, this.name, value);\n    }\n});\n", "\nimport library   from '../modules/library.js';\nimport Renderer, { renderString } from './renderer.js';\nimport compile   from '../modules/compile.js';\nimport analytics from './analytics.js';\nimport names     from './property-names.js';\n\nconst assign = Object.assign;\n/**\nBooleanRenderer()\nConstructs an object responsible for rendering to a boolean attribute.\n**/\n\nexport function setBooleanProperty(node, name, value) {\n    const prop = names[name] || name;\n\n    if (prop in node) {\n        if ((!!value) === node[prop]) {\n            return 0;\n        }\n\n        node[prop] = !!value;\n    }\n    else if (value) {\n        node.setAttribute(name, name);\n    }\n    else {\n        node.removeAttribute(name);\n    }\n\n    // Return DOM mutation count\n    return 1;\n}\n\nexport default function BooleanRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = options.name;\n    this.literally = options.literally || compile(library, 'data, element', options.source, null, options, this.element);\n\n    // Remove the boolean until it is processed\n    node.removeAttribute(this.name);\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].boolean || (analytics[id].boolean = 1);\n    ++analytics.Totals.boolean;\n}\n\nassign(BooleanRenderer.prototype, Renderer.prototype, {\n    compose: function() {\n        const value = renderString(arguments);\n        return setBooleanProperty(this.node, this.name, value)\n    }\n});\n", "/**\nisDefined(value)\nCheck for value – where `value` is `undefined`, `NaN` or `null`, returns\n`false`, otherwise `true`.\n*/\n\n\nexport default function isDefined(value) {\n    // !!value is a fast out for non-zero numbers, non-empty strings\n    // and other objects, the rest checks for 0, '', etc.\n    return !!value || (value !== undefined && value !== null && !Number.isNaN(value));\n}\n", "\nconst assign      = Object.assign;\nconst CustomEvent = window.CustomEvent;\n\nconst defaults    = {\n\t// The event bubbles (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\tbubbles: true,\n\n\t// The event may be cancelled (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\tcancelable: true\n\n\t// Trigger listeners outside of a shadow root (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/composed\n\t//composed: false\n};\n\n/**\nEvent(type, properties)\n\nCreates a CustomEvent of type `type`.\nAdditionally, `properties` are assigned to the event object.\n*/\n\nexport default function Event(type, options) {\n\tlet settings;\n\n\tif (typeof type === 'object') {\n\t\tsettings = assign({}, defaults, type);\n\t\ttype = settings.type;\n        delete settings.type;\n\t}\n\n\tif (options && options.detail) {\n\t\tif (settings) {\n\t\t\tsettings.detail = options.detail;\n\t\t}\n\t\telse {\n\t\t\tsettings = assign({ detail: options.detail }, defaults);\n\t\t}\n\t}\n\n    // Settings accepted by CustomEvent:\n    // detail:     any\n    // bubbles:    true | false\n    // cancelable: true | false\n    // composed:   true | false\n    // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n\tvar event = new CustomEvent(type, settings || defaults);\n\n\tif (options) {\n\t\tdelete options.detail;\n\t\tassign(event, options);\n\t}\n\n\treturn event;\n}\n", "\n/**\ntrigger(type, node)\n\nTriggers event of `type` on `node`. Returns `false` if the event default was\nprevented, otherwise `true`.\n\n```\ntrigger('dom-activate', node);\n```\n*/\n\n/**\ntrigger(data, node)\n\nTriggers an event described by `data` on `node`. The `data` object must have a\n`type` property. Use the `details` property to carry a data payload.\n\n```\ntrigger({\n    type: 'dom-activate',\n    details: {...}\n}, node);\n```\n\nReturns `false` if the event default was prevented, otherwise `true`.\n*/\n\nimport curry from '../../fn/modules/curry.js';\nimport Event from './event.js';\n\nexport function trigger(type, node) {\n    let properties;\n\n    if (typeof type === 'object') {\n        properties = type;\n        type = properties.type;\n        delete properties.type;\n    }\n\n    // Don't cache events. It prevents you from triggering an event of a\n\t// given type from inside the handler of another event of that type.\n\tconst event = Event(type, properties);\n    return node.dispatchEvent(event);\n}\n\nexport default curry(trigger, true);\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { trigger });\n}\n", "\nexport default {\n    changeEvent: 'dom-update'\n}\n", "\nimport isDefined from '../../fn/modules/is-defined.js';\nimport trigger   from '../../dom/modules/trigger.js';\nimport config    from '../modules/config.js';\nimport library   from '../modules/library.js';\nimport compile   from '../modules/compile.js';\nimport Renderer  from './renderer.js';\nimport analytics from './analytics.js';\n\nconst assign  = Object.assign;\nconst rempty  = /^\\s*$/;\n\nfunction isNotEmpty(string) {\n    return !rempty.test(string);\n}\n\n\n/**\nCheckedRenderer()\nConstructs an object responsible for rendering to a plain text attribute.\n**/\n\nfunction toString(value) {\n    return '' + value;\n}\n\nfunction setChecked(node, value, hasValue) {\n        // Value may be a boolean in which case we use it directly\n    const checked = typeof value === 'boolean' ? value :\n        // If the element has a value attribute defined, we compare against it\n        hasValue ?\n            // Is value an array of values? It's important to include this here,\n            // at least for checkboxes, of which multiple may be checked. It\n            // cuts down on tag parsing in lists of inputs.\n            node.type === 'checkbox' && value && value.map ?\n                value.map(toString).includes(node.value) :\n                // Or a string or a number?\n                value + '' === node.value :\n        // Otherwise treat value as a boolean\n        !!value ;\n\n    if (checked === node.checked) {\n        return 0;\n    }\n\n    node.checked = checked;\n\n    // Optional event hook\n    if (config.changeEvent) {\n        trigger(config.changeEvent, node);\n    }\n\n    // Return DOM mod count\n    return 1;\n}\n\nexport default function CheckedRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = 'checked';\n    this.literally = options.literally || compile(library, 'data, element', options.source, null, options, this.element);\n    this.hasValue  = isDefined(node.getAttribute('value'));\n\n    // Negate the effects of having template content in the checked attribute -\n    // resetting the form sets it back to attribute state\n    node.removeAttribute('checked');\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].checked || (analytics[id].checked = 1);\n    ++analytics.Totals.checked;\n}\n\nassign(CheckedRenderer.prototype, Renderer.prototype, {\n    compose: function renderBoolean(strings, value) {\n        if (arguments.length !== 2 || strings.find(isNotEmpty)) {\n            throw new Error('A checked attribute may contain only one ${ tag }, optionally surrounded by white space');\n        }\n\n        return setChecked(this.node, value, this.hasValue)\n    }\n});\n", "\n/** include(src, data)\nIncludes another template. Not available inside attributes.\n**/\n\nimport { requestGet }   from '../../dom/modules/request.js';\nimport { getTarget }    from '../../fn/observer/observer.js';\nimport TemplateRenderer from '../renderers/template-renderer.js';\nimport request          from './request.js';\n\nexport default function include(url, object, element) {\n    if (typeof url === 'string' && !/^#/.test(url)) {\n        throw new Error('include() external url not yet supported, #fragment identifiers only');\n    }\n\n    // Currently we accept string URLs in the form '#id' only\n    const renderer = new TemplateRenderer(typeof url === 'string' ? url.slice(1) : url, element);\n\n    // Accept a url, fetch or import it before rendering\n    if (typeof object === 'string') {\n        return request(object)\n        .then((data) => renderer.push(data))\n        .then(() => renderer);\n    }\n\n    // Operate on target to be sure we are not registering gets for data.then\n    // in parent renderer\n    const data = getTarget(object);\n\n    // Accept a promise of data\n    if (data && data.then) {\n        return data\n        .then((data) => renderer.push(data))\n        .then(() => renderer);\n    }\n\n    // Cue the renderer so that we do not end up collecting read paths read by\n    // the child renderer in the parent.\n    return renderer\n    .push(data || {})\n    .then(() => renderer);\n}\n", "\n\nimport create           from '../../dom/modules/create.js';\nimport print            from '../library/print.js';\nimport toText           from '../modules/to-text.js';\nimport TemplateRenderer from './template-renderer.js';\nimport { cue }          from './batcher.js';\nimport { log }          from '../modules/log.js';\nimport { meta }         from './analytics.js';\n\nconst assign = Object.assign;\n\nexport function isStream(object) {\n    return !!object.each;\n}\n\nfunction connect(object) {\n    object && object.connect && object.connect();\n}\n\nfunction remove(object) {\n    object.remove();\n}\n\nfunction stop(object) {\n    object && object.stop && object.stop();\n}\n\nfunction toRenderer(value) {\n    // `this` should be the parent renderer\n    const parent = this;\n\n    return (!value || typeof value !== 'object') ?\n            create('text', toText(value)) :\n        value instanceof Node ?\n            value :\n        value instanceof TemplateRenderer ?\n            value :\n        (typeof value.length === 'number') ?\n            new ArrayRenderer(value) :\n        value instanceof Promise ?\n            new PromiseRenderer(value, parent) :\n        isStream(value) ?\n            new StreamRenderer(value) :\n        create('text', toText(value)) ;\n}\n\n/* ArrayRenderer */\n\nfunction toContent(object) {\n    return object && typeof object === 'object' && object.content ?\n        toContent(object.content) :\n        object ;\n}\n\nexport function ArrayRenderer(array) {\n    this.id       = ++meta.count;\n    this.contents = array.map(toRenderer, this);\n    this.content  = create('fragment', '');\n    this.first    = create('text', '');\n\n    // Render content to content fragment\n    this.content.append(this.first);\n    this.content.append.apply(this.content, this.contents.map(toContent));\n}\n\nassign(ArrayRenderer.prototype, {\n    replaceWith: function(node) {\n        this.stop();\n        this.contents.forEach(remove);\n        this.first.replaceWith.apply(this.first, arguments);\n    },\n\n    remove: function() {\n        this.contents.forEach(remove);\n        this.first.remove();\n    },\n\n    stop: function() {\n        if (this.status === 'done') { return; }\n        this.status = 'done';\n        this.contents.forEach(stop);\n    },\n\n    connect: function() {\n        if (this.status === 'dom') { return; }\n        this.status = 'dom';\n        this.contents.forEach(connect);\n    }\n});\n\n\n/* PromiseRenderer */\n\nexport function PromiseRenderer(promise, parent) {\n    this.id      = ++meta.count;\n    this.parent  = parent;\n    this.content = create('text', '');\n\n    promise\n    .then((value) => this.push(value))\n    .catch((e) => this.print(e))\n    .finally(() => this.stop());\n}\n\nassign(PromiseRenderer.prototype, {\n    push: function(value) {\n        // A promise may resolve after we have stopped its renderer, catch this\n        this.status !== 'done' && cue(this, arguments);\n    },\n\n    render: function(value) {\n        // Replace this promise renderer. Note that value cannot be a promise\n        // here – promise cannot resolve to a promise.\n        const renderer = toRenderer(value);\n        const content  = toContent(renderer);\n\n        this.content.replaceWith(content);\n        // A bit fudgy, it's a shame this renderer has to know about its parent\n        this.parent.content = renderer;\n        this.stop();\n\n        // If we're in the DOM, signal connected state\n        if (this.parent.status === 'dom') {\n            renderer.connect && renderer.connect();\n        }\n\n        return 1;\n    },\n\n    replaceWith: function(node) {\n        this.content.replaceWith(node);\n    },\n\n    print: window.DEBUG ?\n        function(e) { this.content.replaceWith(print(e)) } :\n        function() { this.content.remove(); },\n\n    remove: function() {\n        this.content.remove();\n    },\n\n    stop: function() {\n        this.status = 'done';\n    },\n\n    connect: function() {\n        this.status = 'dom';\n    }\n});\n\n\n/* StreamRenderer */\n\nexport function StreamRenderer(stream) {\n    this.id      = ++meta.count;\n    this.parent  = parent;\n    this.content = create('text', '');\n    this.stream  = stream;\n    stream.pipe(this);\n}\n\nassign(StreamRenderer.prototype, PromiseRenderer.prototype, {\n    render: function(value) {\n        const renderer = toRenderer.call(this, value);\n        const content  = toContent(renderer);\n\n        this.content.stop && this.content.stop();\n        this.content.replaceWith(content);\n        this.content = renderer;\n\n        // If we're in the DOM, signal connected state\n        if (this.status === 'dom') {\n            renderer.connect && renderer.connect();\n        }\n\n        return 1;\n    },\n\n    stop: function() {\n        if (this.status === 'done') { return; }\n        this.status = 'done';\n        this.stream.stop && this.stream.stop();\n        this.content.stop && this.content.stop();\n    },\n\n    connect: function() {\n        if (this.status === 'dom') { return; }\n        this.status = 'dom';\n        this.content.connect && this.content.connect();\n    }\n});\n", "\n/**\nContentRenderer()\nConstructs an object responsible for rendering to a text node. If the result of\nprocessing the literal content is more DOM content this renderer will insert\nthat DOM after the text node.\n**/\n\nimport curry          from '../../fn/modules/curry.js';\nimport library        from '../modules/library.js';\nimport compile        from '../modules/compile.js';\nimport toText         from '../modules/to-text.js';\nimport include        from '../library/include-literal.js';\nimport Renderer, { removeNodes } from './renderer.js';\nimport TemplateRenderer from './template-renderer.js';\nimport { StreamRenderer, ArrayRenderer, PromiseRenderer, isStream } from './content-renderers.js';\nimport analytics      from './analytics.js';\n\n\nconst assign = Object.assign;\n\nfunction toRenderer(value) {\n    // `this` should be the parent renderer\n    const parent = this;\n\n    return (!value || typeof value !== 'object') ?\n            toText(value) :\n        value instanceof Node ?\n            value :\n        value instanceof TemplateRenderer ?\n            value :\n        (typeof value.length === 'number') ?\n            new ArrayRenderer(value) :\n        value instanceof Promise ?\n            new PromiseRenderer(value, parent) :\n        isStream(value) ?\n            new StreamRenderer(value) :\n        toText(value) ;\n}\n\nfunction renderValue(parent, string, value) {\n    const contents = parent.contents;\n    const renderer = toRenderer.call(parent, value);\n\n    if (typeof renderer === 'string') {\n        return string + renderer;\n    }\n    else {\n        string && contents.push(string);\n        contents.push(renderer);\n        return '';\n    }\n}\n\nfunction setNodeValue(node, value) {\n    if (node.nodeValue !== value) {\n        node.nodeValue = value;\n        return 1;\n    }\n\n    return 0;\n}\n\nfunction stop(node) {\n    node && typeof node === 'object' && node.stop && node.stop();\n}\n\nfunction toContent(object) {\n    return typeof object === 'string' ? object :\n        object.content ? toContent(object.content) :\n        object ;\n}\n\nfunction setContents(first, last, contents, state) {\n    let count = 0;\n\n    // TODO: get rid of need to slice\n    const nodes = contents.map(toContent);\n\n    // Remove existing nodes, leaving first and last alone\n    if (first.nextSibling && last.previousSibling !== first) {\n        count += removeNodes(first.nextSibling, last.previousSibling);\n    }\n\n    // Set first text node\n    if (typeof contents[0] === 'string') {\n        count += setNodeValue(first, nodes.shift());\n    }\n    else {\n        count += setNodeValue(first, '');\n    }\n\n    // Set last text node\n    if (typeof nodes[nodes.length - 1] === 'string') {\n        count += setNodeValue(last, nodes.pop());\n    }\n    else {\n        count += setNodeValue(last, '');\n    }\n\n    if (nodes.length) {\n        first.after.apply(first, nodes);\n        state === 'dom' && contents.forEach((renderer) =>\n            (typeof renderer === 'object' && renderer.connect && renderer.connect())\n        );\n        count += contents.length;\n    }\n\n    return count;\n}\n\nexport default function ContentRenderer(node, options, element) {\n    Renderer.apply(this, arguments);\n\n    this.first     = node;\n    this.last      = document.createTextNode('');\n    this.first.after(this.last);\n    this.contents  = [];\n    this.literally = options.literally || compile(library, 'data, element, include', options.source, null, options, element);\n\n    // Renderer scoped template functions\n    this.include = curry((template, data) => include(template, data, element));\n\n    // Analytics\n    const id = '#' + options.template;\n\n    ++analytics[id].text || (analytics[id].text = 1);\n    ++analytics.Totals.text;\n}\n\nassign(ContentRenderer.prototype, Renderer.prototype, {\n    push: function() {\n        // Preemptively stop all nodes, they are about to be updated\n        this.contents.forEach(stop);\n        this.contents.length = 0;\n        return Renderer.prototype.push.apply(this, arguments);\n    },\n\n    render: function(data) {\n        // Stop all nodes, they are about to be recreated. This needs to be done\n        // here as well as render, as update may be called by TemplateRenderer\n        // without going through .push() cueing first. (??)\n        this.contents.forEach(stop);\n        this.contents.length = 0;\n        return Renderer.prototype.render.call(this, data, this.element, this.include);\n    },\n\n    compose: function(strings) {\n        let n = -1;\n        let string = '';\n\n        while (strings[++n] !== undefined) {\n            // Append to string until it has to be pushed to contents because\n            // a node or renderer has to be pushed in behind it\n            string = renderValue(this, string + strings[n], arguments[n + 1]);\n        }\n\n        string && this.contents.push(string);\n        return setContents(this.first, this.last, this.contents, this.status);\n    }\n});\n", "\nimport overload  from '../../fn/modules/overload.js';\nimport library   from '../modules/library.js';\nimport compile   from '../modules/compile.js';\nimport toText    from '../modules/to-text.js';\nimport Renderer  from './renderer.js';\nimport analytics from './analytics.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\n\nconst nothing = [];\n\n/**\nTokensRenderer()\nConstructs an object responsible for rendering to a token list attribute such\nas a class attribute.\n**/\n\nconst getTokenList = overload((node, name) => name, {\n    'class': (node) => node.classList\n});\n\nfunction valueify(value) {\n    return (value && typeof value === 'object' && value.length !== undefined) ?\n        value.join(' ') :\n        toText(value) ;\n}\n\nfunction updateTokens(list, cached, tokens, count) {\n    // Remove all tokens from cached that are found in new tokens\n    let n = cached.length;\n    while (n--) {\n        if (tokens.includes(cached[n])) {\n            cached.splice(n, 1);\n        }\n    }\n\n    // The remainder are not in values and thus must be removed\n    if (cached.length) {\n        list.remove.apply(list, cached);\n        ++count;\n    }\n\n    // Add the new tokens. The list object (a TokenList) ignores tokens it\n    // already contains, so it is safe to set doubles. Return DOM mutation count\n    // for logging\n    if (tokens.length) {\n        list.add.apply(list, tokens);\n        ++count\n    }\n\n    return count;\n}\n\nexport default function TokensRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = options.name;\n    this.list      = getTokenList(node, options.name);\n    this.tokens    = nothing;\n    this.literally = options.literally || compile(library, 'data, element', options.source, null, options, node);\n\n    // Empty the tokens until it is rendered to avoid code in literals\n    // being interpreted as classes\n    node.setAttribute(this.name, '');\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].class || (analytics[id].class = 1);\n    ++analytics.Totals.class;\n}\n\nassign(TokensRenderer.prototype, Renderer.prototype, {\n    compose: function(strings) {\n        let count = 0;\n\n        // Set permanent tokens on first render only\n        if (this.count === 1) {\n            const tokens = strings.join(' ').trim().split(/\\s+/);\n            this.list.add.apply(this.list, tokens);\n            ++count;\n        }\n\n        // Turn evaluated values into an array of strings\n        const tokens = A.slice.call(arguments, 1)\n            .map(valueify)\n            .filter((string) => !!string);\n\n        count = updateTokens(this.list, this.tokens, tokens, count);\n        this.tokens  = tokens;\n        return count;\n    }\n});\n", "\nimport trigger   from '../../dom/modules/trigger.js';\nimport config    from '../modules/config.js';\nimport library   from '../modules/library.js';\nimport compile   from '../modules/compile.js';\nimport Renderer, { renderString } from './renderer.js';\nimport analytics from './analytics.js';\n\nconst assign = Object.assign;\n\n\n/**\nValueRenderer()\nConstructs an object responsible for rendering to a plain text attribute.\n**/\n\nconst rempty = /^\\s*$/;\n\nconst types = {\n    'number': 'number',\n    'range':  'number'\n};\n\nfunction addValue(result, value) {\n    return result === undefined ?\n        value :\n        result + value ;\n}\n\nfunction renderValue(values) {\n    const strings = values[0];\n    let value = rempty.test(strings[0]) ? undefined : strings[0];\n    let n = 0;\n\n    while (strings[++n] !== undefined) {\n        value = addValue(value, values[n]);\n\n        if (!rempty.test(strings[n])) {\n            value = addValue(value, strings[n]);\n        }\n    }\n\n    return value;\n}\n\n\n/**\nsetProperty(node, name, value)/\n**/\n\nfunction setProperty(node, value) {\n    // Bit of an edge case, but where we have a custom element that has not\n    // been upgraded yet, but it gets a property defined on its prototype when\n    // it does upgrade, setting the property on the instance now will mask the\n    // ultimate get/set definition on the prototype when it does arrive.\n    //\n    // So don't, if property is not in node. Set the attribute, it will be\n    // picked up on upgrade. MEH.\n    if (value === null) {\n        throw new Error('VALUE');\n    }\n\n    //console.log('VALUE', value);\n    node.value = value;\n\n    // Return DOM mutation count\n    return 1;\n}\n\nfunction setValue(node, value) {\n    // Don't render into focused nodes, it makes the cursor jump to the\n    // end of the field, and we should cede control to the user anyway\n    if (document.activeElement === node) {\n        return 0;\n    }\n\n    const type = types[node.type];\n    value = type === undefined ? value :\n        typeof value === type ? value :\n        null ;\n\n    // Avoid updating with the same value. Support node values of any type to\n    // support custom elements (like <range-control>), as well as values that\n    // are always strings\n    if (value === node.value || (value + '') === node.value) {\n        return 0;\n    }\n\n    // Here's how we did it for number\n    //if (value === (node.value === '' ? null : +node.value)) { return 0; }\n\n    const count = setProperty(node, value);\n\n    // Optional event hook\n    if (config.changeEvent) {\n        trigger(config.changeEvent, node);\n    }\n\n    // Return DOM mod count\n    return count;\n}\n\nexport default function ValueRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = 'value';\n    this.literally = options.literally || compile(library, 'data, element', options.source, null, options, node);\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].value || (analytics[id].value = 1);\n    ++analytics.Totals.value;\n}\n\nassign(ValueRenderer.prototype, Renderer.prototype, {\n    compose: function() {\n        const value = renderValue(arguments);\n        return setValue(this.node, value)\n    }\n});\n\n\n/**\nStringValueRenderer()\nConstructs an object responsible for rendering to a value property as a string.\n**/\n\nexport function StringValueRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = 'value';\n    this.literally = options.literally || compile(library, 'data, element', options.source, null, options, node);\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].value || (analytics[id].value = 1);\n}\n\nassign(StringValueRenderer.prototype, Renderer.prototype, {\n    compose: function() {\n        const value = renderString(arguments);\n        return setValue(this.node, value)\n    }\n});\n", "\nconst textarea = document.createElement('textarea');\n\nexport default function decode(html) {\n    // Converts &amp;, &lt; and &gt; to &, < and >\n    textarea.innerHTML = html;\n    return textarea.value;\n}\n", "\nimport noop     from '../../fn/modules/noop.js';\nimport overload from '../../fn/modules/overload.js';\nimport toType   from '../../dom/modules/to-type.js';\n\nimport AttributeRenderer from '../renderers/attribute-renderer.js';\nimport BooleanRenderer   from '../renderers/boolean-renderer.js';\nimport CheckedRenderer   from '../renderers/checked-renderer.js';\nimport ContentRenderer   from '../renderers/content-renderer.js';\nimport TokensRenderer    from '../renderers/tokens-renderer.js';\nimport ValueRenderer, { StringValueRenderer } from '../renderers/value-renderer.js';\n\nimport decode   from './decode.js';\n\nconst A = Array.prototype;\nconst rliteral = /\\$\\{/;\n\n\n/**\ncompileAttributes(renderers, options, nodeames)\n**/\n\nfunction addAttributeRenderer(renderers, Renderer, node, source, name, options) {\n    if (!source || !rliteral.test(source)) { return; }\n    options.source = source;\n    options.name   = name;\n    renderers.push(new Renderer(node, options));\n}\n\nfunction compileAttr(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, AttributeRenderer, node, attribute.value, attribute.localName, options);\n}\n\nfunction compileBoolean(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, BooleanRenderer, node, attribute.value, attribute.localName, options);\n}\n\nfunction compileTokens(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, TokensRenderer, node, attribute.value, attribute.localName, options);\n}\n\nfunction compileValue(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, ValueRenderer, node, attribute.value, 'value', options);\n}\n\nfunction compileValueString(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, StringValueRenderer, node, attribute.value, 'value', options);\n}\n\n\nconst compileAttribute = overload((renderers, options, node, attribute) => attribute.localName, {\n    'checked':  function compileChecked(renderers, options, node, attribute) {\n        addAttributeRenderer(renderers, CheckedRenderer, node, attribute.value, 'checked', options);\n    },\n\n    'class': compileTokens,\n\n    'datetime': function compileDatetime(renderers, options, node, attribute) {\n        if (window.DEBUG) { console.log('Todo: compile datetime attribute'); }\n    },\n\n    'disabled': compileBoolean,\n    'hidden': compileBoolean,\n\n    // Special workaround attribute used in cases where ${} cannot be added\n    // directly to the HTML content, such as in <tbody> or <tr>\n    'inner-content': function(renderers, options, node, attribute) {\n        const string = attribute.value;\n        if (!string || !rliteral.test(string)) { return; }\n        node.removeAttribute(attribute.localName);\n        options.source = decode(string);\n        options.name   = 'innerHTML';\n        renderers.push(new ContentRenderer(node, options, parent));\n    },\n\n    'required': compileBoolean,\n\n    'value': overload((renderers, options, node, attribute) => ('' + node.type), {\n        //'checkbox':  compileValueChecked,\n        //'date':      compileValueDate,\n        //'number':    compileValueNumber,\n        //'range':     compileValueNumber,\n        //'select-multiple': compileValueArray,\n        'text':       compileValueString,\n        'search':     compileValueString,\n        'select-one': compileValueString,\n        'default':    compileValue,\n        'undefined':  compileAttr\n    }),\n\n    'default': compileAttr\n});\n\nfunction compileAttributes(renderers, options, node) {\n    // Attributes may be removed during parsing so copy the list before looping\n    const attributes = A.slice.apply(node.attributes);\n    var n = -1, attribute;\n    // Todo: order attributes so that min, max, value come last?\n    while (attribute = attributes[++n]) {\n        compileAttribute(renderers, options, node, attribute);\n    }\n}\n\n\n/**\ncompileElement()\n**/\n\nfunction compileChildren(renderers, options, node, parent) {\n    const children = node.childNodes;\n\n    if (children) {\n        const path = options.path;\n        let n = -1;\n\n        while(children[++n]) {\n            options.path = path ? path + '.' + n : '' + n;\n            compileNode(renderers, options, children[n], parent);\n        }\n\n        // Put path back to what it was or subsequent renderers will get an\n        // erroneous path\n        options.path = path;\n    }\n\n    return renderers;\n}\n\nconst compileElement = overload((renderers, options, element) => element.tagName.toLowerCase(), {\n    // Ignore SVG <defs>, which for our purposes we consider as inert like\n    // HTML's <template>\n    'defs': noop,\n\n    'default': (renderers, options, element) => {\n        // Children first means inner DOM to outer DOM\n        compileChildren(renderers, options, element, element);\n\n        // We must wait until custom elements are upgraded before we may\n        // interact with their non-standard properties and attributes\n        // Todo: Test this\n        // Hang on... is this still true given that the renderer.set negociates\n        // the way an attribute is rendered??\n        /*const tag = node.getAttribute('is') || node.tagName.toLowerCase();\n        if (/-/.test(tag)) {\n            window.customElements.whenDefined(node.tagName).then(() => {\n                compileAttributes(renderers, options, node);\n                compileType(renderers, options, node);\n            });\n        }\n        else {*/\n            compileAttributes(renderers, options, element);\n            //compileType(renderers, options, node);\n        /*}*/\n\n        return renderers;\n    }\n});\n\n\n/**\ncompileNode()\n**/\n\nconst compileNode = overload((renderers, options, node) => toType(node), {\n    'comment': noop,\n\n    'element': compileElement,\n\n    'fragment': compileChildren,\n\n    'text': (renderers, options, node, parent) => {\n        const string = node.nodeValue;\n\n        if (string && rliteral.test(string)) {\n            options.source = decode(string);\n            options.name   = null;\n            renderers.push(new ContentRenderer(node, options, parent));\n        }\n\n        return renderers;\n    },\n\n    'doctype': noop,\n\n    'document': (renderers, options, document) => {\n        compileElement(renderers, options, document.documentElement);\n        return renderers;\n    },\n\n    'default': () => {\n        throw new Error('Node not compileable');\n    }\n});\n\nexport default compileNode;\n", "\n/**\nTemplateRenderer(template)\n\nImport the `TemplateRenderer` constructor from the main module:\n\n```js\nimport TemplateRenderer from 'https://stephen.band/literal/module.js';\n```\n\nThe `TemplateRenderer` constructor takes a template element, or the `id` of a\ntemplate element, and creates a renderer of a clone of the template's content.\nA renderer manages an asynchronous lifecycle of content renders, updating its\nDOM nodes in response to changing data.\n\n```js\nconst renderer = new TemplateRenderer('id');\nconst data     = {};\n\n// Cue data for render then add it to the DOM\nrenderer\n.push(data)\n.then(() => document.body.append(renderer.content));\n```\n**/\n\nimport identify        from '../../dom/modules/identify.js';\nimport isTextNode      from '../../dom/modules/is-text-node.js';\nimport compileNode     from '../modules/compile-node.js';\nimport { Observer, getTarget } from '../../fn/observer/observer.js';\nimport stats, { meta } from './analytics.js';\nimport { uncue }       from './batcher.js';\nimport Renderer, { removeNodes, renderStopped, trigger } from './renderer.js';\n\nconst assign = Object.assign;\nconst cache  = {};\n\n\n/*\nTemplateRenderer\nDescendant paths are stored in the form `\"1.12.3.class\"`, enabling fast\ncloning of template instances without retraversing their DOMs looking for\nliteral attributes and text.\n*/\n\nfunction child(parent, index) {\n    return /^[a-zA-Z]/.test(index) ?\n        parent :\n        parent.childNodes[index] ;\n}\n\nfunction getDescendant(path, root) {\n    // If path is empty return root\n    const p = path && path.split(/\\./);\n    return path ?\n        p.reduce(child, root) :\n        root ;\n}\n\nfunction isMarkerNode(node) {\n    // Markers should be spaces-only else we risk unrendered content being\n    // inserted into the DOM. If it's not a text node, it's not a marker\n    // node because it could contain something that contains unrendered code.\n    if (!isTextNode(node)) {\n        return false;\n    }\n\n    const text  = node.nodeValue;\n    const space = /^\\s*/.exec(text);\n\n    // If text is more than just space return false\n    return space[0].length === text.length;\n}\n\nfunction prepareContent(content) {\n    // Due to the way HTML is usually written the vast majority of templates\n    // start and end with a text node, usually containing some white space\n    // and new lines. The renderer uses these as delimiters for the start and\n    // end of templated content – where it can. If the template does NOT start\n    // or end with a text node, we insert text nodes where needed.\n    const first = content.childNodes[0];\n    const last  = content.childNodes[content.childNodes.length - 1];\n\n    if (!isMarkerNode(first)) {\n        content.prepend(document.createTextNode(''));\n    }\n\n    if (!isMarkerNode(last)) {\n        content.append(document.createTextNode(''));\n    }\n}\n\nfunction newRenderer(renderer) {\n    // `this` is the parent renderer of the new renderer\n    const node = getDescendant(renderer.path, this.content);\n\n    // Where node is a text node we must find its context element\n    const element = isTextNode(node) ?\n        // If it's a direct child of template, use the template renderer's\n        // element as context element\n        !/\\./.test(renderer.path) ? this.element :\n\n        // Otherwise it is already inside its context element\n        node.parentNode :\n\n    // node itself is the context element for attributes\n    node ;\n\n    return new renderer.constructor(node, renderer, element);\n}\n\nexport default function TemplateRenderer(template, parent) {\n    // TemplateRenderer may be called with a string id or a template element\n    const id = typeof template === 'string' ?\n        template :\n        identify(template) ;\n\n    this.id      = ++meta.count;\n    this.element = parent;\n\n    // If the template is already compiled, clone the compiled contents to\n    // this renderer and bind them to a new fragment\n    if (cache[id]) {\n        const template = cache[id].template;\n        this.template  = template;\n        this.content   = template.content ? template.content.cloneNode(true) : template.cloneNode(true) ;\n        this.first     = this.content.childNodes[0];\n        this.last      = this.content.childNodes[this.content.childNodes.length - 1];\n        this.contents = cache[id].contents.map(newRenderer, this);\n        ++stats['#' + id].template;\n        ++stats.Totals.template;\n        return;\n    }\n\n    template = typeof template === 'string' ?\n        document.getElementById(template[0] === '#' ? template.slice(1) : template) :\n        template ;\n\n    if (window.DEBUG) {\n        if (!template) {\n            throw new Error('Template id=\"' + id + '\" not found in document');\n        }\n        /*\n        if (!template.content) {\n            throw new Error('Element id=\"' + id + '\" is not a <template> (no content fragment)');\n        }\n        */\n    }\n\n    /**\n    .content\n\n    A fragment that initially contains the renderer's DOM nodes. On creation of\n    a renderer they are in an unrendered state. They are guaranteed to be in a\n    rendered state on resolution of the first render(). The fragment may be\n    inserted into the DOM at any time, at which point it will no longer contain\n    the renderer's DOM nodes.\n    **/\n    template.content && prepareContent(template.content);\n\n    this.template = template;\n\ntry {\n    this.content  = template.content ? template.content.cloneNode(true) : template.cloneNode(true) ;\n}\ncatch(e) {\n    console.log(template, template.content);\n    throw e;\n}\n\n    this.first    = this.content.childNodes[0];\n    this.last     = this.content.childNodes[this.content.childNodes.length - 1];\n\n    // Analytics (must be declared before contents)\n    stats['#' + id] = { template: 1 };\n    ++stats.Totals.template;\n\n    // The options object contains information for renderer objects. It is\n    // mutated as it is passed to each renderer (specifically path, name,\n    // source properties). We can do this because renderer construction is\n    // synchronous within a template.\n    this.contents = compileNode([], { template: id, path: '' }, this.content, parent);\n    cache[id] = this;\n}\n\nassign(TemplateRenderer.prototype, Renderer.prototype, {\n    /**\n    .push(data)\n    Cues `data` to be rendered in the next render batch. Returns a promise that\n    resolves when the batch is finished rendering. [Todo: this is a bit bizarre,\n    perhaps implement .each().]\n\n    The `data` object is observed for mutations, and the renderer updates it\n    content until either a new data object is cued or the renderer is stopped.\n    **/\n    push: function(object) {\n        const data = object ? getTarget(object) : null ;\n\n        // Deduplicate. Not sure this is entirely necessary.\n        if (data === this.data) {\n            return Promise.reject('Attempt to render with same object as last render');\n        }\n\n        this.data = data;\n        return Renderer.prototype.push.apply(this, arguments);\n    },\n\n    render: function(object) {\n        //console.log(this.constructor.name + '#' + this.id + '.render()');\n\n        if (!object) {\n            // Remove all but the first node to the renderer's content fragment\n            const nodes = [];\n            let node = this.first;\n\n            while (node !== this.last) {\n                node = node.nextSibling;\n                nodes.push(node);\n            }\n\n            this.content.append.apply(this.content, nodes);\n            return nodes.length;\n        }\n\n        const data      = getTarget(object);\n        const observer  = Observer(data);\n        const contents = this.contents;\n        var count = 0;\n\n        // Render the contents (synchronously)\n        contents.forEach((renderer) => count += renderer.render(observer));\n\n        // If this.first is not in the content fragment, it must be in the\n        // parent DOM being used as a marker. It's time for its freshly rendered\n        // brethren to join it.\n        if (this.content.firstChild && this.first !== this.content.firstChild) {\n            this.first.after(this.content);\n            ++count;\n        }\n\n        return count;\n    },\n\n    /**\n    .remove()\n    Removes rendered content from the DOM.\n    **/\n    remove: function() {\n        return removeNodes(this.first, this.last);\n    },\n\n    /**\n    .replaceWith()\n    Removes rendered content from the DOM and inserts arguments in its place.\n    **/\n    replaceWith: function() {\n        this.first.before.apply(this.first, arguments);\n        return this.remove();\n    },\n\n    /**\n    .stop()\n    Stops renderer.\n    **/\n    stop: function() {\n        uncue(this);\n\n        if (window.DEBUG) {\n            this.render = renderStopped;\n        }\n\n        // object, method, status, payload\n        trigger(this, 'stop', 'done');\n        return this;\n    }\n});\n", "\n/**\n<include-literal>\n\nA `include-literal` may be placed pretty much anywhere in your HTML, enabling\nthe insertion of chunks of dynamic, JS-rendered DOM wherever you like in a\ndocument.\n\nA `include-literal` finds a source template identified by its `src` attribute,\nfetches JSON or imports a module referred to by its `data` attribute, renders\nattributes and text found to contain literal tags, then replaces itself with\nthe rendered result.\n\nA `include-literal` may contain fallback content, in case any of that fails.\n\n```html\n<template id=\"greetings\">\n    Hello ${ data.name }.\n</template>\n\n<include-literal src=\"#greetings\" data=\"/users/1.json\">\n    Fallback content.\n</include-literal>\n```\n\nMultiple `data-` attributes may be declared, their values become properties of\nthe `data` object inside the template:\n\n```\n<include-literal src=\"#add-to-collections-thumb\" data-pk=\"34\" ... ></include-literal>\n```\n\nOr a single `data` attribute can be used to pass JSON to use as the `data`\nobject inside the template:\n\n```\n<include-literal src=\"#add-to-collections-thumb\" data='{\"pk\":34, ... }'></include-literal>\n```\n\nBoth `data` and `data-` attributes also accept URLs. A URL is used to fetch a\n.json file...\n\n```\n<include-literal src=\"#greetings\" data=\"/users/1.json\"></include-literal>\n```\n\n...or import the default export of a .js module:\n\n```\n<include-literal src=\"#greetings\" data=\"/user-module.js\"></include-literal>\n```\n\n**/\n\nimport element        from '../../dom/modules/element.js';\nimport { requestGet } from '../../dom/modules/request.js';\nimport create         from '../../dom/modules/create.js';\nimport request from '../library/request.js';\nimport TemplateRenderer from '../renderers/template-renderer.js';\nimport print   from '../library/print.js';\n\nconst rpath = /^\\/|\\.|^https?:\\/\\//;\n\nfunction parseValue(string) {\n    try {\n        return JSON.parse(string);\n    }\n    catch(e) {\n        return string;\n    }\n}\n\nfunction resolveValue(value) {\n    return rpath.test(value) ?\n        request(value) :\n        parseValue(value) ;\n}\n\nfunction zipObject(keys, values) {\n    const object = {};\n    let n = keys.length;\n    while (n--) { object[keys[n]] = values[n]; }\n    return object;\n}\n\nconst onerror = window.DEBUG ? (e, element) => {\n    element.loading = false;\n    element.replaceWith(print(e));\n    throw e;\n} : (e, include) => {\n    element.loading = false;\n    if (element.frame) { cancelAnimationFrame(element.frame); }\n    else { element.removeAttribute('loading'); }\n    throw e;\n} ;\n\nelement('<include-literal>', {\n    construct: function() {\n        if (window.DEBUG && !this.hasAttribute('src')) {\n            console.error('<include-literal> a src attribute is required', this);\n        }\n\n        // Resolve data\n        const keys   = Object.keys(this.dataset);\n        const values = Object.values(this.dataset);\n        const dataPromise = keys.length ?\n            // where there are values in dataset compose data from dataset\n            Promise\n            .all(values.map(resolveValue))\n            .then((values) => zipObject(keys, values)) :\n\n            // Otherwise wait for data attribute\n            new Promise((resolve, reject) => {\n                this.resolveData = resolve;\n                this.rejectData  = reject;\n            }) ;\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolveSrc = resolve;\n            this.rejectSrc = reject;\n        })\n        .then((src) => {\n            // TODO: remove parent here, should not be needed until render\n            this.renderer = new TemplateRenderer(src, this.parentElement);\n            return dataPromise;\n        })\n        .catch((e) => onerror(e, this));\n    },\n\n    connect: function() {\n        // If we are loading at connect time, add the loading attribute after a\n        // couple of frames, allowing time for any styled transition to start\n        (this.loading && (this.frame = requestAnimationFrame(() =>\n            (this.loading && (this.frame = requestAnimationFrame(() =>\n                (this.loading && this.setAttribute('loading', ''))\n            )))\n        )));\n\n        // Cue up first render and replace\n        this.promise.then((data) => {\n            this.loading = false;\n            this.renderer.element = this.parentElement;\n            this.renderer.render(data);\n            this.replaceWith(this.renderer.content);\n            this.renderer.connect();\n        });\n\n        // Where no data or data-* attribute has been defined resolve with an\n        // empty object...\n        //this.resolveData && this.resolveData({});\n    }\n}, {\n    /**\n    data=\"\"\n    Defines a JSON file or JS module containing data to be rendered. If a data\n    attribute is not defined and empty object is used.\n\n    To get data from a JSON file specify a path to JSON:\n\n    ```html\n    <include-literal src=\"#greetings\" data=\"./package.json\"></include-literal>\n    ```\n\n    Or import the default export of a JS module:\n\n    ```html\n    <include-literal src=\"#greetings\" data=\"./modules/literal.js\"></include-literal>\n    ```\n\n    Or import a named export of JS module:\n\n    ```html\n    <include-literal src=\"#greetings\" data=\"./modules/literal.js#name\"></include-literal>\n    ```\n    **/\n\n    data: {\n        attribute: function(value) {\n            this.data = value;\n        },\n\n        get: function() {\n            if (this.renderer) {\n                return this.renderer.data;\n            }\n        },\n\n        set: function(value) {\n            if (this.renderer) {\n                if (!value || value === 'null') {\n                    this.renderer.push(null);\n                }\n                else if (typeof value === 'string') {\n                    request(value).then((data) => this.renderer.push(data));\n                }\n                else {\n                    console.log('YEAH', value);\n                    this.renderer.push(value);\n                }\n\n                return;\n            }\n\n            if (!this.resolveData) {\n                //console.log('BOO dont know why this is triggered multiple times', value)\n                throw new Error('<include-literal> may possess either data-* attributes or a single data attribute, not both');\n            }\n\n            if (!value) {\n                return;\n            }\n            else if (typeof value === 'string') {\n                this.loading = true;\n                this.request = request(value);\n                this.resolveData(this.request);\n            }\n            else {\n                this.resolveData(value);\n            }\n        }\n    },\n\n    loading: {\n        /**\n        loading=\"\"\n        Read-only (pseudo-read-only) boolean attribute indicating status of\n        `src` and `data` requests.\n        **/\n\n        /**\n        .loading\n        Read-only (pseudo-read-only) boolean indicating status of `src` and\n        `data` requests.\n        **/\n        value: false,\n        writable: true\n    },\n\n    /**\n    src=\"\"\n    Define a source template whose rendered content replaces this\n    `include-literal`. This is a required attribute and must be in the form of\n    a fragment identifier pointing to a `template` element in the DOM.\n    **/\n\n    src: {\n        attribute: function(value) {\n            if (!value) {\n                return this.rejectSrc(new Error('<include-literal> source src=\"' + value + '\" is empty'));\n            }\n\n            // This is for inserting static HTML for living archives, but the API\n            // should be different for static HTML\n            if (!/^#/.test(value)) {\n                // Flag loading until we connect, at which point we add the\n                // loading attribute that may be used to indicate loading. Why\n                // wait? Because we are not in the DOM yet, and if we want a\n                // loading icon to transition in the transition must begin after\n                // we are already in the DOM.\n                this.loading = true;\n\n                requestGet(value).then((html) => {\n                    return this.resolveSrc(create('fragment', html));\n                });\n\n                return;\n            }\n\n            const id = value.replace(/^#/, '');\n            const template = document.getElementById(id);\n\n            if (!template) {\n                this.rejectSrc(new Error('<include-literal> src template \"' + value + '\" not found'));\n                return;\n            }\n\n            this.resolveSrc(template);\n        }\n    }\n});\n", "\nimport renderers from '../renderers/analytics.js';\n\nexport default {\n    renderers\n};\n", "\nimport Stream   from '../../fn/modules/stream.js';\nimport Producer from '../../fn/modules/stream/producer.js';\n//import features from './features.js';\n\nconst assign  = Object.assign;\nconst rspaces = /\\s+/;\n\n/*\nfunction prefixType(type) {\n\treturn features.events[type] || type ;\n}\n*/\n\n/**\nisPrimaryButton(e)\nReturns `true` if event is from the primary (normally the left or only)\nbutton of an input device. Use this to filter out right-clicks.\n*/\n\nexport function isPrimaryButton(e) {\n\t// Ignore mousedowns on any button other than the left (or primary)\n\t// mouse button, or when a modifier key is pressed.\n\treturn (e.which === 1 && !e.ctrlKey && !e.altKey && !e.shiftKey);\n}\n\n/**\npreventDefault(e)\nCalls `e.preventDefault()`.\n**/\n\nexport function preventDefault(e) {\n\te.preventDefault();\n}\n\n/**\nisTargetEvent(e)\nTests whether `e.target === e.currentTarget`.\n**/\nexport function isTargetEvent(e) {\n\treturn e.target === e.currentTarget;\n}\n\nexport function isNotPrevented(e) {\n\treturn !e.defaultPrevented;\n}\n\n\n\n/**\nevents(type, node)\n\nReturns a mappable stream of events heard on `node`:\n\n```js\nvar stream = events('click', document.body);\n.map(get('target'))\n.each(function(node) {\n    // Do something with nodes\n});\n```\n\nStopping the stream removes the event listeners:\n\n```js\nstream.stop();\n```\n\nThe first parameter may also be an options object, which must have a `type`\nproperty. The `select: '...'` property allows for delegation of an event from\nthe selected target. Other properties, eg. `passive: true` are passed to\naddEventListener options.\n\n```js\nvar stream = events({ type: 'scroll', passive: true, select: '' }, document.body);\n```\n*/\n\n// DOM click events may be simulated on inputs when their labels are\n// clicked. The tell-tale is they have the same timeStamp. Track click\n// timeStamps.\nvar clickTimeStamp = 0;\n\nwindow.addEventListener('click', (e) => clickTimeStamp = e.timeStamp);\n\nfunction listen(listener, type) {\n    listener.node.addEventListener(type, listener, listener.options);\n    return listener;\n}\n\nfunction unlisten(listener, type) {\n    listener.node.removeEventListener(type, listener);\n    return listener;\n}\n\nfunction EventsProducer(type, options, node) {\n    this.types   = type.split(rspaces);//.map(prefixType);\n    this.options = options;\n    this.node    = node;\n    this.select  = options && options.select;\n\n    // Potential hard-to-find error here if type has repeats, ie 'click click'.\n    // Lets assume nobody is dumb enough to do this, I dont want to have to\n    // check for that every time.\n}\n\nassign(EventsProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        this[0] = stream;\n        this.types.reduce(listen, this);\n    },\n\n    handleEvent: function(e) {\n        // Ignore clicks with the same timeStamp as previous clicks –\n        // they are likely simulated by the browser.\n        if (e.type === 'click' && e.timeStamp <= clickTimeStamp) {\n            return;\n        }\n\n        // If there is a selector and the target doesn't match, shoofty\n        // outta here\n        if (this.select) {\n            const selectedTarget = e.target.closest(this.select);\n            if (!selectedTarget) { return; }\n            e.selectedTarget = selectedTarget;\n        }\n\n        this[0].push(e);\n    },\n\n    stop: function() {\n        this.types.reduce(unlisten, this);\n        Producer.prototype.stop.apply(this, arguments);\n    }\n});\n\nexport default function events(type, node) {\n    let options;\n\n    if (typeof type === 'object') {\n        options = type;\n        type    = options.type;\n    }\n\n    return new Stream(new EventsProducer(type, options, node));\n}\n\n\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n\twindow.dom ? (window.dom.events = events) : (window.dom = { events });\n}\n\n", "\n/**\nrect(node)\n\nReturns a `DOMRect` object describing the draw rectangle of `node`.\n(If `node` is `window` a preudo-DOMRect object is returned).\n**/\n\nfunction windowBox() {\n\treturn {\n\t\tx:      0,\n\t\ty:      0,\n\t\tleft:   0,\n\t\ttop:    0,\n\t\tright:  window.innerWidth,\n\t\tbottom: window.innerHeight,\n\t\twidth:  window.innerWidth,\n\t\theight: window.innerHeight\n\t};\n}\n\nexport default function rect(node) {\n\treturn node === window ?\n\t\twindowBox() :\n        // In Safari SVG shapes dont get a .getClientRects()[0] so fallback to\n        // .getBoundingClientRect()\n\t\tnode.getClientRects()[0] || node.getBoundingClientRect() ;\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { rect });\n}\n", "/**\ntoArray(object)\n*/\n\nexport default function toArray(object) {\n    if (object.toArray) { return object.toArray(); }\n\n    // Speed test for array conversion:\n    // https://jsperf.com/nodelist-to-array/27\n\n    var array = [];\n    var l = object.length;\n    var i;\n\n    if (typeof object.length !== 'number') { return array; }\n\n    array.length = l;\n\n    for (i = 0; i < l; i++) {\n        array[i] = object[i];\n    }\n\n    return array;\n}\n", "\n/**\nselect(selector, node)\n\nReturns an array of all descendants of `node` that match `selector`.\n*/\n\nimport curry from '../../fn/modules/curry.js';\nimport toArray from '../../fn/modules/to-array.js';\n\nexport function select(selector, node) {\n\treturn toArray(node.querySelectorAll(selector));\n}\n\nexport default curry(select, true)\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n\twindow.dom ? (window.dom.select = select) : (window.dom = { select });\n}\n", "\n/**\nGet Started\n\nImport Literal from the main module in the repo:\n\n```\nimport 'http://stephen.band/literal/module.js';\n```\n\n<p class=\"right-bubble bubble\">Clearly you should not rely on this resource in\nproduction. Use a bundler such as <a href=\"https://esbuild.github.io/\">esbuild</a>\nto package it into your own module.</p>\n\nAnd grab the associated CSS:\n\n```css\n@import 'http://stephen.band/literal/module.css';\n```\n\n<p class=\"right-bubble bubble\">Clearly you should not rely on this resource in\nproduction. Use a bundler to package it into your own CSS.</p>\n\nThis registers the custom element `<include-literal>`. Here is how to use it:\n\n```html\n<template id=\"item\">\n    <li>${ data.text }</li>\n</template>\n\n<template id=\"todo-list\">\n    <p>Todo list: ${ data.title }</p>\n    <ul>${ data.tasks.map(include('#item')) }</ul>\n</template>\n\n<include-literal src=\"#todo-list\" data=\"./data/todo.json\">\n    <p>Fallback content.</p>\n</include-literal>\n```\n\nA `<include-literal>` is replaced with the content of its `src` template when\nits `data` is fetched and rendered. Inside the template, data to render\nis accessed through the variable `${ data }`. The result of this example is:\n\n<template id=\"item\">\n    <li>${ data.text }</li>\n</template>\n\n<template id=\"author\">\n    <p>Todo list: ${ data.title }</p>\n    <ul>${ data.tasks.map(include('#item')) }</ul>\n</template>\n\n<include-literal src=\"#author\" data=\"./data/todo.json\">\n    <p>Fallback content.</p>\n</include-literal>\n\nThe template renderer observes `data` objects and updates the DOM if changes are\ndetected. In the following example a mutating `data` object is imported from a\nJS module and used to rotate an SVG:\n\n```html\n<template id=\"clock\">\n    <svg style=\"transform: rotate(${ round(data.time) * 6 + 'deg'});\" viewBox=\"0 0 24 24\">\n        <circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"white\" />\n        <line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"1\" />\n    </svg>\n    <p>You loaded this <b>${ round(data.time) + 's' }</b> ago.</p>\n</template>\n\n<include-literal src=\"#clock\" data=\"./data/dom-clock.js\">\n    <p>You loaded this.</p>\n</include-literal>\n```\n\nAnd the result is:\n\n<template id=\"clock\">\n    <svg style=\"transform: rotate(${ round(data.time) * 6 + 'deg'});\" viewBox=\"0 0 24 24\" width=\"32\" height=\"32\">\n        <circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"white\" stroke-width=\"2\" />\n        <line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"1\" stroke-width=\"1\" />\n    </svg>\n    <p>You loaded this <b>${ round(data.time) + 's' }</b> ago.</p>\n</template>\n\n<include-literal src=\"#clock\" data=\"./data/dom-clock.js\">\n    <p>You loaded this.</p>\n</include-literal>\n**/\n\n/*\nContents\n- <a href=\"#include-literal\">`<include-literal>`</a>\n- <a href=\"#template-functions\">Literal template functions</a>\n*/\n\n/* Importing include-literal registers – and instantiates – <include-literal> */\nimport './elements/include-html.js';\nimport './elements/include-literal.js';\nexport { cache as compiled } from './modules/compile.js';\n\nimport { register } from './modules/library.js';\nexport { register };\n\nimport analytics from './modules/analytics.js';\nexport { analytics };\n\nimport events      from '../dom/modules/events.js';\nimport trigger     from '../dom/modules/trigger.js';\nimport rect        from '../dom/modules/rect.js';\nimport select      from '../dom/modules/select.js';\nimport request     from './library/request.js';\nimport includeHTML from './library/include-html.js';\n\nregister('events',  events);\nregister('trigger', trigger);\nregister('select',  select);\nregister('rect',    rect);\nregister('request', request);\nregister('includeHTML', includeHTML);\n\nexport { Observer }  from '../fn/observer/observer.js';\nexport { default as observe } from '../fn/observer/observe.js';\n\nexport default function Literal(id) {\n    return new TemplateRenderer(id);\n}\n\nLiteral.stats = analytics;\n\nif (window.DEBUG) {\n    window.Literal = Literal;\n}\n"],
  "mappings": "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",
  "names": []
}
