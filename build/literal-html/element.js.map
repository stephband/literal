{
  "version": 3,
  "sources": ["https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/exec.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/capture.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/to-load-promise.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/to-prefetch-promise.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element/internals.js", "https://cdn.jsdelivr.net/gh/stephband/dom@master/modules/element.js", "../../modules/dom/assign-dataset.js", "https://cdn.jsdelivr.net/gh/stephband/fn@master/modules/cache-by-key.js", "../../modules/request-data.js", "../../literal-html/element.js"],
  "sourcesContent": ["\n/**\nexec(regex, fn, string)\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n**/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + (string.length > 128 ? string.length.slice(0, 128) + '…' : string) + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "\n/**\ntoLoadPromise(element)\n**/\n\nconst onceEvent = { once: true };\n\nexport default function toLoadPromise(element) {\n    return new Promise((resolve, reject) => {\n        element.addEventListener('load', resolve, onceEvent);\n        element.addEventListener('error', reject, onceEvent);\n    });\n}\n", "\n/**\ntoPrefetchPromise(url)\nGenerate a promise of <link rel=\"preload\"> load state for each URL. Currently\nsupports prefetching stylesheets only. (TODO: Parse url for file extension)\n**/\n\nimport cache         from 'fn/cache.js';\nimport create        from '../create.js';\nimport toLoadPromise from './to-load-promise.js';\n\nexport default cache((url) => {\n    if (!url || url.includes('undefined')) {\n        throw new Error('ERRR?')\n    }\n    const link    = create('link', { rel: 'preload', as: 'style', href: url });\n    const promise = toLoadPromise(link);\n    document.head.append(link);\n    return promise;\n});\n", "\n\nimport create from '../create.js';\n\nconst $internals = Symbol('internals');\n\nfunction attachInternals(element) {\n    var internals;\n\n    // Use native attachInternals where it exists\n    if (element.attachInternals) {\n        internals = element.attachInternals();\n        if (internals.setFormValue) {\n            return internals;\n        }\n    }\n    else {\n        internals = {\n            shadowRoot: elem.shadowRoot\n        };\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however – it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    internals.polyfillInput = create('input', { type: 'hidden', name: elem.name });\n    elem.appendChild(internals.polyfillInput);\n\n    // Polyfill internals object setFormValue\n    internals.setFormValue = function(value) {\n        this.input.value = value;\n    };\n\n    return internals;\n}\n\nexport function createInternals(Element, element, shadow) {\n    return (element[$internals] = Element.formAssociated ?\n        attachInternals(element) :\n        { shadowRoot: shadow }\n    );\n}\n\nexport function getInternals(element) {\n    // Default to an empty object\n    return element[$internals];// || (element[$internals] = {});\n}\n", "\n/**\nelement(tag, lifecycle, properties, stylesheet, message)\n\nRegisters a custom element `tag` and returns its constructor.\n\n- `tag`: A string in the form `'custom-name'`, `'<custom-name>'`,\n`'tag is=\"custom-name\"'` or `'<tag is=\"custom-name\">'`\n- `lifecycle`: `{\n    mode:       'open' or 'closed'\n    focusable:  true or false\n    shadow:     html string or '#template-id' or fragment\n\n    // Styleheet\n    stylesheet: optional string path to stylesheet for shadow DOM\n\n    // Lifecycle handlers\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n\n    // Form elements\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}`\n- `properties`: `{\n    name: {\n        construct: fn called before lifecycle.construct\n        attribute: fn called on `element.setAttribute('name', ...)`\n        set:       fn called on setting property 'name'\n        get:       fn called on getting property 'name'\n    }\n}`\n- `stylesheet`: url of a stylesheet to load in to the shadow DOM\n- `message`: optional debug message to logged when element is registered\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in\nbrowsers that support the feature. Safari does not, but support is somewhat\npolyfilled. Mileage will vary.\n\n#### Lifecycle\n\nLifecycle handlers are called with the element as `this` and with the parameters\n`shadow` and `internals`.\n\nOn initialisation the `construct` handler is called. Set up the shadow root and\ndefine event handlers here. Children and attributes must not be inspected or\nassigned at this point: doing so will throw an error when constructed via\n`document.createElement()`.\n\nFollowing that, attribute handlers in `properties` are called for attributes\ndeclared in the HTML. The HTML parser normally calls these in source order.\n\nThen the `connect` handler is called when the element is placed in the DOM, or\nif it is already in the DOM and is being upgraded.\n\nBoth `load` and `slotchange` are asynchronous. Things get a little tricky here.\nThe order of `load` callbacks and `'slotchange'` listeners cannot be guaranteed\nin Safari. When there is an empty cache `slotchange` comes first, as it always\ndoes in other browsers, otherwise `load` happens first.\n\nWhere there is a stylesheet loading, most browsers call `'slotchange'` listeners\n(asynchronously) before `load` – except Safari, where if the stylesheet is\nalready cached `load` is called before `'slotchange'` listeners. (TODO: I would\nlike to guarantee `slotchange` before `load`, but it is not clear how to delay\n`load`... if there is no slotted content, `slotchange` may not be called at\nall...)\n\nFinally, `connect` and `disconnect` are called whenever the element is inserted\ninto or removed from the DOM.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\n### Properties\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser\nsupport.\n*/\n\nimport capture           from 'fn/capture.js';\nimport create            from './create.js';\nimport toLoadPromise     from './element/to-load-promise.js';\nimport toPrefetchPromise from './element/to-prefetch-promise.js';\nimport { createInternals, getInternals } from './element/internals.js';\n\nconst define  = Object.defineProperties;\nconst nothing = {};\n\nconst constructors = {\n    // We need list only those whose constructor names do not match their tag\n    'a':        HTMLAnchorElement,\n    'article':  HTMLElement,\n    'dl':       HTMLDListElement,\n    'p':        HTMLParagraphElement,\n    'br':       HTMLBRElement,\n    'fieldset': HTMLFieldSetElement,\n    'hr':       HTMLHRElement,\n    'img':      HTMLImageElement,\n    'li':       HTMLLIElement,\n    'ol':       HTMLOListElement,\n    'optgroup': HTMLOptGroupElement,\n    'q':        HTMLQuoteElement,\n    'section':  HTMLElement,\n    'textarea': HTMLTextAreaElement,\n    'td':       HTMLTableCellElement,\n    'th':       HTMLTableCellElement,\n    'tr':       HTMLTableRowElement,\n    'tbody':    HTMLTableSectionElement,\n    'thead':    HTMLTableSectionElement,\n    'tfoot':    HTMLTableSectionElement,\n    'ul':       HTMLUListElement\n};\n\nconst formProperties = {\n    // These properties echo those provided by native form controls.\n    // They are not strictly required, but provided for consistency.\n    //type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function()     { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get:   function() { return getInternals(this).form; }},\n    labels:            { get:   function() { return getInternals(this).labels; }},\n    validity:          { get:   function() { return getInternals(this).validity; }},\n    validationMessage: { get:   function() { return getInternals(this).validationMessage; }},\n    willValidate:      { get:   function() { return getInternals(this).willValidate; }},\n    checkValidity:     { value: function() { return getInternals(this).checkValidity(); }},\n    reportValidity:    { value: function() { return getInternals(this).reportValidity(); }}\n};\n\nconst shadowParameterIndex = 0;\n\nlet supportsCustomisedBuiltIn = false;\n\nfunction getElementConstructor(tag) {\n        // Return a constructor from the known list of tag names – not all tags\n        // have constructor names that match their tags\n    return constructors[tag]\n        // Or assemble the tag name in the form \"HTMLTagElement\" and return\n        // that property of the window object\n        || window['HTML' + tag[0].toUpperCase() + tag.slice(1) + 'Element']\n        || (() => {\n            throw new Error('Constructor not found for tag \"' + tag + '\"');\n        })();\n}\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst parseNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w-]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is[=\\s]*[\"']?([a-z][\\w]*-[\\w-]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n\n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() – name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nfunction constructProperty(element, descriptor) {\n    if (descriptor.construct) descriptor.construct.apply(element);\n    return element;\n}\n\nfunction transferProperty(element, key) {\n    if (element.hasOwnProperty(key)) {\n        const value = element[key];\n        delete element[key];\n        element[key] = value;\n    }\n    return element;\n}\n\nfunction createShadow(elem, options, stylesheet) {\n    // Create a shadow root. Shadows may be 'open' or 'closed'. Closed shadows\n    // are not exposed via element.shadowRoot, and events propagating from\n    // inside of them report the element as target. Default to 'closed'.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: stylesheet });\n        shadow.append(link);\n    }\n\n    return shadow;\n}\n\nfunction fillShadowFromTemplate(shadow, template) {\n    // It's a string\n    if (typeof template === 'string') {\n        // It's an id of a template\n        if (template[0] === '#') {\n            shadow.appendChild(\n                document.getElementById(template.slice(1))\n                .content.clone(true)\n            );\n        }\n        // It's html\n        else {\n            shadow.innerHTML = template;\n        }\n    }\n    // It's a <template>\n    else {\n        shadow.appendChild(template.content.clone(true));\n    }\n\n    return shadow;\n}\n\nfunction hasPropertyAttribute(option) {\n    return !!option.attribute;\n}\n\nfunction hasPropertyDefinition(option) {\n    return option.set || option.get || option.hasOwnProperty('value');\n}\n\nfunction groupAttributeProperty(data, entry) {\n    if (hasPropertyAttribute(entry[1])) {\n        data.attributes[entry[0]] = entry[1].attribute;\n    }\n\n    if (hasPropertyDefinition(entry[1])) {\n        data.properties[entry[0]] = entry[1];\n    }\n\n    return data;\n}\n\nexport default function element(definition, lifecycle, api, stylesheet, log = '') {\n    const { name, tag } = parseNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    const { attributes, properties } = api ?\n        Object.entries(api).reduce(groupAttributeProperty, {\n            attributes: {},\n            properties: {}\n        }) :\n        nothing ;\n\n    function Element() {\n        // Construct an instance from Constructor using the Element prototype\n        const element = Reflect.construct(constructor, arguments, Element);\n\n        // Make shadow if mode or template have been set\n        const shadow = lifecycle.mode || lifecycle.shadow ?\n            createShadow(element, lifecycle, stylesheet || lifecycle.stylesheet) :\n            undefined ;\n\n        // Fill shadow with template\n        if (lifecycle.shadow) {\n            fillShadowFromTemplate(shadow, lifecycle.shadow);\n        }\n\n        // Get access to the internals object. If form associated, internals is\n        // the form control API internals object. We're gonna be rude and\n        // extend it.\n        const internals = createInternals(Element, element, shadow);\n        const params = internals.params = [shadow, internals];\n\n        // Flag unconnected until first connect\n        internals.unconnected = true;\n\n        // Flag support for custom built-ins. We know this when tag exists and\n        // Element constructor is called\n        if (tag) supportsCustomisedBuiltIn = true;\n\n        if (properties) {\n            // Loop over property descriptors and call descriptor construct()\n            // function if it exists\n            Object.values(properties).reduce(constructProperty, element);\n        }\n\n        if (lifecycle.construct) lifecycle.construct.apply(element, params);\n\n        // At this point, if properties have been set before the element was\n        // upgraded they already exist on the element itself, where we have\n        // just upgraded it's protytype to define those properties. Those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype, as in\n        //    Object.defineProperties(element, properties);\n        //\n        // 2. Take a great deal of care when authoring not to set properties\n        //    before an element is upgraded. We can't impose a restriction like that.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy we have to do this, though.\n        if (properties) {\n            Object.keys(properties).reduce(transferProperty, element);\n        }\n\n        // Avoid flash of unstyled content in shadow DOMs that must load assets.\n        if (shadow) {\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                // Hide all content other than the default slot until stylesheets\n                // have loaded. We keep the default slot visible as that content\n                // was visible before upgrade and we do not want it to momentarily\n                // disappear.\n                const style = create('style', '*:not(:has(slot:not([name]))) { display: none !important; }');\n                shadow.append(style);\n\n                internals.stylesheetsLoadPromise = Promise\n                .all(Array.from(links, toLoadPromise))\n                .finally(() => style.remove());\n            }\n        }\n\n        return element;\n    }\n\n    // Prefetch stylesheet\n    if (stylesheet) {\n        toPrefetchPromise(stylesheet);\n        log = window.DEBUG ?\n            log + ' – stylesheet ' + stylesheet :\n            log ;\n    }\n\n    // Properties\n\n    // Must be defined before attributeChangedCallback, but I cannot figure out\n    // why. Where one of the properties is `value`, the element is set up as a\n    // form element.\n    Element.prototype = Object.create(constructor.prototype, properties) ;\n\n    if (properties && properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n\n        // Define standard form properties\n        define(Element.prototype, formProperties);\n\n        if (lifecycle.enable || lifecycle.disable) {\n            Element.prototype.formDisabledCallback = function(disabled) {\n                const internals = getInternals(this);\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.apply(this, internals.params) :\n                    lifecycle.enable && lifecycle.enable.apply(this, internals.params) ;\n            };\n        }\n\n        if (lifecycle.reset) {\n            Element.prototype.formResetCallback = function() {\n                const internals = getInternals(this);\n                return lifecycle.reset.apply(this, internals.params);\n            };\n        }\n\n        if (lifecycle.restore) {\n            Element.prototype.formStateRestoreCallback = function() {\n                const internals = getInternals(this);\n                const params    = internals.params;\n                return lifecycle.restore.apply(this, internals.params);\n            };\n        }\n    }\n\n\n    // Attributes\n\n    if (attributes) {\n        Element.observedAttributes = Object.keys(attributes);\n        Element.prototype.attributeChangedCallback = function(name, old, value) {\n            return attributes[name].call(this, value) ;\n        };\n    }\n\n\n    // Lifecycle\n\n    Element.prototype.connectedCallback = function() {\n        const internals = getInternals(this);\n\n        // If we have simulated form internals (for Safari), append the hidden\n        // input now\n        if (internals.polyfillInput) {\n            elem.appendChild(internals.polyfillInput);\n        }\n\n        // If this is the first connect and there is a lifecycle.load fn,\n        // unconnected is true\n        if (internals.unconnected) {\n            if (lifecycle.load && internals.stylesheetsLoadPromise) {\n                internals.stylesheetsLoadPromise.then(() =>\n                    lifecycle.load.apply(this, internals.params)\n                );\n            }\n            else if (lifecycle.load) {\n                // Guarantee that lifecycle load is called asynchronously in\n                // cases where there is nothing to load\n                Promise.resolve().then(() =>\n                    lifecycle.load.apply(this, internals.params)\n                );\n            }\n\n            delete internals.unconnected;\n        }\n\n        lifecycle.connect && lifecycle.connect.apply(this, internals.params);\n    }\n\n    if (lifecycle.disconnect) {\n        Element.prototype.disconnectedCallback = function() {\n            const internals = getInternals(this);\n            return lifecycle.disconnect.apply(this, internals.params);\n        };\n    }\n\n    // Log registration to console\n    window.console &&\n    window.console.log('%c<' + (tag ? tag + ' is=' + name + '' : name) + '>%c ' + log, 'color:#3a8ab0;font-weight:600;', 'color:#888888;font-weight:400;');\n\n    // Define the element\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n    // Safari partial polyfill.\n    // Where tag is supplied, element should have been registered as a customised\n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to\n    // go some way towards filling in support by searching for elements and\n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        if (window.DEBUG) {\n            console.warn('Browser does not support customised built-in elements, polyfilling <' + tag + ' is=\"' + name + '\">');\n        }\n\n        document.querySelectorAll('[is=\"' + name + '\"]').forEach((element) => {\n            // Define properties on element\n            if (properties) {\n                define(element, properties);\n            }\n\n            // Construct an instance from Constructor using the Element prototype\n            const shadow = lifecycle.mode || lifecycle.shadow ?\n                createShadow(element, lifecycle, stylesheet || lifecycle.stylesheet) :\n                undefined ;\n\n            // Get access to the internals object\n            const internals = createInternals(Element, element, shadow);\n\n            // Run constructor\n            lifecycle.construct && lifecycle.construct.call(element, shadow, internals);\n\n            // Detect and run attributes\n            let name;\n            for (name in attributes) {\n                // elements.attributes is sometimes undefined... why?\n                const attribute = element.attributes[name];\n                if (attribute) {\n                    attributes[name].call(element, attribute.value);\n                }\n            }\n\n            // Run connected callback\n            lifecycle.connect && lifecycle.connect.call(element, shadow, internals);\n        });\n    }\n\n    return Element;\n}\n\nexport { getInternals };\n", "\nfunction parseData(value) {\n    try {\n        return JSON.parse(value);\n    }\n    catch(e) {\n        return value;\n    }\n}\n\nexport default function assignDataset(object, dataset) {\n    const keys   = Object.keys(dataset);\n    const values = Object.values(dataset);\n\n    return values\n    .map(parseData)\n    .reduce((object, value, i) => (object[keys[i]] = value, object), object);\n}\n", "/**\ncacheByKey(fn)\nReturns a function that caches the output values of `fn(input)` against input\nvalues, which are registered as keys in an object, such that for each input\nkey `fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cacheByKey(fn) {\n    var map = {};\n\n    return function cache(input) {\n        /*if (window.DEBUG && !warned && input === undefined) {\n            warned = true;\n            console.warn('cacheByKey() called with undefined. Not illegal, but potentially bad.');\n        }\n\n        if (window.DEBUG && typeof input !== 'string' && typeof input !== 'number') {\n            console.warn('cacheByKey() called with non-primitive input, coerced to string \"' + input + '\"');\n        }*/\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cacheByKey() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        return input in map ?\n            map[input] :\n            map[input] = fn(input) ;\n    };\n}\n", "\n/**\nrequestData(url)\n\nTakes a `url` pointing to either a `.json` file (in which case it fetches and\nparses it) or a `.js` file (which it imports as a module), and returns a\npromise of the result.\n\n```\nrequestData('./path/to/data.json');\n```\n\nWhere a `url` to a module is a relative URL it is normalised to `window.location`\nso that imports written in templates are treated correctly (dynamic `import()`\nwould otherwise try and import relative to this module).\n\n```\nrequestData('./path/to/module.js');\n```\n\nBy default a module request imports the default export. If `url` contains a\n`#fragment` identifier, the named export corresponding to the identifier is\nimported.\n\n```\nrequestData('./path/to/module#named');\n```\n**/\n\n/*\nIf the fragment identifier is also post-fixed with parameters then that named\nexport is treated as a constructor function and called:\n\n```\nrequestData('./path/to/module#named(\"parameter\")');\n```\n\nTo construct a default export use the name `default`:\n\n```\nrequestData('./path/to/module#default(\"parameter\")');\n```\n*/\n\nimport get            from 'fn/get.js';\nimport overload       from 'fn/overload.js';\nimport cache          from 'fn/cache-by-key.js';\nimport { rewriteURL } from './urls.js';\n\nconst rextension = /\\.([\\w-]+)(?:#|\\?|$)/;\nconst empty      = [];\n\nconst request = overload((url) => (rextension.exec(url.pathname) || empty)[1], {\n    js: cache((url) => {\n        // Get named import from hash\n        const src  = url.origin + url.pathname + url.search;\n        const name = url.hash.slice(1) || 'default';\n        // Return promise of imported named module\n        return import(src).then(get(name));\n    }),\n\n    default: cache((url) => fetch(url).then((response) => {\n        if (!response.ok) {\n            throw new Error(`Literal failed to fetch data – ${response.status}`);\n        }\n\n        return response.json();\n    }))\n});\n\nexport default function requestData(path) {\n    // Get rewritten URL\n    const url = rewriteURL(path);\n\n    // Return promise of data\n    return request(url);\n}\n", "\n/**\n<template is=\"literal-html\">\n\nA `literal-html` template may be placed anywhere in your HTML. It is designed to\nmake it easy to mix islands of dynamically rendered content into static content.\n\nA `literal-html` template is replaced in the DOM with it's own rendered content.\n\nNote that templates declared as shadow roots with the `shadowrootmode=\"open\"` or\n`shadowrootmode=\"closed\"` attribute cannot also be `is=\"literal-html\"` templates:\nthe HTML parser picks them up and treats them as shadows before the custom\nelement registry can upgrade them: they cannot be enhanced, sadly.\n**/\n\n\nimport Data           from 'fn/data.js';\nimport element, { getInternals } from 'dom/element.js';\nimport assignDataset  from '../modules/dom/assign-dataset.js';\nimport requestData    from '../modules/request-data.js';\nimport Template       from '../modules/template.js';\nimport Literal        from '../modules/literal.js';\nimport { printError } from '../modules/print.js';\n\n\nexport default element('<template is=\"literal-html\">', {\n    construct: function(shadow, state) {\n        state.template = Template.fromTemplate(this);\n        // Debugging info for printError()\n        if (window.DEBUG) state.code = `<template is=\"literal-html\" id=\"${ this.id }\">`;\n    },\n\n    connect: function(shadow, state) {\n        const { renderer } = state;\n\n        // If src or data was not set use data found in dataset\n        if (!state.connected && !state.promise && !state.renderer) {\n            state.connected = true;\n            this.data = assignDataset({}, this.dataset);\n        }\n    }\n}, {\n    /**\n    src=\"\"\n    A path to a JSON file or JS module exporting data to be rendered.\n\n    ```html\n    <template is=\"literal-html\" src=\"./data.json\">...</template>\n    <template is=\"literal-html\" src=\"./module.js\">...</template>\n    ```\n\n    Named exports are supported via an identifier:\n\n    ```html\n    <template is=\"literal-html\" data=\"./module.js#namedExport\">...</template>\n    ```\n    **/\n    src: {\n        attribute: function(url) {\n            this.src = url;\n        },\n\n        get: function() {\n            return getInternals(this).src;\n        },\n\n        set: function(url) {\n            const state = getInternals(this);\n            state.src = url;\n\n            // Cancel existing promise of data\n            if (state.promise) {\n                state.promise.cancelled = true;\n                state.promise = undefined;\n            }\n\n            // Set state.promise\n            const p = requestData(url)\n            .then((data) => { if (!p.cancelled) this.data = data; })\n            .catch((error) => this.replaceWith(printError(state, error)));\n\n            state.promise = p;\n        }\n    },\n\n\n    /**\n    .data\n\n    The `data` property may be set to an object.\n\n    Getting the `data` property returns the object currently being rendered.\n    Sort of. The returned data object is actually a _proxy_ of the set object.\n    This data proxy monitors mutations which the Literal template is already\n    observing, so changes to this data are reflected in the DOM immediately\n    (well, not quite immediately – literal renders changes on the next frame).\n    **/\n    data: {\n        attribute: function(json) {\n            this.data = JSON.parse(json);\n        },\n\n        get: function() {\n            const state = getInternals(this);\n            return state.renderer && state.renderer.data;\n        },\n\n        set: function(object) {\n            const state = getInternals(this);\n\n            if (state.renderer) state.renderer.remove();\n            if (!object) return;\n            state.renderer = new Literal(\n                state.template,\n                object,\n                { element: this.parentElement }\n            );\n\n            this.replaceWith(state.renderer.fragment);\n        }\n    }\n\n\n    /**\n    .consts=\"\"\n    A list of property names found on `data` that are set as consts inside the\n    template.\n    **/\n    // No definition for consts, it's picked up by Template.fromTemplate()\n}, 'stephen.band/literal/');\n"],
  "mappings": "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",
  "names": ["exec", "regex", "fn", "string", "data", "tokens", "output", "exec_default", "curry_default", "error", "regex", "reducers", "string", "reduce", "acc", "tokens", "n", "capture", "output", "exec", "capture_default", "curry_default", "onceEvent", "toLoadPromise", "element", "resolve", "reject", "to_prefetch_promise_default", "cacheByObject", "url", "link", "create_default", "promise", "toLoadPromise", "$internals", "attachInternals", "element", "internals", "create_default", "value", "createInternals", "Element", "shadow", "getInternals", "define", "nothing", "constructors", "formProperties", "name", "getInternals", "supportsCustomisedBuiltIn", "getElementConstructor", "tag", "constructors", "parseNameTag", "capture_default", "data", "captures", "name", "constructProperty", "element", "descriptor", "transferProperty", "key", "value", "createShadow", "elem", "options", "stylesheet", "shadow", "link", "create_default", "fillShadowFromTemplate", "template", "hasPropertyAttribute", "option", "hasPropertyDefinition", "groupAttributeProperty", "entry", "definition", "lifecycle", "api", "log", "constructor", "attributes", "properties", "nothing", "Element", "internals", "createInternals", "params", "links", "style", "toLoadPromise", "to_prefetch_promise_default", "define", "formProperties", "disabled", "getInternals", "old", "attribute", "parseData", "value", "assignDataset", "object", "dataset", "keys", "i", "cacheByKey", "fn", "map", "input", "rextension", "empty", "request", "overload", "url", "cacheByKey", "src", "name", "get_default", "response", "requestData", "path", "rewriteURL", "element_default", "element", "shadow", "state", "Template", "renderer", "assignDataset", "url", "getInternals", "p", "requestData", "data", "error", "printError", "json", "object", "Literal"]
}
