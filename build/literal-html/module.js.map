{
  "version": 3,
  "sources": ["../../../fn/modules/exec.js", "../../../fn/modules/capture.js", "../../../dom/modules/element/internals.js", "../../../dom/modules/element.js", "../../modules/dom/assign-dataset.js", "../../../fn/modules/cache-by-key.js", "../../modules/request-data.js", "../../literal-html/module.js"],
  "sourcesContent": ["\n/**\nexec(regex, fn, string)\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n**/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + (string.length > 128 ? string.length.slice(0, 128) + '…' : string) + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "\n\nimport create from '../create.js';\n\nconst $internals = Symbol('internals');\n\n// TODO: No longer needed polyfill for Safari... ??\n/*\nfunction attachInternals(element) {\n    var internals;\n\n    // Use native attachInternals where it exists and we have the right to use\n    // it - you cannot attachInternals to customised built-ins\n    if (element.attachInternals && !element.getAttribute('is')) {\n        return element.attachInternals();\n        //if (internals.setFormValue) return internals;\n    }\n    else {\n        internals = {\n            shadowRoot: elem.shadowRoot\n        };\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however – it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    //internals.polyfillInput = create('input', { type: 'hidden', name: elem.name });\n    //elem.appendChild(internals.polyfillInput);\n    // Polyfill internals object setFormValue\n    //internals.setFormValue = function(value) {\n    //    this.input.value = value;\n    //};\n\n    return internals;\n}\n\nexport function createInternals(Element, element, shadow) {\n    return (element[$internals] = Element.formAssociated ?\n        attachInternals(element) :\n        { shadowRoot: shadow }\n    );\n}\n*/\n\nexport function createInternals(Element, element, shadow) {\n    return element[$internals] = (element.attachInternals && !element.getAttribute('is')) ?\n        element.attachInternals() :\n        { shadowRoot: shadow } ;\n}\n\nexport function getInternals(element) {\n    return element[$internals];\n}\n", "\n/**\nelement(tag, lifecycle, properties, stylesheet, message)\n\nRegisters a custom element `tag` and returns its constructor.\n\n- `tag`: A string in the form `'custom-name'`, `'<custom-name>'`,\n`'tag is=\"custom-name\"'` or `'<tag is=\"custom-name\">'`\n- `lifecycle`: `{\n    mode:       'open' or 'closed'\n    focusable:  true or false\n    shadow:     html string or '#template-id' or fragment\n\n    // Styleheet\n    stylesheet: optional string path to stylesheet for shadow DOM\n\n    // Lifecycle handlers\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n\n    // Form elements\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}`\n- `properties`: `{\n    name: {\n        construct: fn called before lifecycle.construct\n        attribute: fn called on `element.setAttribute('name', ...)`\n        set:       fn called on setting property 'name'\n        get:       fn called on getting property 'name'\n    }\n}`\n- `stylesheet`: url of a stylesheet to load in to the shadow DOM\n- `message`: optional debug message to logged when element is registered\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in\nbrowsers that support the feature. Safari does not, but support is somewhat\npolyfilled. Mileage will vary.\n\n#### Lifecycle\n\nLifecycle handlers are called with the element as `this` and with the parameters\n`shadow` and `internals`.\n\nOn initialisation the `construct` handler is called. Set up the shadow root and\ndefine event handlers here. Children and attributes must not be inspected or\nassigned at this point: doing so will throw an error when constructed via\n`document.createElement()`.\n\nFollowing that, attribute handlers in `properties` are called for attributes\ndeclared in the HTML. The HTML parser normally calls these in source order.\n\nThen the `connect` handler is called when the element is placed in the DOM, or\nif it is already in the DOM and is being upgraded.\n\nBoth `load` and `slotchange` are asynchronous. Things get a little tricky here.\nThe order of `load` callbacks and `'slotchange'` listeners cannot be guaranteed\nin Safari. When there is an empty cache `slotchange` comes first, as it always\ndoes in other browsers, otherwise `load` happens first.\n\nWhere there is a stylesheet loading, most browsers call `'slotchange'` listeners\n(asynchronously) before `load` – except Safari, where if the stylesheet is\nalready cached `load` is called before `'slotchange'` listeners. (TODO: I would\nlike to guarantee `slotchange` before `load`, but it is not clear how to delay\n`load`... if there is no slotted content, `slotchange` may not be called at\nall...)\n\nFinally, `connect` and `disconnect` are called whenever the element is inserted\ninto or removed from the DOM.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\n### Properties\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser\nsupport.\n*/\n\nimport capture  from 'fn/capture.js';\nimport id       from 'fn/id.js';\nimport noop     from 'fn/noop.js';\nimport overload from 'fn/overload.js';\nimport create   from './create.js';\nimport { createInternals, getInternals } from './element/internals.js';\n\n\nconst define         = Object.defineProperties;\nconst nothing        = {};\nconst constructors   = {};\nconst formProperties = {\n    // These properties echo those provided by native form controls. They are\n    // not strictly required, but provided for consistency with standard form\n    // elements.\n\n    //type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function()     { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get:   function() { return getInternals(this).form; }},\n    labels:            { get:   function() { return getInternals(this).labels; }},\n    validity:          { get:   function() { return getInternals(this).validity; }},\n    validationMessage: { get:   function() { return getInternals(this).validationMessage; }},\n    willValidate:      { get:   function() { return getInternals(this).willValidate; }},\n    checkValidity:     { value: function() { return getInternals(this).checkValidity(); }},\n    reportValidity:    { value: function() { return getInternals(this).reportValidity(); }}\n};\n\n\nlet supportsCustomisedBuiltIn = false;\n\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst parseNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w-]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is[=\\s]*[\"']?([a-z][\\w]*-[\\w-]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n\n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() – name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nconst onceEvent = { once: true };\n\nfunction toLoadPromise(element) {\n    return !!element.sheet ?\n        // Link has already loaded\n        Promise.resolve({ target: element }) :\n        // Wait for load\n        new Promise((resolve, reject) => {\n            element.addEventListener('load', resolve, onceEvent);\n            element.addEventListener('error', reject, onceEvent);\n        }) ;\n}\n\nfunction stop(object) {\n    object.stop();\n}\n\nfunction getElementConstructor(tag) {\n    if (constructors[tag]) return constructors[tag];\n\n    const constructor = document.createElement(tag).constructor;\n    if (constructor === HTMLUnknownElement) {\n        throw new Error('Cannot define customised built-in - constructor for <' + tag + '> is HTMLUnknownElement');\n    }\n\n    return constructors[tag] = constructor;\n}\n\nfunction transferProperty(element, key) {\n    if (element.hasOwnProperty(key)) {\n        const value = element[key];\n        delete element[key];\n        element[key] = value;\n    }\n    return element;\n}\n\nfunction createShadow(elem, options) {\n    // Create a shadow root. Shadows may be 'open' or 'closed'. Closed shadows\n    // are not exposed via element.shadowRoot, and events propagating from\n    // inside of them report the element as target. Default to 'closed'.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (options.stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: options.stylesheet });\n        shadow.append(link);\n    }\n\n    return shadow;\n}\n\nfunction fillShadowFromTemplate(shadow, template) {\n    // It's a string\n    if (typeof template === 'string') {\n        // It's an id of a template\n        if (template[0] === '#') {\n            shadow.appendChild(\n                document.getElementById(template.slice(1))\n                .content.clone(true)\n            );\n        }\n        // It's html\n        else {\n            shadow.innerHTML = template;\n        }\n    }\n    // It's a <template>\n    else {\n        shadow.appendChild(template.content.clone(true));\n    }\n\n    return shadow;\n}\n\nfunction isNotUpgraded(element) {\n    /* Detect marked as upgraded, mark if not */\n    const upgraded = element.isUpgraded;\n    element.isUpgraded = true;\n    return !upgraded;\n}\n\nfunction findByIs(root, name) {\n    return Array\n    .from(root.querySelectorAll('[is=\"' + name + '\"]'))\n    .filter(isNotUpgraded);\n}\n\nconst createDescriptor = overload((name, options) => typeof options, {\n    object:   (name, descriptor) => descriptor,\n    function: (name, fn) => ({ value: fn }),\n    default:  (name, options) => {\n        throw new TypeError('element() does not accept property descriptor of type ' + typeof options);\n    }\n});\n\nexport default function element(definition, lifecycle = {}, properties = {}, log = '') {\n    const { name, tag } = parseNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    // Split properties into attributes and property descriptors\n    const attributes  = [];\n    const descriptors = {};\n\n    let propname, descriptor;\n    for (propname in properties) {\n        descriptor = createDescriptor(propname, properties[propname]);\n\n        // Add name to list of observed attributes\n        if (descriptor.attribute) attributes.push(propname);\n\n        // Add descriptor to properties to be defined\n        if (descriptor.set || descriptor.get || 'value' in descriptor) descriptors[propname] = descriptor;\n\n        // Override property descriptor\n        properties[propname] = descriptor;\n    }\n\n    // Declare constructor\n    function Element() {\n        // Construct an instance from Constructor using Element prototype\n        const element = Reflect.construct(constructor, arguments, Element);\n\n        // Make shadow if mode or shadow have been set\n        const shadow = (lifecycle.mode || (typeof lifecycle.shadow === 'string')) ?\n            createShadow(element, lifecycle) :\n            undefined ;\n\n        // Fill shadow with template\n        if (lifecycle.shadow) fillShadowFromTemplate(shadow, lifecycle.shadow);\n\n        // Get access to the internals object. If form associated, internals is\n        // the form control API internals object. We're gonna be rude and\n        // extend it.\n        const internals = createInternals(Element, element, shadow);\n\n        // Flag support for custom built-ins. We know this when tag exists and\n        // Element constructor is called\n        if (tag) supportsCustomisedBuiltIn = true;\n        if (lifecycle.construct) lifecycle.construct.call(element, shadow, internals);\n\n        // At this point, if properties have been set before the element was\n        // upgraded they already exist on the element itself, where we have\n        // just upgraded it's protytype to define those properties. Those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype, as in\n        //    Object.defineProperties(element, descriptors) here in the\n        //    constructor. Won't actually solve the problem.\n        //\n        // 2. Take a great deal of care when authoring not to set properties\n        //    before an element is upgraded. We can't impose a restriction like\n        //    that on Joe Bloggs front end developer.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy we have to do this, though.\n        Object.keys(descriptors).reduce(transferProperty, element);\n\n        return element;\n    }\n\n    // Set prototype and define properties\n    Element.prototype = Object.create(constructor.prototype, descriptors);\n\n    // Prefetch stylesheet ??\n    /*if (stylesheet) {\n        toPrefetchPromise(stylesheet);\n        log = window.DEBUG ?\n            log + ' – stylesheet ' + stylesheet :\n            log ;\n    }*/\n\n    if (properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n\n        // Define standard form properties\n        define(Element.prototype, formProperties);\n\n        if (lifecycle.enable || lifecycle.disable) {\n            Element.prototype.formDisabledCallback = function(disabled) {\n                const internals = getInternals(this);\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.call(this, internals.shadowRoot, internals) :\n                    lifecycle.enable && lifecycle.enable.call(this, internals.shadowRoot, internals) ;\n            };\n        }\n\n        if (lifecycle.reset) {\n            Element.prototype.formResetCallback = function() {\n                const internals = getInternals(this);\n                return lifecycle.reset.call(this, internals.shadowRoot, internals);\n            };\n        }\n\n        if (lifecycle.restore) {\n            Element.prototype.formStateRestoreCallback = function() {\n                const internals = getInternals(this);\n                return lifecycle.restore.call(this, internals.shadowRoot, internals);\n            };\n        }\n    }\n\n    // Attributes\n    if (attributes.length) {\n        Element.observedAttributes = attributes;\n        Element.prototype.attributeChangedCallback = function(name, old, value) {\n            return properties[name].attribute.call(this, value) ;\n        };\n    }\n\n    // Lifecycle\n    if (lifecycle.connect) {\n        Element.prototype.connectedCallback = function() {\n            const internals = getInternals(this);\n            const shadow    = internals.shadowRoot;\n\n            // Connect\n            internals.stopable = lifecycle.connect.call(this, shadow, internals);\n\n            // Avoid flash of unstyled content in shadow DOMs that must load assets.\n            // Now, it's debatable whether this code should be here or in the constructor.\n            // Whether links in the shadow may have already emitted load events by connect\n            // time. They'd have to have done it synchronously, so I don't think so.\n            if (!shadow) return;\n\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                // Hide all content other than the default slot until stylesheets\n                // have loaded. We keep the default slot visible as that content\n                // was visible before upgrade and we do not want it to momentarily\n                // disappear.\n                const style = create('style', '*:not(slot), slot:not([name]) { display: none !important; }');\n                shadow.prepend(style);\n\n                let promise;\n                if (!internals.loadPromise) {\n                    // Wait for stylesheets to load\n                    promise = internals.loadPromise = Promise.all(Array.from(links, toLoadPromise));\n                }\n                else {\n                    // Insert an animation frame to avoid flash on reconnect\n                    promise = internals.loadPromise.then(() => new Promise(requestAnimationFrame));\n                }\n\n                promise.finally(() => {\n                    if (window.DEBUG) window.console.log('%c<' + (tag ? tag + ' is=' + name + '' : name) + '>%c load \\n' + Array.from(links).map((link) => link.href.replace(/https?:\\/\\//, '')).join('\\n'), 'color:#3a8ab0;font-weight:400;', 'color:#888888;font-weight:400;');\n                    // Remove hide style\n                    style.remove();\n                    // and call the load() callback\n                    if (lifecycle.load) lifecycle.load.call(this, shadow, internals);\n                });\n            }\n            else if (lifecycle.load) {\n                lifecycle.load.call(this, shadow, internals);\n            }\n        }\n    }\n\n    Element.prototype.disconnectedCallback = function() {\n        const internals = getInternals(this);\n        if (internals.stopable) {\n            // Support a stopable...\n            if (internals.stopable.stop) { internals.stopable.stop(); }\n            // or an array of stopables\n            else { internals.stopable.forEach(stop); }\n        }\n        if (lifecycle.disconnect) lifecycle.disconnect.call(this, internals.shadowRoot, internals);\n    };\n\n    // Log registration to console\n    window.console &&\n    window.console.log('%c<' + (tag ? tag + ' is=' + name + '' : name) + '>%c ' + log, 'color:#3a8ab0;font-weight:600;', 'color:#888888;font-weight:400;');\n\n    // Define the element\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n\n    // Safari partial polyfill.\n    // Where tag is supplied, element should have been registered as a customised\n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to\n    // go some way towards filling in support by searching for elements and\n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        // It may be there were none in the DOM, in which case we must run a\n        // test. Not ideal.\n        const div = document.createElement('div');\n        div.style.position = 'fixed';\n        div.style.left = '-1000px';\n        div.style.top  = '-1000px';\n        div.innerHTML = '<' + tag + ' is=\"' + name + '\"></' + tag + '>';\n        document.body.append(div);\n        div.remove();\n\n        if (!supportsCustomisedBuiltIn) {\n            if (window.DEBUG) {\n                console.warn('Browser does not support customised built-in elements, polyfilling <' + tag + ' is=\"' + name + '\">');\n            }\n\n            function upgrade(element) {\n                // Store values of properties we are about to define\n                const store = {};\n                Object.keys(descriptors).forEach((key) => {\n                    if (element[key] !== undefined) store[key] = element[key];\n                });\n\n                // Define properties on element\n                define(element, descriptors);\n\n                // Construct an instance from Constructor using the Element prototype\n                const shadow = lifecycle.mode || lifecycle.shadow ?\n                    createShadow(element, lifecycle) :\n                    undefined ;\n\n                // Get access to the internals object\n                const internals = createInternals(Element, element, shadow);\n\n                // Run constructor\n                lifecycle.construct && lifecycle.construct.call(element, shadow, internals);\n\n                if (window.DEBUG) {\n                    // Assign stored properties back onto element\n                    try {\n                        Object.assign(element, store);\n                    }\n                    catch(e) {\n                        console.warn(e.message, tag, Object.keys(store));\n                    }\n                }\n                else {\n                    Object.assign(element, store);\n                }\n\n                // Detect and run attributes\n                let n = -1, name;\n                while (name = attributes[++n]) {\n                    // elements.attributes is sometimes undefined... why?\n                    const attribute = element.attributes[name];\n                    if (attribute) properties[name].attribute.call(element, attribute.value);\n                }\n\n                // Run connected callback\n                lifecycle.connect && lifecycle.connect.call(element, shadow, internals);\n            }\n\n            function polyfillByRoot(root) {\n                findByIs(root, name).forEach(upgrade)\n                const observer = new MutationObserver(() => findByIs(root, name).forEach(upgrade));\n                observer.observe(root, { childList: true, subtree: true });\n            }\n\n            // Expose on element for use in shadow DOMs\n            Element.polyfillByRoot = polyfillByRoot;\n\n            // Run on document automatically\n            polyfillByRoot(document);\n        }\n        else {\n            Element.polyfillByRoot = noop;\n        }\n    }\n    else {\n        Element.polyfillByRoot = noop;\n    }\n\n    return Element;\n}\n\nexport { getInternals };\n", "\nfunction parseData(value) {\n    try {\n        return JSON.parse(value);\n    }\n    catch(e) {\n        return value;\n    }\n}\n\nexport default function assignDataset(object, dataset) {\n    const keys   = Object.keys(dataset);\n    const values = Object.values(dataset);\n\n    return values\n    .map(parseData)\n    .reduce((object, value, i) => (object[keys[i]] = value, object), object);\n}\n", "/**\ncacheByKey(fn)\nReturns a function that caches the output values of `fn(input)` against input\nvalues, which are registered as keys in an object, such that for each input\nkey `fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cacheByKey(fn) {\n    var map = {};\n\n    return function cache(input) {\n        /*if (window.DEBUG && !warned && input === undefined) {\n            warned = true;\n            console.warn('cacheByKey() called with undefined. Not illegal, but potentially bad.');\n        }\n\n        if (window.DEBUG && typeof input !== 'string' && typeof input !== 'number') {\n            console.warn('cacheByKey() called with non-primitive input, coerced to string \"' + input + '\"');\n        }*/\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cacheByKey() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        return input in map ?\n            map[input] :\n            map[input] = fn(input) ;\n    };\n}\n", "\n/**\nrequestData(url)\n\nTakes a `url` pointing to either a `.json` file (in which case it fetches and\nparses it) or a `.js` file (which it imports as a module), and returns a\npromise of the result.\n\n```\nrequestData('./path/to/data.json');\n```\n\nWhere a `url` to a module is a relative URL it is normalised to `window.location`\nso that imports written in templates are treated correctly (dynamic `import()`\nwould otherwise try and import relative to this module).\n\n```\nrequestData('./path/to/module.js');\n```\n\nBy default a module request imports the default export. If `url` contains a\n`#fragment` identifier, the named export corresponding to the identifier is\nimported.\n\n```\nrequestData('./path/to/module#named');\n```\n**/\n\n/*\nIf the fragment identifier is also post-fixed with parameters then that named\nexport is treated as a constructor function and called:\n\n```\nrequestData('./path/to/module#named(\"parameter\")');\n```\n\nTo construct a default export use the name `default`:\n\n```\nrequestData('./path/to/module#default(\"parameter\")');\n```\n*/\n\nimport get            from 'fn/get.js';\nimport overload       from 'fn/overload.js';\nimport cache          from 'fn/cache-by-key.js';\nimport { rewriteURL } from './urls.js';\n\nconst rextension = /\\.([\\w-]+)(?:#|\\?|$)/;\nconst empty      = [];\n\nconst request = overload((url) => (rextension.exec(url.pathname) || empty)[1], {\n    js: cache((url) => {\n        // Get named import from hash\n        const src  = url.origin + url.pathname + url.search;\n        const name = url.hash.slice(1) || 'default';\n        // Return promise of imported named module\n        return import(src).then(get(name));\n    }),\n\n    default: cache((url) => fetch(url).then((response) => {\n        if (!response.ok) {\n            throw new Error(`Literal failed to fetch data – ${response.status}`);\n        }\n\n        return response.json();\n    }))\n});\n\nexport default function requestData(path) {\n    // Get rewritten URL\n    const url = rewriteURL(path);\n\n    // Return promise of data\n    return request(url);\n}\n", "\n/**\n<template is=\"literal-html\">\n\nA `literal-html` template may be placed anywhere in your HTML. It is designed to\nmake it easy to mix islands of dynamically rendered content into static content.\n\nA `literal-html` template is replaced in the DOM with it's own rendered content.\n\nNote that templates declared as shadow roots with the `shadowrootmode=\"open\"` or\n`shadowrootmode=\"closed\"` attribute cannot also be `is=\"literal-html\"` templates:\nthe HTML parser picks them up and treats them as shadows before the custom\nelement registry can upgrade them: they cannot be enhanced, sadly.\n**/\n\n\nimport Data           from 'fn/data.js';\nimport element, { getInternals } from 'dom/element.js';\nimport assignDataset  from '../modules/dom/assign-dataset.js';\nimport requestData    from '../modules/request-data.js';\nimport Template       from '../modules/template.js';\nimport Literal        from '../modules/literal.js';\nimport { printError } from '../modules/print.js';\n\n\nexport default element('<template is=\"literal-html\">', {\n    construct: function(shadow, state) {\n        state.connected = false;\n        state.rendered  = false;\n        state.template  = Template.fromTemplate(this);\n    },\n\n    connect: function(shadow, state) {\n        const { renderer } = state;\n\n        // If src or data was not set use data found in dataset\n        if (!state.connected && !state.promise && !state.renderer) {\n            state.connected = true;\n            this.data = assignDataset({}, this.dataset);\n        }\n    }\n}, {\n    /**\n    src=\"\"\n    A path to a JSON file or JS module exporting data to be rendered.\n\n    ```html\n    <template is=\"literal-html\" src=\"./data.json\">...</template>\n    <template is=\"literal-html\" src=\"./module.js\">...</template>\n    ```\n\n    Named exports are supported via an identifier:\n\n    ```html\n    <template is=\"literal-html\" data=\"./module.js#namedExport\">...</template>\n    ```\n    **/\n    src: {\n        attribute: function(url) {\n            this.src = url;\n        },\n\n        get: function() {\n            return getInternals(this).src;\n        },\n\n        set: function(url) {\n            const state = getInternals(this);\n            state.src = url;\n\n            // Cancel existing promise of data\n            if (state.promise) {\n                state.promise.cancelled = true;\n                state.promise = undefined;\n            }\n\n            // Set state.promise\n            const p = state.promise = requestData(url)\n            .then((data) => {\n                if (p.cancelled) { return; }\n                this.data = data;\n            })\n            .catch((error) => this.replaceWith(printError(this, error)));\n        }\n    },\n\n\n    /**\n    .data\n\n    The `data` property may be set to an object.\n\n    Getting the `data` property returns the object currently being rendered.\n    Sort of. The returned data object is actually a _proxy_ of the set object.\n    This data proxy monitors mutations which the Literal template is already\n    observing, so changes to this data are reflected in the DOM immediately\n    (well, not quite immediately – literal renders changes on the next frame).\n    **/\n    data: {\n        attribute: function(json) {\n            this.data = JSON.parse(json);\n        },\n\n        get: function() {\n            const state = getInternals(this);\n            return state.renderer && state.renderer.data;\n        },\n\n        set: function(object) {\n            const state = getInternals(this);\n\n            if (state.renderer) state.renderer.remove();\n            if (!object) return;\n            state.renderer = new Literal(\n                state.template,\n                object,\n                { element: this.parentElement }\n            );\n\n            this.replaceWith(state.renderer.fragment);\n        }\n    }\n\n\n    /**\n    .consts=\"\"\n    A list of property names found on `data` that are set as consts inside the\n    template.\n    **/\n    // No definition for consts, it's picked up by Template.fromTemplate()\n}, 'stephen.band/literal/');\n"],
  "mappings": "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",
  "names": ["exec", "regex", "fn", "string", "data", "tokens", "output", "exec_default", "curry_default", "error", "regex", "reducers", "string", "reduce", "acc", "tokens", "n", "capture", "output", "exec", "capture_default", "curry_default", "$internals", "createInternals", "Element", "element", "shadow", "getInternals", "define", "constructors", "formProperties", "name", "getInternals", "supportsCustomisedBuiltIn", "parseNameTag", "capture_default", "data", "captures", "onceEvent", "toLoadPromise", "element", "resolve", "reject", "stop", "object", "getElementConstructor", "tag", "constructor", "transferProperty", "key", "value", "createShadow", "elem", "options", "shadow", "link", "create_default", "fillShadowFromTemplate", "template", "isNotUpgraded", "upgraded", "findByIs", "root", "createDescriptor", "overload", "descriptor", "fn", "definition", "lifecycle", "properties", "log", "attributes", "descriptors", "propname", "Element", "internals", "createInternals", "define", "disabled", "old", "links", "style", "promise", "div", "noop", "upgrade", "store", "e", "n", "attribute", "polyfillByRoot", "parseData", "value", "assignDataset", "object", "dataset", "keys", "i", "cacheByKey", "fn", "map", "input", "rextension", "empty", "request", "overload", "url", "cacheByKey", "src", "name", "get_default", "response", "requestData", "path", "rewriteURL", "module_default", "element", "shadow", "state", "Template", "renderer", "assignDataset", "url", "getInternals", "p", "requestData", "data", "error", "printError", "json", "object", "Literal"]
}
